var declmap = {
    "ph_buf_new": "buffer",
    "ph_buf_addref": "buffer",
    "ph_buf_delref": "buffer",
    "ph_buf_slice": "buffer",
    "ph_buf_copy": "buffer",
    "ph_buf_set": "buffer",
    "ph_buf_len": "buffer",
    "ph_buf_mem": "buffer",
    "ph_buf_concat": "buffer",
    "ph_bufq_new": "buffer",
    "ph_bufq_set_max_record_size": "buffer",
    "ph_bufq_get_max_record_size": "buffer",
    "ph_bufq_free": "buffer",
    "ph_bufq_append": "buffer",
    "ph_bufq_consume_bytes": "buffer",
    "ph_bufq_peek_bytes": "buffer",
    "ph_bufq_consume_record": "buffer",
    "ph_bufq_peek_record": "buffer",
    "ph_bufq_stm_write": "buffer",
    "ph_bufq_stm_read": "buffer",
    "ph_bufq_len": "buffer",
    "ph_config_load_config_file": "configuration",
    "ph_config_set_global": "configuration",
    "ph_config_get_global": "configuration",
    "ph_config_query": "configuration",
    "ph_config_query_int": "configuration",
    "ph_config_queryf_int": "configuration",
    "ph_config_query_double": "configuration",
    "ph_config_query_string": "configuration",
    "ph_config_query_string_cstr": "configuration",
    "ph_counter_scope_define": "counter",
    "ph_counter_scope_resolve": "counter",
    "ph_counter_scope_delref": "counter",
    "ph_counter_scope_register_counter": "counter",
    "ph_counter_scope_register_counter_block": "counter",
    "ph_counter_scope_add": "counter",
    "ph_counter_block_open": "counter",
    "ph_counter_block_add": "counter",
    "ph_counter_block_delref": "counter",
    "ph_counter_block_bulk_add": "counter",
    "ph_counter_scope_get": "counter",
    "ph_counter_scope_get_view": "counter",
    "ph_counter_scope_get_name": "counter",
    "ph_counter_scope_get_num_slots": "counter",
    "ph_counter_scope_iterator_init": "counter",
    "ph_counter_scope_iterator_next": "counter",
    "PH_LIBRARY_INIT_PRI": "defs",
    "PH_LIBRARY_INIT": "defs",
    "struct ph_library_init_entry": "defs",
    "ph_static_assert": "defs",
    "ph_panic": "defs",
    "ph_assert": "defs",
    "ph_debug_assert": "defs",
    "struct ph_dns_addrinfo": "dns",
    "ph_dns_getaddrinfo": "dns",
    "ph_dns_addrinfo_free": "dns",
    "struct ph_ht_key_def": "hashtable",
    "struct ph_ht_val_def": "hashtable",
    "ph_ht_init": "hashtable",
    "ph_ht_grow": "hashtable",
    "ph_ht_destroy": "hashtable",
    "ph_ht_free_entries": "hashtable",
    "ph_ht_set": "hashtable",
    "ph_ht_replace": "hashtable",
    "ph_ht_insert": "hashtable",
    "ph_ht_get": "hashtable",
    "ph_ht_lookup": "hashtable",
    "ph_ht_del": "hashtable",
    "ph_ht_size": "hashtable",
    "struct ph_ht_iter": "hashtable",
    "ph_ht_iter_first": "hashtable",
    "ph_ht_iter_next": "hashtable",
    "struct ph_ht_ordered_iter": "hashtable",
    "ph_ht_ordered_iter_first": "hashtable",
    "ph_ht_ordered_iter_next": "hashtable",
    "ph_ht_ordered_iter_end": "hashtable",
    "ph_hook_point_get": "hook",
    "ph_hook_point_get_cstr": "hook",
    "ph_hook_invoke_inner": "hook",
    "ph_hook_invokev": "hook",
    "ph_hook_invoke_vargs": "hook",
    "ph_hook_invocation_stop": "hook",
    "ph_hook_register": "hook",
    "ph_hook_register_cstr": "hook",
    "ph_hook_unregister": "hook",
    "ph_hook_unregister_cstr": "hook",
    "struct ph_job_def": "job",
    "struct ph_job": "job",
    "ph_job_init": "job",
    "ph_job_alloc": "job",
    "ph_job_free": "job",
    "ph_job_set_nbio": "job",
    "ph_job_set_nbio_timeout_in": "job",
    "ph_job_get_kmask": "job",
    "ph_job_clear_timer": "job",
    "ph_job_dispatch_now": "job",
    "ph_job_set_timer_at": "job",
    "ph_job_set_timer_in": "job",
    "ph_job_set_timer_in_ms": "job",
    "ph_job_set_pool": "job",
    "ph_job_set_pool_immediate": "job",
    "ph_thread_pool_define": "job",
    "ph_thread_pool_by_name": "job",
    "ph_thread_pool_signal_stop": "job",
    "ph_thread_pool_wait_stop": "job",
    "ph_thread_pool_start_workers": "job",
    "struct ph_thread_pool_stats": "job",
    "ph_thread_pool_stat": "job",
    "ph_sched_run": "job",
    "ph_sched_stop": "job",
    "ph_nbio_queue_affine_func": "job",
    "ph_job_wakeup": "job",
    "ph_job_has_pending_wakeup": "job",
    "ph_job_collector_register": "job",
    "ph_nbio_init": "job",
    "ph_json_load_stream": "json",
    "ph_json_load_string": "json",
    "ph_json_load_cstr": "json",
    "ph_json_dump_stream": "json",
    "ph_json_dump_string": "json",
    "ph_listener_new": "listener",
    "ph_listener_bind": "listener",
    "ph_listener_get_fd": "listener",
    "ph_listener_set_backlog": "listener",
    "ph_listener_enable": "listener",
    "ph_listener_set_acceptor_data": "listener",
    "ph_listener_get_acceptor_data": "listener",
    "ph_log_level_set": "log",
    "ph_log_level_get": "log",
    "ph_log": "log",
    "ph_logv": "log",
    "ph_log_stacktrace": "log",
    "ph_log_disable_stderr": "log",
    "struct ph_memtype_def": "memory",
    "ph_memtype_register": "memory",
    "ph_memtype_register_block": "memory",
    "ph_mem_alloc": "memory",
    "ph_mem_alloc_size": "memory",
    "ph_mem_realloc": "memory",
    "ph_mem_free": "memory",
    "ph_mem_strdup": "memory",
    "struct ph_mem_stats": "memory",
    "ph_mem_stat": "memory",
    "ph_mem_stat_facility": "memory",
    "ph_mem_stat_range": "memory",
    "ph_mem_type_by_name": "memory",
    "ph_library_init_openssl": "openssl",
    "ph_openssl_bio_wrap_stream": "openssl",
    "ph_stm_ssl_open": "openssl",
    "ph_openssl_bio_wrap_bufq": "openssl",
    "ph_vprintf_named_formatter_func": "printf",
    "ph_vprintf_register": "printf",
    "ph_vprintf_core": "printf",
    "ph_vsnprintf": "printf",
    "ph_snprintf": "printf",
    "ph_vfdprintf": "printf",
    "ph_fdprintf": "printf",
    "ph_vasprintf": "printf",
    "ph_vmtsprintf": "printf",
    "ph_refcnt_add": "refcnt",
    "ph_refcnt_del": "refcnt",
    "struct phenom_sockaddr": "socket",
    "ph_sockaddr_socklen": "socket",
    "ph_sockaddr_set_v4": "socket",
    "ph_sockaddr_set_v6": "socket",
    "ph_sockaddr_set_unix": "socket",
    "ph_sockaddr_set_from_addrinfo": "socket",
    "ph_sockaddr_set_from_hostent": "socket",
    "ph_sockaddr_set_port": "socket",
    "ph_sockaddr_print": "socket",
    "ph_socket_set_nonblock": "socket",
    "ph_socket_for_addr": "socket",
    "ph_socket_connect_func": "socket",
    "ph_socket_connect": "socket",
    "ph_sock_func": "socket",
    "ph_sock_openssl_handshake_func": "socket",
    "struct ph_sock": "socket",
    "ph_sock_new_from_socket": "socket",
    "ph_sock_enable": "socket",
    "ph_sock_wakeup": "socket",
    "ph_sock_free": "socket",
    "ph_sock_read_bytes_exact": "socket",
    "ph_sock_read_record": "socket",
    "ph_sock_read_line": "socket",
    "ph_sock_connect_func": "socket",
    "ph_sock_resolve_and_connect": "socket",
    "ph_sock_shutdown": "socket",
    "ph_sock_openssl_enable": "socket",
    "struct ph_stream": "stream",
    "ph_stm_read": "stream",
    "ph_stm_readahead": "stream",
    "ph_stm_write": "stream",
    "ph_stm_writev": "stream",
    "ph_stm_vprintf": "stream",
    "ph_stm_printf": "stream",
    "ph_stm_flush": "stream",
    "ph_stm_seek": "stream",
    "ph_stm_rewind": "stream",
    "ph_stm_copy": "stream",
    "ph_stm_close": "stream",
    "ph_stm_errno": "stream",
    "ph_stm_fd_open": "stream",
    "ph_stm_file_open": "stream",
    "ph_stm_string_open": "stream",
    "struct ph_stream_funcs": "stream",
    "ph_stm_make": "stream",
    "ph_stm_destroy": "stream",
    "ph_string_init_claim": "string",
    "ph_string_init_slice": "string",
    "ph_string_make_slice": "string",
    "ph_string_make_claim": "string",
    "ph_string_make_copy": "string",
    "ph_string_make_cstr": "string",
    "ph_string_make_empty": "string",
    "ph_string_addref": "string",
    "ph_string_delref": "string",
    "ph_string_append_buf": "string",
    "ph_string_append_str": "string",
    "ph_string_append_cstr": "string",
    "ph_string_append_utf16_as_utf8": "string",
    "ph_string_iterate_utf8_as_utf16": "string",
    "ph_string_is_valid_utf8": "string",
    "ph_string_len": "string",
    "ph_string_reset": "string",
    "ph_string_equal": "string",
    "ph_string_equal_caseless": "string",
    "ph_string_equal_cstr": "string",
    "ph_string_compare": "string",
    "ph_string_vprintf": "string",
    "ph_string_printf": "string",
    "ph_string_make_printf": "string",
    "PH_STRING_DECLARE_AND_COPY_CSTR": "string",
    "PH_STRING_DECLARE_CSTR_AVOID_COPY": "string",
    "ph_pipe": "sysutil",
    "ph_library_init": "sysutil",
    "ph_power_2": "sysutil",
    "ph_num_cores": "sysutil",
    "ph_mkostemp": "sysutil",
    "ph_mkostemps": "sysutil",
    "ph_strerror": "sysutil",
    "ph_strerror_r": "sysutil",
    "ph_hash_bytes_murmur": "sysutil",
    "ph_thread_spawn": "thread",
    "ph_thread_join": "thread",
    "ph_thread_self": "thread",
    "ph_thread_set_name": "thread",
    "ph_thread_set_affinity": "thread",
    "ph_thread_epoch_begin": "thread",
    "ph_thread_epoch_end": "thread",
    "ph_thread_epoch_defer": "thread",
    "ph_thread_epoch_poll": "thread",
    "ph_thread_epoch_barrier": "thread",
    "ph_thread_emitter_affinity": "thread",
    "ph_timerwheel_init": "timerwheel",
    "ph_timerwheel_disable": "timerwheel",
    "ph_timerwheel_enable": "timerwheel",
    "ph_timerwheel_remove": "timerwheel",
    "ph_timerwheel_tick": "timerwheel",
    "struct ph_variant": "variant",
    "ph_var_type": "variant",
    "ph_var_bool": "variant",
    "ph_var_bool_val": "variant",
    "ph_var_is_boolean": "variant",
    "ph_var_null": "variant",
    "ph_var_is_null": "variant",
    "ph_var_delref": "variant",
    "ph_var_addref": "variant",
    "ph_var_int": "variant",
    "ph_var_int_val": "variant",
    "ph_var_is_int": "variant",
    "ph_var_double": "variant",
    "ph_var_double_val": "variant",
    "ph_var_is_double": "variant",
    "ph_var_string_claim": "variant",
    "ph_var_string_make": "variant",
    "ph_var_string_make_cstr": "variant",
    "ph_var_string_val": "variant",
    "ph_var_is_string": "variant",
    "ph_var_array": "variant",
    "ph_var_array_size": "variant",
    "ph_var_is_array": "variant",
    "ph_var_array_append": "variant",
    "ph_var_array_append_claim": "variant",
    "ph_var_array_get": "variant",
    "ph_var_array_set_claim": "variant",
    "ph_var_array_set": "variant",
    "ph_var_object": "variant",
    "ph_var_is_object": "variant",
    "ph_var_object_size": "variant",
    "ph_var_object_set_claim_kv": "variant",
    "ph_var_object_set": "variant",
    "ph_var_object_set_claim_cstr": "variant",
    "ph_var_object_del": "variant",
    "ph_var_object_get": "variant",
    "ph_var_object_get_cstr": "variant",
    "ph_var_object_iter_first": "variant",
    "ph_var_object_iter_next": "variant",
    "ph_var_object_ordered_iter_first": "variant",
    "ph_var_object_ordered_iter_next": "variant",
    "ph_var_object_ordered_iter_end": "variant",
    "ph_var_equal": "variant",
    "ph_var_pack": "variant",
    "ph_var_vpack": "variant",
    "ph_var_unpack": "variant",
    "ph_var_vunpack": "variant",
    "ph_var_jsonpath_get": "variant"
};
var docs = {
    "README": {
        "name": "README",
        "title": "README",
        "content": "# libPhenom\n\nlibPhenom is an eventing framework for building high performance and high\nscalability systems in C\n\n## System Requirements\n\nlibPhenom is known to compile and pass its test suite on:\n\n * Linux systems with `epoll`\n * OS X\n * Illumos and Solaris style systems that have `port_create(3C)`.\n\nlibPhenom has been known to compile and pass its test suite on these\nsystems, but they have not been tried in a little while, so may require\na little bit of TLC:\n\n * BSDish systems that have the `kqueue(2)` facility, including\n   FreeBSD 9.1 and OpenBSD 5.2\n\nlibPhenom depends on:\n\n * `pkg-config` to find dependencies.\n * [Concurrency Kit](http:\/\/concurrencykit.org\/) for its excellent\n   concurrency primitives and key data structures.\n   If you are on OS\/X, you can `brew install concurrencykit`.\n   On other platforms, you will You will need to install\n   CK yourself as it is not widely distributed at this time.\n   We expect to be able to find CK using `pkg-config`.\n * **OpenSSL** is required; this should be provided by your OS.\n   You will need to install `openssl-devel` or `libssl-dev` or a similarly\n   named package.\n * **autoconf**, **automake** and **libtool** are required to build libPhenom\n\nlibPhenom works best if built with GCC version 4.3 or later, but should\nbe able to build with any C99 compiler.\n\n[![Build Status](https:\/\/travis-ci.org\/facebook\/libphenom.png)](https:\/\/travis-ci.org\/facebook\/libphenom)\n\n## Facilities\n\n * Memory management with counters - record how much of which kinds\n   of memory your application is using.\n * Jobs - decompose your application into portions of work\n   and let the phenom scheduler manage getting them done\n * streaming I\/O with buffers\n * Handy data structures (hash tables, lists, queues)\n * Variant data type to enable serialization and deserialization of\n   JSON\n * A printf implementation with registerable object formatting\n\n## Goals\n\n * Balance ease of use with performance\n * Aim to be neutral wrt. your choice of threaded or event-based dispatch\n   and work well with both.\n * Where possible, avoid contention points in our implementation so as to\n   avoid limiting scalability with the number of cores in the system.\n\n## How to use these docs\n\nIf you're reading these on http:\/\/facebook.github.io\/libphenom, simply start\ntyping and the search box will suggest topics.  You may select topics from the\n`Topics` menu or browse the header files via the `Headers` menu.\n\n## Getting it\n\nYou can obtain the sources from https:\/\/github.com\/facebook\/libphenom:\n\n```bash\n$ git clone https:\/\/github.com\/facebook\/libphenom.git\n```\n\nor [grab a snapshot of master](https:\/\/github.com\/facebook\/libphenom\/archive\/master.zip)\n\n\n\n## Build\n\n```bash\n$ .\/autogen.sh\n$ .\/configure\n$ make\n$ make check\n$ sudo make install\n```\n\n## Quick Start for using the library\n\nYou'll want to set up the main loop using something like this:\n\n```c\n\/\/ Always include phenom\/defs.h first to correctly set up the compilation env\n#include \"phenom\/defs.h\"\n#include \"phenom\/configuration.h\"\n#include \"phenom\/job.h\"\n#include \"phenom\/log.h\"\n#include \"phenom\/sysutil.h\"\n\nint main(int argc, char **argv)\n{\n  \/\/ Must be called prior to calling any other phenom functions\n  ph_library_init();\n  \/\/ Optional config file for tuning internals\n  ph_config_load_config_file(\"\/path\/to\/my\/config.json\");\n  \/\/ Enable the non-blocking IO manager\n  ph_nbio_init(0);\n\n  \/\/ Do stuff here to register client\/server stuff.\n  \/\/ This enables a very simple request\/response console\n  \/\/ that allows you to run diagnostic commands:\n  \/\/ `echo memory | nc -UC \/tmp\/phenom-debug-console`\n  \/\/ (on BSD systems, use `nc -Uc`!)\n  \/\/ The code behind this is in\n  \/\/ https:\/\/github.com\/facebook\/libphenom\/blob\/master\/corelib\/debug_console.c\n  ph_debug_console_start(\"\/tmp\/phenom-debug-console\");\n\n  \/\/ Run\n  ph_sched_run();\n\n  return 0;\n}\n```\n\nAnd compile it using something like this: (you need optimization enabled)\n\n```bash\n$ gcc -O2 main.c `pkg-config libphenom --cflags --libs`\n```\n\n(this will link against `libphenom`).\n\nA more detailed example can be found at https:\/\/github.com\/facebook\/libphenom\/blob\/master\/examples\/echo.c\n\nWant more inspiration?  Take a look at the code in the test suite.\n\n## Status\n\nWe're still hacking and evolving this library, so there may be some rough\nedges.  We're very open to feedback; check out the Contributing section\nbelow.\n\n## Getting Help\n\nWe've started an IRC channel for realtime conversations; join us in\n[#phenom @ freenode](irc:\/\/#phenom@chat.freenode.net\/)\n\n## Contributing\n\nIf you're thinking of hacking on libPhenom we'd love to hear from you!\nFeel free to use the Github issue tracker and pull requests to discuss and\nsubmit code changes.\n\nWe (Facebook) have to ask for a \"Contributor License Agreement\" from someone\nwho sends in a patch or code that we want to include in the codebase.  This is\na legal requirement; a similar situation applies to Apache and other ASF\nprojects.\n\nIf we ask you to fill out a CLA we'll direct you to [our online CLA\npage](https:\/\/developers.facebook.com\/opensource\/cla) where you can complete it\neasily.  We use the same form as the Apache CLA so that friction is minimal.\n\n## License\n\nlibPhenom is made available under the terms of the Apache License 2.0.  See the\nLICENSE file that accompanies this distribution for the full text of the\nlicense.\n\n",
        "decl_titles": []
    },
    "buffer": {
        "name": "buffer",
        "title": "buffer",
        "content": "\n# Buffers\n\nThe libPhenom buffer API allows for fixed-size buffers to be used reasonably\nefficiently in an application.  The API provides a couple of benefits:\n\n* Slices can be made over a region of another buffer.  The slice allows\n  for the region to be referenced without copying, while still safely\n  managing the underlying storage\n* The object representation of a string buffer means that we can avoid\n  string interning costs when integrating with runtimes such as Lua\n* Discontiguous buffers can be used to accumulate data.  The fixed size\n  of these buffers helps to reduce heap fragmentation.  An API is provided\n  to locate and slice (or duplicate if needed) a delimited record (such\n  as CRLF delimited lines)\n\n### ph_buf_new\n\n```c\nph_buf_t *ph_buf_new(uint64_t size);\n```\n\n\n*Create a new buffer*\n\n\nThe buffer will be at least the size that you requested; the implementation\nmay decide to round your allocation up to one of a set of common buffer\nsizes.\n\nIf you specify 0 for the size, a default buffer size will be selected\nfor you.\n\nThe contents of the buffer are undefined.\n\nReturns a reference to the buffer.  When the final reference is released,\nthe storage is reclaimed.\n\nUse ph_buf_delref() to release a reference to a buffer.\n\n### ph_buf_addref\n\n```c\nvoid ph_buf_addref(ph_buf_t *buf);\n```\n\n\n*Add a reference to a buffer*\n\n\n### ph_buf_delref\n\n```c\nvoid ph_buf_delref(ph_buf_t *buf);\n```\n\n\n*Release a reference to a buffer*\n\n\n### ph_buf_slice\n\n```c\nph_buf_t *ph_buf_slice(ph_buf_t *buf, uint64_t start, uint64_t len);\n```\n\n\n*Create a slice over a buffer*\n\n\nCreates a new buffer object that references a region in another buffer.\n\nThe slice takes a reference on the other buffer; when the slice is\ndestroyed, it will release that reference.\n\nOperating on the slice operates on the specified region of the original\nbuffer.\n\nIf len == 0, len is interpreted as the length that covers the region from\nthe start to the end of the buffer.\n\n### ph_buf_copy\n\n```c\nbool ph_buf_copy(ph_buf_t *src, ph_buf_t *dest, uint64_t start, uint64_t len,\n    uint64_t dest_start);\n```\n\n\n*Copy data from one buffer to another*\n\n\nCopies the specified range of bytes from the source buffer to the\ndestination buffer at the specified offset.\n\nThe source and destination buffer may be the same object; the memory\nranges may overlap.\n\nIf either the source or destination range is out of bounds, no copying\ntakes place and this function will return false.\n\nOtherwise, returns true\n\n### ph_buf_set\n\n```c\nbool ph_buf_set(ph_buf_t *buf, int value, uint64_t start, uint64_t len);\n```\n\n\n*Fills a buffer region with a byte value*\n\n\nLogically equivalent to memset(3), but operates on a range in a buffer\n\n### ph_buf_len\n\n```c\nuint64_t ph_buf_len(ph_buf_t *buf);\n```\n\n\n*Returns the size of the buffer*\n\n\nReturn the number of bytes of available storage in the buffer; this is\nthe size of the allocated storage space.  The buffer API doesn't track\nwhether bytes are \"used\" (there is no cursor, since slices make this\nawkward to track), so this is simply the raw number of bytes in the\nmemory backing the buffer object.\n\n### ph_buf_mem\n\n```c\nuint8_t *ph_buf_mem(ph_buf_t *buf);\n```\n\n\n*Returns a pointer to the start of the buffer memory*\n\n\nThis is the raw buffer memory; you are responsible for constraining your\nread\/writes to this region within the length specified by ph_buf_len().\n\n### ph_buf_concat\n\n```c\nph_buf_t *ph_buf_concat(uint64_t length, uint32_t num_bufs,\n    ph_buf_t **buffers, uint64_t first_offset);\n```\n\n\n*Concatenate a sequence of buffers together*\n\n\nAllocates a buffer that is large enough to hold the total number of\nbytes specified, then copies data from the sequence of buffers into\nthis new buffer.\n\nThis is useful when matching a record across a series of buffers and\nthen wanting to pass the data to code that requires a contiguous memory\nbuffer.\n\nIf length == 0, the function will query the total length of the buffers\nand use that as the length.\n\n`first_offset` specifies the number of bytes to skip in the first buffer.\n\n### ph_bufq_new\n\n```c\nph_bufq_t *ph_bufq_new(uint64_t max_size);\n```\n\n\n*Create a new buffer queue*\n\n\nA buffer queue allows buffering of buffers in a FIFO manner.\nThis is useful to implement a segmented read or write buffer with an\nupper bound on buffer size.\n\nA freshly created buffer queued is populated with an initial ph_buf_t\nwith the default size.\n\n### ph_bufq_set_max_record_size\n\n```c\nvoid ph_bufq_set_max_record_size(ph_bufq_t *buf, uint64_t size);\n```\n\n\n*Set a buffer queue's max record size*\n\n\nSet the buffer queue's record size to a specified maximum,\nafter which it will not go over.\n\nThis does not modify the contents of the buffer, only sets future limits.\n\n\n### ph_bufq_get_max_record_size\n\n```c\nuint64_t ph_bufq_get_max_record_size(ph_bufq_t *buf);\n```\n\n\n*Get a buffer's size*\n\n\nGets the maximum size of a record in this buffer queue in bytes.\n\n### ph_bufq_free\n\n```c\nvoid ph_bufq_free(ph_bufq_t *q);\n```\n\n\n*Destroy a buffer queue*\n\n\nReleases all of its resources\n\n### ph_bufq_append\n\n```c\nph_result_t ph_bufq_append(ph_bufq_t *q, const void *buf, uint64_t len,\n    uint64_t *added_bytes);\n```\n\n\n*Accumulate data into a buffer queue*\n\n\nCopies the data from the provided raw buffer pointer into the buffer\nqueue.  Attempts to top off the \"last\" logical ph_buf_t in the queue.\nIf the data being added won't fit in the buffer, a new buffer is allocated\nand appended.\n\nIf the data to be appended would exceed the maximum size of the buffer\nqueue, only the data up to the size limit will be added.\n\nReturns PH_OK on success (which may mean partial success), or an error\ncode on failure (such as failure to allocate buffers).\n\nPopulates the number of bytes that were consumed in the added_bytes\nparameter.\n\n### ph_bufq_consume_bytes\n\n```c\nph_buf_t *ph_bufq_consume_bytes(ph_bufq_t *q, uint64_t len);\n```\n\n\n*Attempts to de-queue data from a buffer queue*\n\n\nIf the requested number of bytes are available in the queue, concatenate\nthem into a contiguous buffer and return that buffer.\n\nThose bytes are considered read and the queue will\nrelease its reference on the associated buffers, potentially releasing\nmemory if those references fall to zero.\n\nIf the requested number of bytes are not present, returns NULL.\n\n### ph_bufq_peek_bytes\n\n```c\nph_buf_t *ph_bufq_peek_bytes(ph_bufq_t *q, uint64_t len);\n```\n\n\n*Peek at data in the buffer queue*\n\n\nIf the requested number of bytes are available in the queue, concatenate\nthem into a contiguous buffer and return that buffer.\n\nThe state of the queue is left unchanged.\n\nIf the requested number of bytes are not present, returns NULL.\n\n### ph_bufq_consume_record\n\n```c\nph_buf_t *ph_bufq_consume_record(ph_bufq_t *q, const char *delim,\n    uint32_t delim_len);\n```\n\n\n*Attempts to de-queue a record from a buffer queue*\n\n\nSearches the buffer queue until it finds the delimiter text.\nIf the delimiter text is not found, returns NULL.\n\nIf the delimiter text is found, constructs a buffer to reference\nthat memory region and dequeues it as though ph_bufq_consume_bytes()\nwas called with the appropriate length to the end of the delimiter text.\n\nIf max_record_size is set, and the size of the data consumed is larger than\nthat size, we will begin truncating that data, and set errno to EOVERFLOW\nupon returning from the function.\n\nWhen data is truncated, it will be truncated from the left side\nand will preserve the record delimiter on the right hand side. This\nallows the application to remain in sync with the protocol while\nmaintaining an upper bound on the buffered data size.\n\nIf the delim_len size exceeds 16 bytes, then max_record_size will\nnot be respected.\n\nThe delimiter is included in the returned buffer.\n\n### ph_bufq_peek_record\n\n```c\nph_buf_t *ph_bufq_peek_record(ph_bufq_t *q, const char *delim,\n    uint32_t delim_len);\n```\n\n\n*Attempts to peek at a record from a buffer queue*\n\n\nSearches the buffer queue until it finds the delimiter text.\nIf the delimiter text is not found, returns NULL.\n\nIf the delimiter text is found, constructs a buffer to reference\nthat memory region and peeks at it as though ph_bufq_peek_bytes()\nwas called with the appropriate length to the end of the delimiter text.\n\nIf max_record_size is set, and the size of the data consumed is larger than\nthat size, we will begin truncating that data, and set errno to EOVERFLOW\nupon returning from the function.\n\nWhen data is truncated, it will be truncated from the left side\nand will preserve the record delimiter on the right hand side. This\nallows the application to remain in sync with the protocol while\nmaintaining an upper bound on the buffered data size.\n\nIf the delim_len size exceeds 16 bytes, then max_record_size will\nnot be respected.\n\nThe delimiter is included in the returned buffer.\n\n### ph_bufq_stm_write\n\n```c\nbool ph_bufq_stm_write(ph_bufq_t *q, ph_stream_t *stm, uint64_t *nwrote);\n```\n\n\n*Attempts to consume data data from a queue and write to a stream*\n\n\nConstructs an iovec representing the queued buffers up to an internal\nlimit of iovec elements, then calls the writev implementation of the stream,\nignoring any buffering that may be present on the stream.  It is recommended\nthat you use an unbuffered stream, but if you decide not to, you are responsible\nfor ensuring that the stream has been flushed prior to calling this function.\n\nAny successfully written bytes are considered consumed and the associated\nstorage may be released.\n\nReturns true on success (which will likely be a partial write) and sets\n*nwrote to the number of bytes that were consumed.\n\nReturns false on failure; you may call ph_stm_errno() to determine what\nwent wrong.\n\n### ph_bufq_stm_read\n\n```c\nbool ph_bufq_stm_read(ph_bufq_t *q, ph_stream_t *stm, uint64_t *nread);\n```\n\n\n*Attempts to read data from a stream and accumulate it in bufq*\n\n\nIf the bufq has a partially filled buffer at the tail, ph_stm_read() will\nbe invoked to attempt to fill that space.\n\nIf not bufs with space are present in the bufq, a default buffer will be\nadded and ph_stm_read() will be invoked to fill that space.\n\nThis function will invoke ph_stm_read() at most once per call.\n\n### ph_bufq_len\n\n```c\nuint64_t ph_bufq_len(ph_bufq_t *q);\n```\n\n\n*Returns the number of bytes to be consumed*\n\n",
        "decl_titles": [
            "ph_buf_new",
            "ph_buf_addref",
            "ph_buf_delref",
            "ph_buf_slice",
            "ph_buf_copy",
            "ph_buf_set",
            "ph_buf_len",
            "ph_buf_mem",
            "ph_buf_concat",
            "ph_bufq_new",
            "ph_bufq_set_max_record_size",
            "ph_bufq_get_max_record_size",
            "ph_bufq_free",
            "ph_bufq_append",
            "ph_bufq_consume_bytes",
            "ph_bufq_peek_bytes",
            "ph_bufq_consume_record",
            "ph_bufq_peek_record",
            "ph_bufq_stm_write",
            "ph_bufq_stm_read",
            "ph_bufq_len"
        ],
        "raw_content": "\/*\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_BUFFER_H\n#define PHENOM_BUFFER_H\n\n\/**\n * # Buffers\n *\n * The libPhenom buffer API allows for fixed-size buffers to be used reasonably\n * efficiently in an application.  The API provides a couple of benefits:\n *\n * * Slices can be made over a region of another buffer.  The slice allows\n *   for the region to be referenced without copying, while still safely\n *   managing the underlying storage\n * * The object representation of a string buffer means that we can avoid\n *   string interning costs when integrating with runtimes such as Lua\n * * Discontiguous buffers can be used to accumulate data.  The fixed size\n *   of these buffers helps to reduce heap fragmentation.  An API is provided\n *   to locate and slice (or duplicate if needed) a delimited record (such\n *   as CRLF delimited lines)\n *\/\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/stream.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_buf;\ntypedef struct ph_buf ph_buf_t;\n\nstruct ph_bufq;\ntypedef struct ph_bufq ph_bufq_t;\n\n\/** Create a new buffer\n *\n * The buffer will be at least the size that you requested; the implementation\n * may decide to round your allocation up to one of a set of common buffer\n * sizes.\n *\n * If you specify 0 for the size, a default buffer size will be selected\n * for you.\n *\n * The contents of the buffer are undefined.\n *\n * Returns a reference to the buffer.  When the final reference is released,\n * the storage is reclaimed.\n *\n * Use ph_buf_delref() to release a reference to a buffer.\n *\/\nph_buf_t *ph_buf_new(uint64_t size);\n\n\/** Add a reference to a buffer *\/\nvoid ph_buf_addref(ph_buf_t *buf);\n\n\/** Release a reference to a buffer *\/\nvoid ph_buf_delref(ph_buf_t *buf);\n\n\/** Create a slice over a buffer\n *\n * Creates a new buffer object that references a region in another buffer.\n *\n * The slice takes a reference on the other buffer; when the slice is\n * destroyed, it will release that reference.\n *\n * Operating on the slice operates on the specified region of the original\n * buffer.\n *\n * If len == 0, len is interpreted as the length that covers the region from\n * the start to the end of the buffer.\n *\/\nph_buf_t *ph_buf_slice(ph_buf_t *buf, uint64_t start, uint64_t len);\n\n\/** Copy data from one buffer to another\n *\n * Copies the specified range of bytes from the source buffer to the\n * destination buffer at the specified offset.\n *\n * The source and destination buffer may be the same object; the memory\n * ranges may overlap.\n *\n * If either the source or destination range is out of bounds, no copying\n * takes place and this function will return false.\n *\n * Otherwise, returns true\n *\/\nbool ph_buf_copy(ph_buf_t *src, ph_buf_t *dest, uint64_t start, uint64_t len,\n    uint64_t dest_start);\n\nbool ph_buf_copy_mem(ph_buf_t *dest, const void *mem,\n    uint64_t len, uint64_t dest_start);\n\n\/** Fills a buffer region with a byte value\n *\n * Logically equivalent to memset(3), but operates on a range in a buffer\n *\/\nbool ph_buf_set(ph_buf_t *buf, int value, uint64_t start, uint64_t len);\n\n\/** Returns the size of the buffer\n *\n * Return the number of bytes of available storage in the buffer; this is\n * the size of the allocated storage space.  The buffer API doesn&#039;t track\n * whether bytes are &quot;used&quot; (there is no cursor, since slices make this\n * awkward to track), so this is simply the raw number of bytes in the\n * memory backing the buffer object.\n *\/\nuint64_t ph_buf_len(ph_buf_t *buf);\n\n\/** Returns a pointer to the start of the buffer memory\n *\n * This is the raw buffer memory; you are responsible for constraining your\n * read\/writes to this region within the length specified by ph_buf_len().\n *\/\nuint8_t *ph_buf_mem(ph_buf_t *buf);\n\n\/** Concatenate a sequence of buffers together\n *\n * Allocates a buffer that is large enough to hold the total number of\n * bytes specified, then copies data from the sequence of buffers into\n * this new buffer.\n *\n * This is useful when matching a record across a series of buffers and\n * then wanting to pass the data to code that requires a contiguous memory\n * buffer.\n *\n * If length == 0, the function will query the total length of the buffers\n * and use that as the length.\n *\n * `first_offset` specifies the number of bytes to skip in the first buffer.\n *\/\nph_buf_t *ph_buf_concat(uint64_t length, uint32_t num_bufs,\n    ph_buf_t **buffers, uint64_t first_offset);\n\n\/** Create a new buffer queue\n *\n * A buffer queue allows buffering of buffers in a FIFO manner.\n * This is useful to implement a segmented read or write buffer with an\n * upper bound on buffer size.\n *\n * A freshly created buffer queued is populated with an initial ph_buf_t\n * with the default size.\n *\/\nph_bufq_t *ph_bufq_new(uint64_t max_size);\n\n\/** Set a buffer queue&#039;s max record size\n *\n * Set the buffer queue&#039;s record size to a specified maximum,\n * after which it will not go over.\n *\n * This does not modify the contents of the buffer, only sets future limits.\n *\n *\/\nvoid ph_bufq_set_max_record_size(ph_bufq_t *buf, uint64_t size);\n\n\/** Get a buffer&#039;s size\n *\n * Gets the maximum size of a record in this buffer queue in bytes.\n *\/\nuint64_t ph_bufq_get_max_record_size(ph_bufq_t *buf);\n\n\/** Destroy a buffer queue\n *\n * Releases all of its resources\n *\/\nvoid ph_bufq_free(ph_bufq_t *q);\n\n\/** Accumulate data into a buffer queue\n *\n * Copies the data from the provided raw buffer pointer into the buffer\n * queue.  Attempts to top off the &quot;last&quot; logical ph_buf_t in the queue.\n * If the data being added won&#039;t fit in the buffer, a new buffer is allocated\n * and appended.\n *\n * If the data to be appended would exceed the maximum size of the buffer\n * queue, only the data up to the size limit will be added.\n *\n * Returns PH_OK on success (which may mean partial success), or an error\n * code on failure (such as failure to allocate buffers).\n *\n * Populates the number of bytes that were consumed in the added_bytes\n * parameter.\n *\/\nph_result_t ph_bufq_append(ph_bufq_t *q, const void *buf, uint64_t len,\n    uint64_t *added_bytes);\n\n\/** Attempts to de-queue data from a buffer queue\n *\n * If the requested number of bytes are available in the queue, concatenate\n * them into a contiguous buffer and return that buffer.\n *\n * Those bytes are considered read and the queue will\n * release its reference on the associated buffers, potentially releasing\n * memory if those references fall to zero.\n *\n * If the requested number of bytes are not present, returns NULL.\n *\/\nph_buf_t *ph_bufq_consume_bytes(ph_bufq_t *q, uint64_t len);\n\n\/** Peek at data in the buffer queue\n *\n * If the requested number of bytes are available in the queue, concatenate\n * them into a contiguous buffer and return that buffer.\n *\n * The state of the queue is left unchanged.\n *\n * If the requested number of bytes are not present, returns NULL.\n *\/\nph_buf_t *ph_bufq_peek_bytes(ph_bufq_t *q, uint64_t len);\n\n\/** Attempts to de-queue a record from a buffer queue\n *\n * Searches the buffer queue until it finds the delimiter text.\n * If the delimiter text is not found, returns NULL.\n *\n * If the delimiter text is found, constructs a buffer to reference\n * that memory region and dequeues it as though ph_bufq_consume_bytes()\n * was called with the appropriate length to the end of the delimiter text.\n *\n * If max_record_size is set, and the size of the data consumed is larger than\n * that size, we will begin truncating that data, and set errno to EOVERFLOW\n * upon returning from the function.\n *\n * When data is truncated, it will be truncated from the left side\n * and will preserve the record delimiter on the right hand side. This\n * allows the application to remain in sync with the protocol while\n * maintaining an upper bound on the buffered data size.\n *\n * If the delim_len size exceeds 16 bytes, then max_record_size will\n * not be respected.\n *\n * The delimiter is included in the returned buffer.\n *\/\nph_buf_t *ph_bufq_consume_record(ph_bufq_t *q, const char *delim,\n    uint32_t delim_len);\n\n\/** Attempts to peek at a record from a buffer queue\n *\n * Searches the buffer queue until it finds the delimiter text.\n * If the delimiter text is not found, returns NULL.\n *\n * If the delimiter text is found, constructs a buffer to reference\n * that memory region and peeks at it as though ph_bufq_peek_bytes()\n * was called with the appropriate length to the end of the delimiter text.\n *\n * If max_record_size is set, and the size of the data consumed is larger than\n * that size, we will begin truncating that data, and set errno to EOVERFLOW\n * upon returning from the function.\n *\n * When data is truncated, it will be truncated from the left side\n * and will preserve the record delimiter on the right hand side. This\n * allows the application to remain in sync with the protocol while\n * maintaining an upper bound on the buffered data size.\n *\n * If the delim_len size exceeds 16 bytes, then max_record_size will\n * not be respected.\n *\n * The delimiter is included in the returned buffer.\n *\/\nph_buf_t *ph_bufq_peek_record(ph_bufq_t *q, const char *delim,\n    uint32_t delim_len);\n\n\/** Attempts to consume data data from a queue and write to a stream\n *\n * Constructs an iovec representing the queued buffers up to an internal\n * limit of iovec elements, then calls the writev implementation of the stream,\n * ignoring any buffering that may be present on the stream.  It is recommended\n * that you use an unbuffered stream, but if you decide not to, you are responsible\n * for ensuring that the stream has been flushed prior to calling this function.\n *\n * Any successfully written bytes are considered consumed and the associated\n * storage may be released.\n *\n * Returns true on success (which will likely be a partial write) and sets\n * *nwrote to the number of bytes that were consumed.\n *\n * Returns false on failure; you may call ph_stm_errno() to determine what\n * went wrong.\n *\/\nbool ph_bufq_stm_write(ph_bufq_t *q, ph_stream_t *stm, uint64_t *nwrote);\n\n\/** Attempts to read data from a stream and accumulate it in bufq\n *\n * If the bufq has a partially filled buffer at the tail, ph_stm_read() will\n * be invoked to attempt to fill that space.\n *\n * If not bufs with space are present in the bufq, a default buffer will be\n * added and ph_stm_read() will be invoked to fill that space.\n *\n * This function will invoke ph_stm_read() at most once per call.\n *\/\nbool ph_bufq_stm_read(ph_bufq_t *q, ph_stream_t *stm, uint64_t *nread);\n\n\/** Returns the number of bytes to be consumed *\/\nuint64_t ph_bufq_len(ph_bufq_t *q);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "configuration": {
        "name": "configuration",
        "title": "configuration",
        "content": "\n# Configuration\n\nlibPhenom provides a relatively simple configuration facility; the\nprocess has a global configuration expressed as a variant object.\n\nThere is limited support for mutating the configuration: any\nvalues or objects you obtain via the configuration API **MUST**\nbe treated as read-only as they may be accessed from any thread\nconcurrently.\n\nIf you need to mutate the configuration at runtime (not recommended),\nthen you need to replace the entire configuration object with the\nnew generation of the configuration, and then dispose of the old\none.\n\n### ph_config_load_config_file\n\n```c\nbool ph_config_load_config_file(const char *config_path);\n```\n\n\n*Load the configuration file*\n\n\n`config_path` may be NULL, in which case a default path is\ndetermined by checking for the following:\n\n* `getenv(\"PHENOM_CONFIG_FILE\")`\n\nThe first of these that yields a file that exists will be used\nas the value for `config_path`.\n\nIf the filename ends with `.json`, then the file will be\ninterpreted as containing JSON text.\n\nA future version may support an alternative format, such as TOML\nhttps:\/\/github.com\/mojombo\/toml.\n\nIf no filename suffix is recognized, the file will be loaded as JSON.\n\nReturns `true` if a configuration file was loaded, `false` otherwise.\n\n### ph_config_set_global\n\n```c\nvoid ph_config_set_global(ph_variant_t *cfg);\n```\n\n\n*Replace the global configuration*\n\n\nSet the configuration to a new generation using the specified\nvariant value.\n\nThe variant will be considered \"owned\" by the config system\nand must be treated as read-only from this point forwards.\n\nThe old generation, if any, will be released.\n\n### ph_config_get_global\n\n```c\nph_variant_t *ph_config_get_global(void);\n```\n\n\n*Get the global configuration*\n\n\nReturns a reference to the global configuration.\nYou must ph_var_delref() it when you no longer need it.\n\nIf there is no global configuration, returns a variant\nrepresenting the null value.\n\n### ph_config_query\n\n```c\nph_variant_t *ph_config_query(const char *query);\n```\n\n\n*Perform a JSONPath query on the global configuration*\n\n\nReturns a reference on the value it found, if any, else\nreturns a NULL pointer.\n\nYou must release the returned value using ph_var_delref() when\nyou no longer need the value.\n\nSee the Variant documentation for details on the JSONPath\nsupport provided by phenom.\n\n### ph_config_query_int\n\n```c\nint64_t ph_config_query_int(const char *query, int64_t defval);\n```\n\n\n*Perform a JSONPath query and return an integer value*\n\n\nA convenience wrapper around performing a global query\nand interpreting the result as an integer with a default\nvalue.\n\n### ph_config_queryf_int\n\n```c\nint64_t ph_config_queryf_int(int64_t defval, const char *query, ...);\n```\n\n\n*Perform a JSONPath query and return an integer value*\n\n\nA convenience wrapper around performing a global query\nand interpreting the result as an integer with a default\nvalue.\n\nThis function expands query using ph_vprintf_core() so that\nyou can parameterize your lookup.\n\n### ph_config_query_double\n\n```c\ndouble ph_config_query_double(const char *query, double defval);\n```\n\n\n*Perform a JSONPath query and return a double value*\n\n\nA convenience wrapper around performing a global query\nand interpreting the result as a double with a default\nvalue.\n\n### ph_config_query_string\n\n```c\nph_string_t *ph_config_query_string(const char *query, ph_string_t *defval);\n```\n\n\n*Perform a JSONPath query and return a string value*\n\n\nA convenience wrapper around performing a global query\nand interpreting the result as a string with a default\nvalue.\n\nYou must call ph_string_delref() on the returned string when\nyou no longer need it.\n\n### ph_config_query_string_cstr\n\n```c\nph_string_t *ph_config_query_string_cstr(const char *query, const char *defval);\n```\n\n\n*Perform a JSONPath query and return a string value*\n\n\nA convenience wrapper around performing a global query\nand interpreting the result as a string with a default\nvalue.\n\nYou must call ph_string_delref() on the returned string when\nyou no longer need it.\n\nNote that this will create a string wrapper for defval if it does not\nexist.  If you are querying for this value frequently, you should\nconsider using ph_config_query_string instead to reduce your heap overhead.\n",
        "decl_titles": [
            "ph_config_load_config_file",
            "ph_config_set_global",
            "ph_config_get_global",
            "ph_config_query",
            "ph_config_query_int",
            "ph_config_queryf_int",
            "ph_config_query_double",
            "ph_config_query_string",
            "ph_config_query_string_cstr"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_CONFIGURATION_H\n#define PHENOM_CONFIGURATION_H\n\n\/**\n * # Configuration\n *\n * libPhenom provides a relatively simple configuration facility; the\n * process has a global configuration expressed as a variant object.\n *\n * There is limited support for mutating the configuration: any\n * values or objects you obtain via the configuration API **MUST**\n * be treated as read-only as they may be accessed from any thread\n * concurrently.\n *\n * If you need to mutate the configuration at runtime (not recommended),\n * then you need to replace the entire configuration object with the\n * new generation of the configuration, and then dispose of the old\n * one.\n *\/\n\n#include &quot;phenom\/variant.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/** Load the configuration file\n *\n * `config_path` may be NULL, in which case a default path is\n * determined by checking for the following:\n *\n * * `getenv(&quot;PHENOM_CONFIG_FILE&quot;)`\n *\n * The first of these that yields a file that exists will be used\n * as the value for `config_path`.\n *\n * If the filename ends with `.json`, then the file will be\n * interpreted as containing JSON text.\n *\n * A future version may support an alternative format, such as TOML\n * https:\/\/github.com\/mojombo\/toml.\n *\n * If no filename suffix is recognized, the file will be loaded as JSON.\n *\n * Returns `true` if a configuration file was loaded, `false` otherwise.\n *\/\nbool ph_config_load_config_file(const char *config_path);\n\n\/** Replace the global configuration\n *\n * Set the configuration to a new generation using the specified\n * variant value.\n *\n * The variant will be considered &quot;owned&quot; by the config system\n * and must be treated as read-only from this point forwards.\n *\n * The old generation, if any, will be released.\n *\/\nvoid ph_config_set_global(ph_variant_t *cfg);\n\n\/** Get the global configuration\n *\n * Returns a reference to the global configuration.\n * You must ph_var_delref() it when you no longer need it.\n *\n * If there is no global configuration, returns a variant\n * representing the null value.\n *\/\nph_variant_t *ph_config_get_global(void);\n\n\/** Perform a JSONPath query on the global configuration\n *\n * Returns a reference on the value it found, if any, else\n * returns a NULL pointer.\n *\n * You must release the returned value using ph_var_delref() when\n * you no longer need the value.\n *\n * See the Variant documentation for details on the JSONPath\n * support provided by phenom.\n *\/\nph_variant_t *ph_config_query(const char *query);\n\n\/** Perform a JSONPath query and return an integer value\n *\n * A convenience wrapper around performing a global query\n * and interpreting the result as an integer with a default\n * value.\n *\/\nint64_t ph_config_query_int(const char *query, int64_t defval);\n\n\/** Perform a JSONPath query and return an integer value\n *\n * A convenience wrapper around performing a global query\n * and interpreting the result as an integer with a default\n * value.\n *\n * This function expands query using ph_vprintf_core() so that\n * you can parameterize your lookup.\n *\/\nint64_t ph_config_queryf_int(int64_t defval, const char *query, ...);\n\n\/** Perform a JSONPath query and return a double value\n *\n * A convenience wrapper around performing a global query\n * and interpreting the result as a double with a default\n * value.\n *\/\ndouble ph_config_query_double(const char *query, double defval);\n\n\/** Perform a JSONPath query and return a string value\n *\n * A convenience wrapper around performing a global query\n * and interpreting the result as a string with a default\n * value.\n *\n * You must call ph_string_delref() on the returned string when\n * you no longer need it.\n *\/\nph_string_t *ph_config_query_string(const char *query, ph_string_t *defval);\n\n\/** Perform a JSONPath query and return a string value\n *\n * A convenience wrapper around performing a global query\n * and interpreting the result as a string with a default\n * value.\n *\n * You must call ph_string_delref() on the returned string when\n * you no longer need it.\n *\n * Note that this will create a string wrapper for defval if it does not\n * exist.  If you are querying for this value frequently, you should\n * consider using ph_config_query_string instead to reduce your heap overhead.\n *\/\nph_string_t *ph_config_query_string_cstr(const char *query, const char *defval);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "counter": {
        "name": "counter",
        "title": "counter",
        "content": "\n# Counters\nThe counter subsystem provides a set of functions that\nallows the application to build a hierarchy of 64-bit\ncounter values.\n\nThese values may be modified and queried atomically via the provided API.\n\nFunctions are provided to introspect the hierarchy and groups of\nrelated counters can be read consistently.  Note that the system does\nnot provide a means for snapshotting the entire counter hierarchy.\n\nCounters are implemented such that individual threads may\nmanipulate their values uncontested (with no locking!), but allowing\nfor a reader to obtain a consistent view of a related set of counters.\n\n## Overview\n\nFirst establish the counter scope, and register counter nodes within\nit:\n\n```\nph_counter_scope_t *myscope = ph_counter_scope_define(NULL, \"myscope\", 8);\nconst char *names[2] = {\"sent\", \"recvd\"};\n#define MY_SENT_COUNTER_SLOT 0\n#define MY_RECVD_COUNTER_SLOT 1\nph_counter_scope_register_counter_block(myscope, 2, 0, names);\n```\n\nThen, elsewhere in you program, adjust the counter values.  There are\ntwo interfaces for this; one is the slow and convenient way:\n\n```\n\/\/ Bump the sent counter by 1.  Slower and more convenient\nph_counter_scope_add(myscope, MY_SENT_COUNTER_SLOT, 1);\n```\n\nThe preferred approach is to open a handle to your thread-local\ncounter block.  This is ideal if you are driving your thread and\ncan maintain that block handle in a local variable.  Alternatively,\nif you are running a tight loop or are updating a series of counters,\nyou should prefer to open the block in this way.  **Note that the block\nreturned can only have its counters modified on the same thread that\nobtained the block**:\n\n```\nph_counter_block_t *block = ph_counter_block_open(myscope);\n\/\/ Bump the sent counter by 1\nph_counter_block_add(block, MY_SENT_COUNTER_SLOT, 1);\n```\n\nTo make an update to multiple counters at once:\n\n```\nuint8_t slots[2] = { MY_SENT_COUNTER_SLOT, MY_RECVD_COUNTER_SLOT };\nint64_t values[2] = { 4, 5 };\n\/\/ adds 4 to the sent counter and 5 to the recvd counter\nph_counter_block_bulk_add(block, 2, slots, values);\n```\n\n### ph_counter_scope_define\n\n```c\nph_counter_scope_t *ph_counter_scope_define(\n    ph_counter_scope_t *parent,\n    const char *path,\n    uint8_t max_counters);\n```\n\n\n*Defines a new counter scope.*\n\n\nCounter scopes contain one or more counter values that\nare logically grouped together.\n\nThe counter subsystem provides fast update access to the\nindividual counter values and a mechanism for reading a\nconsistent snapshot of the counter values in the scope.\n\n* `parent` - optional relative counter scope. May be NULL.\n* `path` - scope name for this set of counters. Must not be NULL.\n* `max_counters` - hint as to the max number of counters that must\n   be available for use in this counter scope.  The system\n   only guarantees that this many slots are available, which\n   may restrict the number of counters that can be dynamically\n   added later.\n\nReturns a counter scope instance.  The caller owns a reference\nto this instance and must release it via ph_counter_scope_delref()\nwhen it is no longer needed.\n\n### ph_counter_scope_resolve\n\n```c\nph_counter_scope_t *ph_counter_scope_resolve(\n    ph_counter_scope_t *parent,\n    const char *path);\n```\n\n\n*Resolve a named counter scope*\n\n\nGiven a relative scope and name, resolves it to a scope instance.\n\n* `parent` - optional relative counter scope. May be NULL.\n* `path` - scope name to be resolved. Must not be NULL.\n\nReturns a counter scope instance.  The caller owns a reference\nto this instance and must release it via ph_counter_scope_delref().\n\n### ph_counter_scope_delref\n\n```c\nvoid ph_counter_scope_delref(ph_counter_scope_t *scope);\n```\n\n\n*Release a reference to a counter scope.*\n\n\nWhen no more references to a scope remain, it is destroyed.\nTo delete a counter scope from the counter subsystem, it must be\nunlinked from its parent scope (not currently supported).\n\n* `scope` - the scope to be released\n\n### ph_counter_scope_register_counter\n\n```c\nuint8_t ph_counter_scope_register_counter(\n    ph_counter_scope_t *scope,\n    const char *name);\n```\n\n\n*Registers a counter name in a counter scope.*\n\n\nReturns a counter slot offset or `PH_COUNTER_INVALID`\n\n* `scope` - the scope in which the counter should be registered\n* `name` - the name of the counter\n\nIt is an error to register a counter with the same name as a child\nscope.\n\nIf the counter cannot be registered, returns `PH_COUNTER_INVALID`.\n\n### ph_counter_scope_register_counter_block\n\n```c\nbool ph_counter_scope_register_counter_block(\n    ph_counter_scope_t *scope,\n    uint8_t num_slots,\n    uint8_t first_slot,\n    const char **names\n);\n```\n\n\n*Registers a block of counter names and values in a counter scope.*\n\n\nReturns true if the registration matched the desired slots, false otherwise\n\n* `scope` - the scope in which the counters should be registered.\n* `num_slots` - the number of slots being registered\n* `first_slot` - the desired slot value for the first slot being registered\n* `slot_names` - an array of slot name strings to be registered.\n\nThis function registers a set of counter names in the specified scope.\nFor example, if you have a set of counters, say \"sent\" and \"recvd\" and\nyou want to register them, you'd write something like:\n\n```\nconst char *names[2] = {\"sent\", \"recvd\"};\nph_counter_scope_register_counter_block(scope, 2, 0, names);\n```\n\n\nIf the requested first_slot is not yet allocated, then it will allocate\nthe counters to the names you've specified and return true.  Otherwise\nit will have no side effects but return false.\n\nIf the scope doesn't have enough room for the num_slots, returns false.\n\n### ph_counter_scope_add\n\n```c\nvoid ph_counter_scope_add(\n    ph_counter_scope_t *scope,\n    uint8_t offset,\n    int64_t value);\n```\n\n\n*Modify a counter value.*\n\n\nAdds the specified value to the current counter value.\nNote that you may add a negative counter value to decrement it.\n\n* `scope` - the scope of the counter\n* `offset` - the counter slot offset\n* `value` - the value to add to the current counter value.\n\n### ph_counter_block_open\n\n```c\nph_counter_block_t *ph_counter_block_open(\n    ph_counter_scope_t *scope);\n```\n\n\n*Open a handle on the set of counters for the current thread*\n\n\nThe handle is useful in two main situations:\n\n1. The same thread is making very frequent updates to counter\n   values and wants to shave off the TLS overheads.\n   See ph_counter_block_add().\n2. The same thread is updating multiple counters in this scope\n   and wants to do so as efficiently as possible.\n   See ph_counter_block_bulk_add().\n\nThe returned handle is reference counted and can be released\nfrom any thread, but it changing the stats within it is only\nsafe when carried out by the owning thread.\n\nYou must call ph_counter_block_delref() on the handle when\nit is no longer needed.\n\n* `scope` - the scope to open\n\nReturns a thread local counter block.\n\n### ph_counter_block_add\n\n```c\nvoid ph_counter_block_add(\n    ph_counter_block_t *block,\n    uint8_t offset,\n    int64_t value)\n```\n\n\n*Modify a counter value in a thread local block*\n\n\nAdds the specified value to the current counter value.\nNote that you may add a negative counter value to decrement it.\n\n* `block` - the block containing the counters\n* `offset` - the counter slot offset\n* `value` - the value to add to the current counter value.\n\n### ph_counter_block_delref\n\n```c\nvoid ph_counter_block_delref(\n    ph_counter_block_t *block);\n```\n\n\n*Release a counter block*\n\n\n* `block` - the block to be released.\n\n### ph_counter_block_bulk_add\n\n```c\nvoid ph_counter_block_bulk_add(\n    ph_counter_block_t *block,\n    uint8_t num_slots,\n    const uint8_t *slots,\n    const int64_t *values)\n```\n\n\n*Modify a set of counters in a block*\n\n\nUpdates multiple slots in a single write \"transaction\".\nCounters use a sequence \"lock\" to allow a reader to detect\nan inconsistent read.  This function places the set of counter\nupdates under the same write sequence, making it both marginally\nfaster to update a set of counters in the same block and faster\nfor a reader to detect and retry a block read when obtaining\nthe counter view.\n\nIf you frequently update a set of related counters together,\nit is recommended that you use this interface.\n\n* `block` - the counter block for this thread\n* `num_slots` - the number of slots being manipulated\n* `slots` - an array of num_slots slot offsets\n* `values` - an array of num_slots values\n\nNOTE: passing an invalid slot offset leads to undefined behavior.\nIt is the callers responsibility to ensure that the offsets are\nvalid.\n\n### ph_counter_scope_get\n\n```c\nint64_t ph_counter_scope_get(\n    ph_counter_scope_t *scope,\n    uint8_t offset);\n```\n\n\n*Returns a current counter value.*\n\n\nReturns the current value associated with a counter slot in the\nspecified scope.\n\nIf the offset is invalid, returns 0.\n\n* `scope` - the containing scope\n* `offset` - the counter slot offset\n\n### ph_counter_scope_get_view\n\n```c\nuint8_t ph_counter_scope_get_view(\n    ph_counter_scope_t *scope,\n    uint8_t num_slots,\n    int64_t *slots,\n    const char **names);\n```\n\n\n*Returns a consistent view on the counters in a scope.*\n\n\nSince counters may be atomically modified from any thread, it can\nbe difficult to make sense of the set of related counters.\nThe counter subsystem uses a sequence synchronization\nmechanism that allows counter updates to proceed unimpeded but that\nallows readers to determine whether they have a consistent view.\nThe get_view operation will retry its counter reads until is\nhas a consistent view on that set of counters.\n\nIf the names parameter is specified, it is an array of size num_slots\nthat will be populated with the names of the counters registered\nin the scope.\n\nReturns the number of slots populated.\n\n* `scope` - the containing scope\n* `num_slots` - the number of slots to read\n* `slots` - an array of size num_slots to hold the values\n* `names` - an optional array to receive the counter names\n\n### ph_counter_scope_get_name\n\n```c\nconst char *ph_counter_scope_get_name(\n    ph_counter_scope_t *scope);\n```\n\n\n*Returns the fully qualified name of the counter scope*\n\n\nIntrospects the provided scope and returns its full path name.\n\nReturns the name.\n\nThe returned string is only valid while the scope reference is\nmaintained; once you delref, the name pointer value is undefined.\n\n### ph_counter_scope_get_num_slots\n\n```c\nuint8_t ph_counter_scope_get_num_slots(\n    ph_counter_scope_t *scope);\n```\n\n\n*Returns the number of allocated slots in a scope.*\n\n\nIntrospects the provided scope and returns the number of slots\nthat have been allocated.  This is useful when dynamically examining\na scope to render the counter values.\n\n* `scope` - the scope being inspected\n\nReturns the number of allocated slots\n\n### ph_counter_scope_iterator_init\n\n```c\nvoid ph_counter_scope_iterator_init(\n    ph_counter_scope_iterator_t *iter);\n```\n\n\n*Initialize a scope iterator.*\n\n\n* `iter` - the iterator to be initialized\n\n### ph_counter_scope_iterator_next\n\n```c\nph_counter_scope_t *ph_counter_scope_iterator_next(\n    ph_counter_scope_iterator_t *iter);\n```\n\n\n*iterate scopes*\n\n\n* `iter` - the iterator\n\nReturns The next scope in the iteration, or NULL if the end has been\nreached.\n\nIteration is thread safe; no locks are required, but iteration may not\nsee scopes that were defined partway through iteration.\n\nIteration order is undefined.\n\nThe caller is responsible for calling ph_counter_scope_delref()\non the returned scope.\n\nIf you wish to halt iteration early, simply break out of your loop.\nThe iterator does not hold any resources and does not need to be\ndestroyed.\n",
        "decl_titles": [
            "ph_counter_scope_define",
            "ph_counter_scope_resolve",
            "ph_counter_scope_delref",
            "ph_counter_scope_register_counter",
            "ph_counter_scope_register_counter_block",
            "ph_counter_scope_add",
            "ph_counter_block_open",
            "ph_counter_block_add",
            "ph_counter_block_delref",
            "ph_counter_block_bulk_add",
            "ph_counter_scope_get",
            "ph_counter_scope_get_view",
            "ph_counter_scope_get_name",
            "ph_counter_scope_get_num_slots",
            "ph_counter_scope_iterator_init",
            "ph_counter_scope_iterator_next"
        ],
        "raw_content": "\/*\n * Copyright 2012-2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n\/**\n * # Counters\n * The counter subsystem provides a set of functions that\n * allows the application to build a hierarchy of 64-bit\n * counter values.\n *\n * These values may be modified and queried atomically via the provided API.\n *\n * Functions are provided to introspect the hierarchy and groups of\n * related counters can be read consistently.  Note that the system does\n * not provide a means for snapshotting the entire counter hierarchy.\n *\n * Counters are implemented such that individual threads may\n * manipulate their values uncontested (with no locking!), but allowing\n * for a reader to obtain a consistent view of a related set of counters.\n *\n * ## Overview\n *\n * First establish the counter scope, and register counter nodes within\n * it:\n *\n * ```\n * ph_counter_scope_t *myscope = ph_counter_scope_define(NULL, &quot;myscope&quot;, 8);\n * const char *names[2] = {&quot;sent&quot;, &quot;recvd&quot;};\n * #define MY_SENT_COUNTER_SLOT 0\n * #define MY_RECVD_COUNTER_SLOT 1\n * ph_counter_scope_register_counter_block(myscope, 2, 0, names);\n * ```\n *\n * Then, elsewhere in you program, adjust the counter values.  There are\n * two interfaces for this; one is the slow and convenient way:\n *\n * ```\n * \/\/ Bump the sent counter by 1.  Slower and more convenient\n * ph_counter_scope_add(myscope, MY_SENT_COUNTER_SLOT, 1);\n * ```\n *\n * The preferred approach is to open a handle to your thread-local\n * counter block.  This is ideal if you are driving your thread and\n * can maintain that block handle in a local variable.  Alternatively,\n * if you are running a tight loop or are updating a series of counters,\n * you should prefer to open the block in this way.  **Note that the block\n * returned can only have its counters modified on the same thread that\n * obtained the block**:\n *\n * ```\n * ph_counter_block_t *block = ph_counter_block_open(myscope);\n * \/\/ Bump the sent counter by 1\n * ph_counter_block_add(block, MY_SENT_COUNTER_SLOT, 1);\n * ```\n *\n * To make an update to multiple counters at once:\n *\n * ```\n * uint8_t slots[2] = { MY_SENT_COUNTER_SLOT, MY_RECVD_COUNTER_SLOT };\n * int64_t values[2] = { 4, 5 };\n * \/\/ adds 4 to the sent counter and 5 to the recvd counter\n * ph_counter_block_bulk_add(block, 2, slots, values);\n * ```\n *\/\n\n#ifndef PHENOM_COUNTER_H\n#define PHENOM_COUNTER_H\n\n#include &lt;phenom\/defs.h&gt;\n#include &lt;ck_sequence.h&gt;\n#include &quot;phenom\/refcnt.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_counter_scope;\nstruct ph_counter_block;\ntypedef struct ph_counter_scope ph_counter_scope_t;\ntypedef struct ph_counter_block ph_counter_block_t;\n\n\/** Defines a new counter scope.\n *\n * Counter scopes contain one or more counter values that\n * are logically grouped together.\n *\n * The counter subsystem provides fast update access to the\n * individual counter values and a mechanism for reading a\n * consistent snapshot of the counter values in the scope.\n *\n * * `parent` - optional relative counter scope. May be NULL.\n * * `path` - scope name for this set of counters. Must not be NULL.\n * * `max_counters` - hint as to the max number of counters that must\n *    be available for use in this counter scope.  The system\n *    only guarantees that this many slots are available, which\n *    may restrict the number of counters that can be dynamically\n *    added later.\n *\n * Returns a counter scope instance.  The caller owns a reference\n * to this instance and must release it via ph_counter_scope_delref()\n * when it is no longer needed.\n *\/\nph_counter_scope_t *ph_counter_scope_define(\n    ph_counter_scope_t *parent,\n    const char *path,\n    uint8_t max_counters);\n\n\/** Resolve a named counter scope\n *\n * Given a relative scope and name, resolves it to a scope instance.\n *\n * * `parent` - optional relative counter scope. May be NULL.\n * * `path` - scope name to be resolved. Must not be NULL.\n *\n * Returns a counter scope instance.  The caller owns a reference\n * to this instance and must release it via ph_counter_scope_delref().\n *\/\nph_counter_scope_t *ph_counter_scope_resolve(\n    ph_counter_scope_t *parent,\n    const char *path);\n\n\/** Release a reference to a counter scope.\n *\n * When no more references to a scope remain, it is destroyed.\n * To delete a counter scope from the counter subsystem, it must be\n * unlinked from its parent scope (not currently supported).\n *\n * * `scope` - the scope to be released\n *\/\nvoid ph_counter_scope_delref(ph_counter_scope_t *scope);\n\n#define PH_COUNTER_INVALID 0xff\n\n\/** Registers a counter name in a counter scope.\n *\n * Returns a counter slot offset or `PH_COUNTER_INVALID`\n *\n * * `scope` - the scope in which the counter should be registered\n * * `name` - the name of the counter\n *\n * It is an error to register a counter with the same name as a child\n * scope.\n *\n * If the counter cannot be registered, returns `PH_COUNTER_INVALID`.\n *\/\nuint8_t ph_counter_scope_register_counter(\n    ph_counter_scope_t *scope,\n    const char *name);\n\n\/** Registers a block of counter names and values in a counter scope.\n *\n * Returns true if the registration matched the desired slots, false otherwise\n *\n * * `scope` - the scope in which the counters should be registered.\n * * `num_slots` - the number of slots being registered\n * * `first_slot` - the desired slot value for the first slot being registered\n * * `slot_names` - an array of slot name strings to be registered.\n *\n * This function registers a set of counter names in the specified scope.\n * For example, if you have a set of counters, say &quot;sent&quot; and &quot;recvd&quot; and\n * you want to register them, you&#039;d write something like:\n\n```\nconst char *names[2] = {&quot;sent&quot;, &quot;recvd&quot;};\nph_counter_scope_register_counter_block(scope, 2, 0, names);\n```\n\n *\n * If the requested first_slot is not yet allocated, then it will allocate\n * the counters to the names you&#039;ve specified and return true.  Otherwise\n * it will have no side effects but return false.\n *\n * If the scope doesn&#039;t have enough room for the num_slots, returns false.\n *\/\nbool ph_counter_scope_register_counter_block(\n    ph_counter_scope_t *scope,\n    uint8_t num_slots,\n    uint8_t first_slot,\n    const char **names\n);\n\n\/** Modify a counter value.\n *\n * Adds the specified value to the current counter value.\n * Note that you may add a negative counter value to decrement it.\n *\n * * `scope` - the scope of the counter\n * * `offset` - the counter slot offset\n * * `value` - the value to add to the current counter value.\n *\/\nvoid ph_counter_scope_add(\n    ph_counter_scope_t *scope,\n    uint8_t offset,\n    int64_t value);\n\n\/** Open a handle on the set of counters for the current thread\n *\n * The handle is useful in two main situations:\n *\n * 1. The same thread is making very frequent updates to counter\n *    values and wants to shave off the TLS overheads.\n *    See ph_counter_block_add().\n * 2. The same thread is updating multiple counters in this scope\n *    and wants to do so as efficiently as possible.\n *    See ph_counter_block_bulk_add().\n *\n * The returned handle is reference counted and can be released\n * from any thread, but it changing the stats within it is only\n * safe when carried out by the owning thread.\n *\n * You must call ph_counter_block_delref() on the handle when\n * it is no longer needed.\n *\n * * `scope` - the scope to open\n *\n * Returns a thread local counter block.\n *\/\nph_counter_block_t *ph_counter_block_open(\n    ph_counter_scope_t *scope);\n\nstruct ph_counter_block {\n  \/* must be first in the struct so that we can cast the return\n   * value from ck_hs_get() *\/\n  uint32_t scope_id;\n  ph_refcnt_t refcnt;\n  uint32_t seqno CK_CC_CACHELINE;\n  char pad[CK_MD_CACHELINE - sizeof(uint32_t)];\n\n  \/* variable size array; the remainder of this struct\n   * holds num_slots elements *\/\n  int64_t slots[1];\n};\n\nstatic inline void ph_counter_block_record_write(\n    ph_counter_block_t *block)\n{\n  block-&gt;seqno += 2;\n}\n\n\/** Modify a counter value in a thread local block\n *\n * Adds the specified value to the current counter value.\n * Note that you may add a negative counter value to decrement it.\n *\n * * `block` - the block containing the counters\n * * `offset` - the counter slot offset\n * * `value` - the value to add to the current counter value.\n *\/\nstatic inline void ph_counter_block_add(\n    ph_counter_block_t *block,\n    uint8_t offset,\n    int64_t value)\n{\n  block-&gt;slots[offset] += value;\n  ph_counter_block_record_write(block);\n}\n\n\/** Release a counter block\n *\n * * `block` - the block to be released.\n *\/\nvoid ph_counter_block_delref(\n    ph_counter_block_t *block);\n\n\/** Modify a set of counters in a block\n *\n * Updates multiple slots in a single write &quot;transaction&quot;.\n * Counters use a sequence &quot;lock&quot; to allow a reader to detect\n * an inconsistent read.  This function places the set of counter\n * updates under the same write sequence, making it both marginally\n * faster to update a set of counters in the same block and faster\n * for a reader to detect and retry a block read when obtaining\n * the counter view.\n *\n * If you frequently update a set of related counters together,\n * it is recommended that you use this interface.\n *\n * * `block` - the counter block for this thread\n * * `num_slots` - the number of slots being manipulated\n * * `slots` - an array of num_slots slot offsets\n * * `values` - an array of num_slots values\n *\n * NOTE: passing an invalid slot offset leads to undefined behavior.\n * It is the callers responsibility to ensure that the offsets are\n * valid.\n *\/\nstatic inline void ph_counter_block_bulk_add(\n    ph_counter_block_t *block,\n    uint8_t num_slots,\n    const uint8_t *slots,\n    const int64_t *values)\n{\n  int i;\n\n  block-&gt;seqno++;\n  for (i = 0; i &lt; num_slots; i++) {\n    block-&gt;slots[slots[i]] += values[i];\n  }\n  block-&gt;seqno++;\n}\n\n\n\/** Returns a current counter value.\n *\n * Returns the current value associated with a counter slot in the\n * specified scope.\n *\n * If the offset is invalid, returns 0.\n *\n * * `scope` - the containing scope\n * * `offset` - the counter slot offset\n *\/\nint64_t ph_counter_scope_get(\n    ph_counter_scope_t *scope,\n    uint8_t offset);\n\n\/** Returns a consistent view on the counters in a scope.\n *\n * Since counters may be atomically modified from any thread, it can\n * be difficult to make sense of the set of related counters.\n * The counter subsystem uses a sequence synchronization\n * mechanism that allows counter updates to proceed unimpeded but that\n * allows readers to determine whether they have a consistent view.\n * The get_view operation will retry its counter reads until is\n * has a consistent view on that set of counters.\n *\n * If the names parameter is specified, it is an array of size num_slots\n * that will be populated with the names of the counters registered\n * in the scope.\n *\n * Returns the number of slots populated.\n *\n * * `scope` - the containing scope\n * * `num_slots` - the number of slots to read\n * * `slots` - an array of size num_slots to hold the values\n * * `names` - an optional array to receive the counter names\n *\/\nuint8_t ph_counter_scope_get_view(\n    ph_counter_scope_t *scope,\n    uint8_t num_slots,\n    int64_t *slots,\n    const char **names);\n\n\/** Returns the fully qualified name of the counter scope\n *\n * Introspects the provided scope and returns its full path name.\n *\n * Returns the name.\n *\n * The returned string is only valid while the scope reference is\n * maintained; once you delref, the name pointer value is undefined.\n *\/\nconst char *ph_counter_scope_get_name(\n    ph_counter_scope_t *scope);\n\n\/** Returns the number of allocated slots in a scope.\n *\n * Introspects the provided scope and returns the number of slots\n * that have been allocated.  This is useful when dynamically examining\n * a scope to render the counter values.\n *\n * * `scope` - the scope being inspected\n *\n * Returns the number of allocated slots\n *\/\nuint8_t ph_counter_scope_get_num_slots(\n    ph_counter_scope_t *scope);\n\n\/* an iterator for scopes *\/\nstruct ph_counter_scope_iterator {\n  void *ptr;\n  intptr_t offset;\n};\ntypedef struct ph_counter_scope_iterator ph_counter_scope_iterator_t;\n\n\/** Initialize a scope iterator.\n *\n * * `iter` - the iterator to be initialized\n *\/\nvoid ph_counter_scope_iterator_init(\n    ph_counter_scope_iterator_t *iter);\n\n\/** iterate scopes\n *\n * * `iter` - the iterator\n *\n * Returns The next scope in the iteration, or NULL if the end has been\n * reached.\n *\n * Iteration is thread safe; no locks are required, but iteration may not\n * see scopes that were defined partway through iteration.\n *\n * Iteration order is undefined.\n *\n * The caller is responsible for calling ph_counter_scope_delref()\n * on the returned scope.\n *\n * If you wish to halt iteration early, simply break out of your loop.\n * The iterator does not hold any resources and does not need to be\n * destroyed.\n *\/\nph_counter_scope_t *ph_counter_scope_iterator_next(\n    ph_counter_scope_iterator_t *iter);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "defs": {
        "name": "defs",
        "title": "defs",
        "content": "\n# Base Environment\n\nIncluding `phenom\/defs.h` sets the base environment for using\nphenom.  This header should be included first (most phenom headers\nwill pull this in explicitly) so that the compilation environment\nexposes the more modern unix compilation features of your system.\n\n### PH_LIBRARY_INIT_PRI\n\n```c\nvoid PH_LIBRARY_INIT_PRI(initfn, finifn, pri);\n```\n\n\n*Records an initialization and finalization routine with a specific priority*\n\n\nThis macro sets up a constructor routine to record the init\nentry.  These init entries are processed when ph_library_init()\nis called by the process.  You should restrict initialization to\nlow level actions like preparing memtypes, initializing locks\nand bootstrapping subsystems.  You **must not** make these functions\ndependent upon configuration, as the configuration will not have\nbeen loaded at the time these are invoked.\n\nThis exists to facilitate initialization of the library itself,\nbut you may also use it aid with registering modules and facilities\nwith the library.  For example, the `PH_TYPE_FORMATTER_REGISTER`\nuses this mechanism to arrange for ph_vprintf_register() to be\ncalled at the appropriate time.\n\nYou may specify either `initfn` or `finifn` as NULL; this just means\nthat the item doesn't have an initializer or finalizer, respectively.\nIt probably doesn't make much sense to specify both as NULL, but it is\nallowed and does not cause an error.\n\n```\nstatic void init(void) {\n  mt = ph_memtype_register(...);\n}\nPH_LIBRARY_INIT(init, 0)\n```\n\n### PH_LIBRARY_INIT\n\n```c\nvoid PH_LIBRARY_INIT(initfn, finifn);\n```\n\n\n*Records an initialization and finalization routine*\n\n\nDelegates to PH_LIBRARY_INIT_PRI() with a default priority.\n\n### struct ph_library_init_entry\n\n```c\nstruct ph_library_init_entry {\n  \/\/ the file where this init entry is defined\n  const char *file;\n  \/\/ the line number where this init entry is defined\n  uint32_t line;\n  \/\/ the priority of this init entry.\n  \/\/ Clients of the library should use values >= 100.\n  \/\/ During init, the `init` functions are calling in order of ascending\n  \/\/ priority.  During finalization, the `fini` functions are called in\n  \/\/ order of descending priority.\n  int pri;\n  \/\/ initializer (may be NULL)\n  void (*init)(void);\n  \/\/ finalizer (may be NULL)\n  void (*fini)(void);\n  \/\/ this is really a ck_stack_entry_t but we don't want to pull in\n  \/\/ that definition from here.  This is protected by a static assert\n  \/\/ in corelib\/init.c\n  intptr_t st;\n};\n```\n\n\n*Records an initialization and finalization routine.*\n\n\nUse PH_LIBRARY_INIT_PRI() or PH_LIBRARY_INIT() rather than using\nthis directly.\n\nThe relative priorities of entries are computed thus:\n\n* The lowest `pri` values are initialized first.\n* If two items have the same `pri` value, the `file` values are\n  ordered using using strcmp.\n* If two items have the same `file`, the item with the lowest\n  `line` value is initialized first.\n* If the `line` values are the same, the address of the entry is\n  used to order the items relative to each other.\n\nAt finalization time, the reverse of the above ordering is used;\nthe items will be finalized in the opposite of the order that they\nwere initialized.\n\n* * *\n\n## Pedantic compilation\n\nTo stave off undefined or unexpected conditions, libPhenom is\ncompiled in an extremely unforgiving mode that causes warnings\nto be treated as errors.\n\nThere are a couple of useful source annotations that you can\nuse to avoid triggering some classes of error.\n\n### ph_unused_parameter\n\n```\nvoid myfunc(int not_used)\n{\n   ph_unused_parameter(not_used);\n}\n```\n\n### Result not ignored\n\nSome compilation environments are very strict and will raise\nwarnings if you ignore return values of certain functions.\nIn some cases you really do want to ignore these results.\nHere's how to tell the compiler to leave you alone:\n\n```\nvoid myfunc(void)\n{\n   ph_ignore_result(poll(&pfd, 1, 100));\n}\n```\n\n* * *\n\n```c\ntypedef uint32_t ph_result_t;\n```\n\n\n*Generic result type*\n\n\nIf you wish to avoid TLS overheads with errno if\/when a function fails,\nyou may choose to implement your return values in terms of the ph_result_t\ntype.  The value `PH_OK` is defined to 0 and means success.  All other\nvalues are interpreted as something not quite working out for a variety\nof reasons.\n\n* `PH_OK` - success!\n* `PH_NOMEM` - insufficient memory\n* `PH_BUSY` - too busy to complete now (try later)\n* `PH_ERR` - generic failure (sorry)\n* `PH_NOENT` - requested item has no entry, could not be found\n* `PH_EXISTS` - requested item is already present\n* `PH_DONE` - operation (iteration) completed\n\n### ph_static_assert\n\n```c\nvoid ph_static_assert(bool constexpr, identifier_message);\n```\n\n\n*Perform a compile time assertion*\n\n\nTo perform compile time assertion checking (useful for things like ABI\nchecks), you may use the ph_static_assert() macro.  Usage is as follows:\n\n```\nph_static_assert(sizeof(int)==4, assuming_32_bits);\n```\n\nThe first parameter is the constant expression to check.  It has to be\nconstant for the compiler to check it at compile time.  If you wish to\nassert that function parameters are correct, you should use ph_assert()\ninstead.\n\nThe second parameter is ideally a meaningful identifier string that gives a\ndescriptive label for the issue.  It has to be a valid identifier component\nin order to provide meaningful error messages on a wider range of compilers.\n\nIf the assertion fails, you'll encounter an error message like this:\n\n```\nerror: zero width for bit-field 'static_assertion_failed_assuming_32_bits'\n```\n\nIf you are using GCC 4.6 or later you'll see an error message like this:\n\n```\nerror: static assertion failed: \"assuming_32_bits\"\n```\n\n### ph_panic\n\n```c\nvoid ph_panic(const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 1, 2)))\n  __attribute__((noreturn))\n#endif\n  ;\n```\n\n\n*Log a PH_LOG_PANIC level message, then abort()*\n\n\nThis logs a PANIC level message using ph_log(), logs the current\nstacktrace using ph_log_stacktrace(), and then calls `abort()`.\n\nIt is intended to be used in situations where the world must\nhave an immediate end.\n\n\n### ph_assert\n\n```c\nvoid ph_assert(bool condition, const char *message);\n```\n\n\n*Perform a runtime assertion*\n\n\nTo perform a runtime assertion, use ph_assert() as shown below.\nlibPhenom makes the assumption that the expression to be asserted\nwill almost never be true.\n\n```\nph_assert(n < 10, \"n is within range\");\n```\n\nIf your compiler is GCC 4.3 or newer, we'll try to evaluate the\nexpression at compile time to save you some surprises.  This\nworks similarly to ph_static_assert().  You'll see an error\nmessage along the lines of:\n\n```\nfile.c:350: error: call to 'failed_assert_1' declared with attribute error: 17 < 16 :: nargs too big\n```\n\nOtherwise, the error will only trigger when the code is executed.\n\nUnlike assert(), ph_assert() is always enabled and compiled into\nyour code.\n\nIf you'd like assertions that are disabled when `NDEBUG` is `#define`d,\nyou may use ph_debug_assert() instead.\n\n### ph_debug_assert\n\n```c\nvoid ph_debug_assert(bool condition, const char *message);\n```\n\n\n*Perform a runtime assertion in debug code*\n\n\nWorks exactly like ph_assert(), except that the assertion code is\nelided from a \"production\" build; one that has `NDEBUG` defined.\n\n```\n\/\/ Never checked in the production build, because there are\n\/\/ never going to be bugs there...\nph_debug_assert(n < 10, \"n is within range\");\n```\n\n* * *\n\n```c\ntypedef int ph_socket_t;\n```\n\n\n*Holds a socket descriptor*\n\n",
        "decl_titles": [
            "PH_LIBRARY_INIT_PRI",
            "PH_LIBRARY_INIT",
            "struct ph_library_init_entry",
            "ph_static_assert",
            "ph_panic",
            "ph_assert",
            "ph_debug_assert"
        ],
        "raw_content": "\/*\n * Copyright 2012-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_DEFS_H\n#define PHENOM_DEFS_H\n\n\/**\n * # Base Environment\n *\n * Including `phenom\/defs.h` sets the base environment for using\n * phenom.  This header should be included first (most phenom headers\n * will pull this in explicitly) so that the compilation environment\n * exposes the more modern unix compilation features of your system.\n *\/\n\n#define PHENOM_TARGET_CPU_X86_64 1\n#define PHENOM_TARGET_CPU_X86    2\n\n#ifndef _REENTRANT\n# define _REENTRANT\n#endif\n#define __EXTENSIONS__ 1\n#define _BSD_SOURCE\n#ifdef __sun__\n#define _XOPEN_SOURCE 600\n#define _POSIX_C_SOURCE 200112L\n#else\n#define _XOPEN_SOURCE 700\n#define _POSIX_C_SOURCE 200809\n#endif\n#define _GNU_SOURCE\n#define _DARWIN_C_SOURCE\n\n\/\/ Ensure that PRIu32 and friends get defined for both C99\n\/\/ and C++ consumers of libphenom\n#ifndef __STDC_FORMAT_MACROS\n# define __STDC_FORMAT_MACROS\n#endif\n\n#ifdef __FreeBSD__\n\/* need this to get u_short so we can include sys\/event.h.\n * This has to happen before we include sys\/types.h *\/\n# include &lt;sys\/cdefs.h&gt;\n# define __BSD_VISIBLE 1\n#endif\n\n#include &lt;sys\/types.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;pthread.h&gt;\n#include &lt;sys\/uio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;time.h&gt;\n#include &lt;sys\/time.h&gt;\n#include &lt;stdarg.h&gt;\n\n# ifdef PHENOM_IMPL\n#  include &quot;phenom_build_config.h&quot;\n\n# ifdef HAVE_ALLOCA_H\n#  include &lt;alloca.h&gt;\n# endif\n# ifdef HAVE_SYS_TIMERFD_H\n#  include &lt;sys\/timerfd.h&gt;\n# endif\n# ifdef HAVE_SYS_EVENTFD_H\n#  include &lt;sys\/eventfd.h&gt;\n# endif\n# ifdef HAVE_SYS_EPOLL_H\n#  include &lt;sys\/epoll.h&gt;\n# endif\n# ifdef HAVE_SYS_EVENT_H\n#  include &lt;sys\/event.h&gt;\n# endif\n\n# ifdef HAVE_PTHREAD_NP_H\n#  include &lt;pthread_np.h&gt;\n# endif\n# include &lt;stdio.h&gt;\n# include &lt;stdlib.h&gt;\n# include &lt;string.h&gt;\n# include &lt;unistd.h&gt;\n# include &lt;errno.h&gt;\n# include &lt;signal.h&gt;\n# include &lt;fcntl.h&gt;\n# include &lt;limits.h&gt;\n\n# ifdef HAVE_SYS_CPUSET_H\n#  include &lt;sys\/cpuset.h&gt;\n# endif\n# ifdef HAVE_SYS_RESOURCE_H\n#  include &lt;sys\/resource.h&gt;\n# endif\n# ifdef HAVE_SYS_PROCESSOR_H\n#  include &lt;sys\/processor.h&gt;\n# endif\n# ifdef HAVE_SYS_PROCSET_H\n#  include &lt;sys\/procset.h&gt;\n# endif\n\n# ifdef HAVE_LOCALE_H\n#  include &lt;locale.h&gt;\n# endif\n\n# ifdef HAVE_PORT_CREATE\n#  include &lt;port.h&gt;\n#  include &lt;sys\/poll.h&gt;\n# endif\n\n# if defined(__APPLE__)\n  \/* for thread affinity *\/\n# include &lt;mach\/thread_policy.h&gt;\n# include &lt;mach\/mach_init.h&gt;\n# include &lt;mach\/thread_act.h&gt;\n  \/* clock *\/\n# include &lt;mach\/mach_time.h&gt;\n# endif\n# endif\n\n# ifdef __GNUC__\n#  define PH_GCC_VERSION (__GNUC__ * 10000 \\\n    + __GNUC_MINOR__ * 100 \\\n    + __GNUC_PATCHLEVEL__)\n# else\n#  define PH_GCC_VERSION 0\n#endif\n\n\/\/ Helpers for pasting __LINE__ for symbol generation\n#define ph_defs_paste2(pre, post)  pre ## post\n#define ph_defs_paste1(pre, post)  ph_defs_paste2(pre, post)\n#if PH_GCC_VERSION &gt;= 40300\n# define ph_defs_gen_symbol(pre)    ph_defs_paste1(pre, __COUNTER__)\n#else\n# define ph_defs_gen_symbol(pre)    ph_defs_paste1(pre, __LINE__)\n#endif\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\n#if 0 \/* fake prototype for documentation purposes *\/\n\/** Records an initialization and finalization routine with a specific priority\n *\n * This macro sets up a constructor routine to record the init\n * entry.  These init entries are processed when ph_library_init()\n * is called by the process.  You should restrict initialization to\n * low level actions like preparing memtypes, initializing locks\n * and bootstrapping subsystems.  You **must not** make these functions\n * dependent upon configuration, as the configuration will not have\n * been loaded at the time these are invoked.\n *\n * This exists to facilitate initialization of the library itself,\n * but you may also use it aid with registering modules and facilities\n * with the library.  For example, the `PH_TYPE_FORMATTER_REGISTER`\n * uses this mechanism to arrange for ph_vprintf_register() to be\n * called at the appropriate time.\n *\n * You may specify either `initfn` or `finifn` as NULL; this just means\n * that the item doesn&#039;t have an initializer or finalizer, respectively.\n * It probably doesn&#039;t make much sense to specify both as NULL, but it is\n * allowed and does not cause an error.\n *\n * ```\n * static void init(void) {\n *   mt = ph_memtype_register(...);\n * }\n * PH_LIBRARY_INIT(init, 0)\n * ```\n *\/\nvoid PH_LIBRARY_INIT_PRI(initfn, finifn, pri);\n\n\/** Records an initialization and finalization routine\n *\n * Delegates to PH_LIBRARY_INIT_PRI() with a default priority.\n *\/\nvoid PH_LIBRARY_INIT(initfn, finifn);\n#endif\n\n\/** Records an initialization and finalization routine.\n *\n * Use PH_LIBRARY_INIT_PRI() or PH_LIBRARY_INIT() rather than using\n * this directly.\n *\n * The relative priorities of entries are computed thus:\n *\n * * The lowest `pri` values are initialized first.\n * * If two items have the same `pri` value, the `file` values are\n *   ordered using using strcmp.\n * * If two items have the same `file`, the item with the lowest\n *   `line` value is initialized first.\n * * If the `line` values are the same, the address of the entry is\n *   used to order the items relative to each other.\n *\n * At finalization time, the reverse of the above ordering is used;\n * the items will be finalized in the opposite of the order that they\n * were initialized.\n *\/\nstruct ph_library_init_entry {\n  \/\/ the file where this init entry is defined\n  const char *file;\n  \/\/ the line number where this init entry is defined\n  uint32_t line;\n  \/\/ the priority of this init entry.\n  \/\/ Clients of the library should use values &gt;= 100.\n  \/\/ During init, the `init` functions are calling in order of ascending\n  \/\/ priority.  During finalization, the `fini` functions are called in\n  \/\/ order of descending priority.\n  int pri;\n  \/\/ initializer (may be NULL)\n  void (*init)(void);\n  \/\/ finalizer (may be NULL)\n  void (*fini)(void);\n  \/\/ this is really a ck_stack_entry_t but we don&#039;t want to pull in\n  \/\/ that definition from here.  This is protected by a static assert\n  \/\/ in corelib\/init.c\n  intptr_t st;\n};\n\nvoid ph_library_init_register(struct ph_library_init_entry *ent);\n#define PH_LIBRARY_INIT_PRI(initfn, finifn, pri) \\\n  static __attribute__((constructor)) \\\n  void ph_defs_gen_symbol(ph__lib__init__)(void) { \\\n    static struct ph_library_init_entry ent = { \\\n      __FILE__, __LINE__, pri, initfn, finifn, 0 \\\n    }; \\\n    ph_library_init_register(&amp;ent); \\\n  }\n#define PH_LIBRARY_INIT(initfn, finifn) \\\n  PH_LIBRARY_INIT_PRI(initfn, finifn, 100)\n\n\/**\n * ## Pedantic compilation\n *\n * To stave off undefined or unexpected conditions, libPhenom is\n * compiled in an extremely unforgiving mode that causes warnings\n * to be treated as errors.\n *\n * There are a couple of useful source annotations that you can\n * use to avoid triggering some classes of error.\n *\n * ### ph_unused_parameter\n *\n * ```\n * void myfunc(int not_used)\n * {\n *    ph_unused_parameter(not_used);\n * }\n * ```\n *\n * ### Result not ignored\n *\n * Some compilation environments are very strict and will raise\n * warnings if you ignore return values of certain functions.\n * In some cases you really do want to ignore these results.\n * Here&#039;s how to tell the compiler to leave you alone:\n *\n * ```\n * void myfunc(void)\n * {\n *    ph_ignore_result(poll(&amp;pfd, 1, 100));\n * }\n * ```\n *\/\n\n\/\/ Use this to eliminate &#039;unused parameter&#039; warnings\n# define ph_unused_parameter(x)  (void)x\n\n\/\/ Use this to cleanly indicate that we intend to ignore\n\/\/ the result of functions marked with warn_unused_result\n# if defined(__USE_FORTIFY_LEVEL) &amp;&amp; __USE_FORTIFY_LEVEL &gt; 0\n#  define ph_ignore_result(x) \\\n  do { __typeof__(x) _res = x; (void)_res; } while (0)\n# else\n#  define ph_ignore_result(x) x\n# endif\n\n# ifdef __GNUC__\n#  define ph_likely(x)    __builtin_expect(!!(x), 1)\n#  define ph_unlikely(x)  __builtin_expect(!!(x), 0)\n# else\n#  define ph_likely(x)    (x)\n#  define ph_unlikely(x)  (x)\n# endif\n\n\/** Generic result type\n *\n * If you wish to avoid TLS overheads with errno if\/when a function fails,\n * you may choose to implement your return values in terms of the ph_result_t\n * type.  The value `PH_OK` is defined to 0 and means success.  All other\n * values are interpreted as something not quite working out for a variety\n * of reasons.\n *\n * * `PH_OK` - success!\n * * `PH_NOMEM` - insufficient memory\n * * `PH_BUSY` - too busy to complete now (try later)\n * * `PH_ERR` - generic failure (sorry)\n * * `PH_NOENT` - requested item has no entry, could not be found\n * * `PH_EXISTS` - requested item is already present\n * * `PH_DONE` - operation (iteration) completed\n *\/\ntypedef uint32_t ph_result_t;\n#define PH_OK      0\n#define PH_NOMEM   1\n#define PH_BUSY    2\n#define PH_ERR     3 \/* programmer too lazy *\/\n#define PH_NOENT   4\n#define PH_EXISTS  5\n#define PH_DONE    6\n\n# ifdef __GNUC__\n#  define ph_offsetof(type, field) __builtin_offsetof(type, field)\n# else\n#  define ph_offsetof(type, field) \\\n      ((size_t)(&amp;((type *)0)-&gt;field)) \/\/ NOLINT(runtime\/casting)\n# endif\n#define ph_container_of(ptr_, type_, member_)  \\\n    ((type_ *)(void*)((char *)ptr_ - ph_offsetof(type_, member_)))\n\n#if 0 \/* fake prototype for documentation purposes *\/\n\/** Perform a compile time assertion\n *\n * To perform compile time assertion checking (useful for things like ABI\n * checks), you may use the ph_static_assert() macro.  Usage is as follows:\n *\n * ```\n * ph_static_assert(sizeof(int)==4, assuming_32_bits);\n * ```\n *\n * The first parameter is the constant expression to check.  It has to be\n * constant for the compiler to check it at compile time.  If you wish to\n * assert that function parameters are correct, you should use ph_assert()\n * instead.\n *\n * The second parameter is ideally a meaningful identifier string that gives a\n * descriptive label for the issue.  It has to be a valid identifier component\n * in order to provide meaningful error messages on a wider range of compilers.\n *\n * If the assertion fails, you&#039;ll encounter an error message like this:\n *\n * ```\n * error: zero width for bit-field &#039;static_assertion_failed_assuming_32_bits&#039;\n * ```\n *\n * If you are using GCC 4.6 or later you&#039;ll see an error message like this:\n *\n * ```\n * error: static assertion failed: &quot;assuming_32_bits&quot;\n * ```\n *\/\nvoid ph_static_assert(bool constexpr, identifier_message);\n#endif\n\n# if PH_GCC_VERSION &gt;= 40600\n#  define ph_static_assert(expr, msg)   _Static_assert(expr, #msg)\n# else\n   \/* this can generate conflicting type names if\n    * the same assert message is used from the same line of two\n    * different files on some compilers *\/\n#  define ph_static_assert(expr, msg) \\\n     typedef struct { \\\n       int ph_defs_paste1(static_assertion_failed_, msg) : \\\n       !!(expr); \\\n     } ph_defs_gen_symbol(static_assertion_failed_)\n# endif\n\n\/** Log a PH_LOG_PANIC level message, then abort()\n *\n * This logs a PANIC level message using ph_log(), logs the current\n * stacktrace using ph_log_stacktrace(), and then calls `abort()`.\n *\n * It is intended to be used in situations where the world must\n * have an immediate end.\n * *\/\nvoid ph_panic(const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 1, 2)))\n  __attribute__((noreturn))\n#endif\n  ;\n\n#if 0 \/* fake prototype for documentation purposes *\/\n\/** Perform a runtime assertion\n *\n * To perform a runtime assertion, use ph_assert() as shown below.\n * libPhenom makes the assumption that the expression to be asserted\n * will almost never be true.\n *\n * ```\n * ph_assert(n &lt; 10, &quot;n is within range&quot;);\n * ```\n *\n * If your compiler is GCC 4.3 or newer, we&#039;ll try to evaluate the\n * expression at compile time to save you some surprises.  This\n * works similarly to ph_static_assert().  You&#039;ll see an error\n * message along the lines of:\n *\n * ```\n * file.c:350: error: call to &#039;failed_assert_1&#039; declared with attribute error: 17 &lt; 16 :: nargs too big\n * ```\n *\n * Otherwise, the error will only trigger when the code is executed.\n *\n * Unlike assert(), ph_assert() is always enabled and compiled into\n * your code.\n *\n * If you&#039;d like assertions that are disabled when `NDEBUG` is `#define`d,\n * you may use ph_debug_assert() instead.\n *\/\nvoid ph_assert(bool condition, const char *message);\n\n\/** Perform a runtime assertion in debug code\n *\n * Works exactly like ph_assert(), except that the assertion code is\n * elided from a &quot;production&quot; build; one that has `NDEBUG` defined.\n *\n * ```\n * \/\/ Never checked in the production build, because there are\n * \/\/ never going to be bugs there...\n * ph_debug_assert(n &lt; 10, &quot;n is within range&quot;);\n * ```\n *\/\nvoid ph_debug_assert(bool condition, const char *message);\n#endif\n\n# if PH_GCC_VERSION &gt;= 40300\n\/\/ You&#039;d think that you could use _Static_assert in here, if your\n\/\/ compiler supported it, but it ends up not seeing the const\n\/\/ folded expression and complains about it not being a constant\n\/\/ expression.  If you try to use _Static_assert(0, msg) then\n\/\/ gcc will generate spurious asserts.  So we&#039;re stuck with this\n\/\/ implementation, which is pretty decent at the end of the day\n# define ph_assert_static_inner(expr, msg, id) do { \\\n    extern void ph_defs_paste1(failed_assert_, id)(void)\\\n      __attribute__((error(#expr &quot; :: &quot; msg))); \\\n    ph_defs_paste1(failed_assert_, id)(); \\\n} while (0)\n# define ph_assert(expr, msg) do { \\\n  if (__builtin_constant_p(expr) &amp;&amp; !(expr)) { \\\n    ph_assert_static_inner(expr, msg, __COUNTER__); \\\n  } \\\n  if (ph_unlikely(!(expr))) { \\\n    ph_panic(&quot;assertion &quot; #expr &quot; failed: &quot; msg &quot; at %s:%d&quot;, \\\n        __FILE__, __LINE__); \\\n  } \\\n} while (0)\n#else\n# define ph_assert(expr, msg) do { \\\n  if (ph_unlikely(!(expr))) { \\\n    ph_panic(&quot;assertion &quot; #expr &quot; failed: &quot; msg &quot; at %s:%d&quot;, \\\n        __FILE__, __LINE__); \\\n  } \\\n} while (0)\n\n#endif\n\n#ifdef NDEBUG\n# define ph_debug_assert(expr, msg) ((void)0)\n#else\n# define ph_debug_assert(expr, msg) ph_assert(expr, msg)\n#endif\n\n\/** Holds a socket descriptor *\/\ntypedef int ph_socket_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "dns": {
        "name": "dns",
        "title": "dns",
        "content": "\n# DNS Resolution facilities\n\nlibPhenom provides an asynchronous wrapper around the system resolver that\ndelegates to the system provided getaddrinfo() library function but\nruns in a thread pool.\n\nThis is provided for the common case of resolving a target hostname\nand then setting up an async connect.\n\nThe resolver functions operate by schedling a resolution and arrange to\ninvoke a callback when the results are available.  The same callback is\ninvoked in both the success and error cases.  The callback may be triggered\non the same thread that scheduled the resolution, but the common case is for\nthe resolution to complete on some other thread and invoke the callback in\nthat context.\n\nThe intended usage is that you schedule a job to continue your\nprocessing in some other context.\n\n### struct ph_dns_addrinfo\n\n```c\nstruct ph_dns_addrinfo {\n  \/\/ The job used to schedule the call\n  ph_job_t job;\n  \/\/ The node being queried\n  char *node;\n  \/\/ The service or port string\n  char *service;\n  \/\/ The hints that were provided\n  struct addrinfo hints;\n  \/\/ Holds the result of getaddrinfo()\n  int result;\n  \/\/ Holds the addrinfo returned from getaddrinfo().\n  \/\/ Do not pass this to freeaddrinfo(), instead, pass the entire\n  \/\/ structure to ph_dns_addrinfo_free() to release its resources\n  struct addrinfo *ai;\n  \/\/ Your arg pointer\n  void *arg;\n  \/\/ Your callback function\n  ph_dns_addrinfo_func func;\n};\n```\n\n\n*Holds the results of an async getaddrinfo call*\n\n\n### ph_dns_getaddrinfo\n\n```c\nph_result_t ph_dns_getaddrinfo(const char *node, const char *service,\n    const struct addrinfo *hints, ph_dns_addrinfo_func func, void *arg);\n```\n\n\n*Initiate an async getaddrinfo(3) call*\n\nThe call is dispatched by a DNS thread pool, which is started alongside\nthe scheduler. When it completes, your ph_dns_addrinfo_func function is\ninvoked in the context of that thread.  You own the resultant ph_dns_addrinfo\nstruct and must call ph_dns_addrinfo_free() to release its resources when you\nare done with them.\n\nArguments are the same as getaddrinfo(3), with the addition of `func`\nand `arg`.  `func` is called after getaddrinfo() completes.  `arg`\nis copied into the ph_dns_addrinfo struct and allows you to pass through\nsome context.\n\nThe expected usage is to schedule some additional work, such as setting\nup a job to connect to the resolved host.\n\n### ph_dns_addrinfo_free\n\n```c\nvoid ph_dns_addrinfo_free(ph_dns_addrinfo_t *info);\n```\n\n\n*Release async addrinfo results*\n\n",
        "decl_titles": [
            "struct ph_dns_addrinfo",
            "ph_dns_getaddrinfo",
            "ph_dns_addrinfo_free"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_DNS_H\n#define PHENOM_DNS_H\n\n#include &quot;phenom\/job.h&quot;\n#include &quot;phenom\/socket.h&quot;\n#include &quot;phenom\/feature_test.h&quot;\n#include &lt;netdb.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/**\n * # DNS Resolution facilities\n *\n * libPhenom provides an asynchronous wrapper around the system resolver that\n * delegates to the system provided getaddrinfo() library function but\n * runs in a thread pool.\n *\n * This is provided for the common case of resolving a target hostname\n * and then setting up an async connect.\n *\n * The resolver functions operate by schedling a resolution and arrange to\n * invoke a callback when the results are available.  The same callback is\n * invoked in both the success and error cases.  The callback may be triggered\n * on the same thread that scheduled the resolution, but the common case is for\n * the resolution to complete on some other thread and invoke the callback in\n * that context.\n *\n * The intended usage is that you schedule a job to continue your\n * processing in some other context.\n *\/\n\n\/* *\/\n\nstruct ph_dns_addrinfo;\ntypedef struct ph_dns_addrinfo ph_dns_addrinfo_t;\ntypedef void (*ph_dns_addrinfo_func)(ph_dns_addrinfo_t *info);\n\n\/** Holds the results of an async getaddrinfo call *\/\nstruct ph_dns_addrinfo {\n  \/\/ The job used to schedule the call\n  ph_job_t job;\n  \/\/ The node being queried\n  char *node;\n  \/\/ The service or port string\n  char *service;\n  \/\/ The hints that were provided\n  struct addrinfo hints;\n  \/\/ Holds the result of getaddrinfo()\n  int result;\n  \/\/ Holds the addrinfo returned from getaddrinfo().\n  \/\/ Do not pass this to freeaddrinfo(), instead, pass the entire\n  \/\/ structure to ph_dns_addrinfo_free() to release its resources\n  struct addrinfo *ai;\n  \/\/ Your arg pointer\n  void *arg;\n  \/\/ Your callback function\n  ph_dns_addrinfo_func func;\n};\n\n\/** Initiate an async getaddrinfo(3) call\n * The call is dispatched by a DNS thread pool, which is started alongside\n * the scheduler. When it completes, your ph_dns_addrinfo_func function is\n * invoked in the context of that thread.  You own the resultant ph_dns_addrinfo\n * struct and must call ph_dns_addrinfo_free() to release its resources when you\n * are done with them.\n *\n * Arguments are the same as getaddrinfo(3), with the addition of `func`\n * and `arg`.  `func` is called after getaddrinfo() completes.  `arg`\n * is copied into the ph_dns_addrinfo struct and allows you to pass through\n * some context.\n *\n * The expected usage is to schedule some additional work, such as setting\n * up a job to connect to the resolved host.\n *\/\nph_result_t ph_dns_getaddrinfo(const char *node, const char *service,\n    const struct addrinfo *hints, ph_dns_addrinfo_func func, void *arg);\n\n\/** Release async addrinfo results *\/\nvoid ph_dns_addrinfo_free(ph_dns_addrinfo_t *info);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "feature_test": {
        "name": "feature_test",
        "title": "feature_test",
        "content": "",
        "decl_titles": [],
        "raw_content": "\/* include\/phenom\/feature_test.h.  Generated from feature_test.h.in by configure.  *\/\n\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n"
    },
    "hashtable": {
        "name": "hashtable",
        "title": "hashtable",
        "content": "\n# Hash Table\n\nlibPhenom provides a hash table facility that allows the\nconstruction of maps from an arbitrary key type to\nan arbitrary value type.\n\nThe hash table uses closed hashing \/ open addressing to reduce the volume\nof discrete allocations required to maintain the table.\n\nNote: The tables have no built-in mutex or locking capability.  For a\nconcurrent map you might consider using the Concurrency Kit hash-set API.\nYou may alternatively wrap your hash table implementation in an appropriate\nmutex or reader-writer lock.\n\n## Defining a hash table\n\nThis implementation uses separate key and value definition structures\nso that you can factor out and re-use the code for keys\nacross different hash tables.  `ph_string_t*` key and value implementations\nare provided:\n\n```\nph_ht_t ht;\n\n\/\/ Declare a map from ph_string_t* -> ph_string_t*\nph_ht_init(&ht, 1, &ph_ht_string_key_def, &ph_ht_string_val_def);\n```\n\nThe table allocates storage for each element based on the sum of\nthe key size and value size declared in the key and value definitions.\n\nThe implementation is flexible enough to allow you to track pointers\nto other structures or to embed them directly, provided that they\nhave a fixed size.\n\n## Inserting data into the table\n\nAll insert operations are expressed in terms of the ph_ht_insert()\nfunction.  Two convenience functions are provided to make this less\nverbose: ph_ht_set() and ph_ht_replace().\n\nSince the API is intended to handle arbitrary key or data types, it\nis expressed in terms of `void*` types for keys and values.\n\nNote: you must pass the address of the keys and values\nto be stored.\n\nFor example, continuing with our string->string map above:\n\n```COUNTEREXAMPLE\nph_string_t *key = ph_string_make_cstr(mt_mytype, \"key\");\nph_string_t *val = ph_string_make_cstr(mt_mytype, \"val\");\n\nph_ht_set(&ht, key, val);   \/\/ WRONG! will crash\n```\n\n```\nph_string_t *key = ph_string_make_cstr(mt_mytype, \"key\");\nph_string_t *val = ph_string_make_cstr(mt_mytype, \"val\");\n\nph_ht_set(&ht, &key, &val); \/\/ CORRECT!\n\n\/\/ the set and replace APIs operate in COPY mode, so we need to\n\/\/ clean up our string references\nph_string_delref(key);\nph_string_delref(val);\n```\n\n## Inserting and claiming values\n\nIf you're constructing refcounted keys\/values just to put them in the\ntable, it can be tedious to repitively bracket the inserts with\ncreate and delref calls.\n\nFor this situation you can use ph_ht_insert() and the `PH_HT_CLAIM`\nflag.  When claiming, if the insertion was successful, the table will\ntake ownership of the references you passed to the table.  If the insert\nfails, you still own your references so that you can print out a\nmeaningful error.\n\n```\nph_string_t *key = ph_string_make_cstr(mt_mytype, \"key\");\nph_string_t *val = ph_string_make_cstr(mt_mytype, \"val\");\n\nif (ph_ht_insert(&ht, &key, &val, PH_HT_CLAIM) != PH_OK) {\n  ph_log(PH_LOG_ERR, \"failed to insert `Ps%p -> `Ps%p\",\n        (void*)key, (void*)val);\n  ph_string_delref(key);\n  ph_string_delref(val);\n}\n```\n\nPragmatic commentary: if you know that your insert operation won't\ncollide with an existing key (or you are using `PH_HT_REPLACE`),\nand your hash table is large enough (see ph_ht_grow()), the insert\noperation cannot fail and you may elect to ignore the result of the\ninsert.  We won't judge you.\n\n## Fetching Data by Key\n\nThere are two functions for retrieving data from the table.  ph_ht_get()\nreturns the raw pointer to the value as stored in the table whereas\nph_ht_lookup() copies the value into a buffer that you provide.\n\nThe differences are best illustrated by continuing our example:\n\n```\nph_string_t **via_get;\nph_string_t *via_lookup;\n\n\/\/ Need to de-reference this, as we're pointing at the value in\n\/\/ the internal table element\nvia_get = ph_ht_get(&ht, &key);\nif (via_get) {\n   ph_log(PH_LOG_DEBUG, \"got `Ps%p\", *via_get);\n}\n\nif (ph_ht_lookup(&ht, &key, &via_lookup, true) == PH_OK) {\n   ph_log(PH_LOG_DEBUG, \"got `Ps%p\", via_lookup);\n   ph_string_delref(via_lookup);\n}\n```\n\n## Iterating the table\n\nTwo different iterators are provided; the first is a light weight\niterator that passes over the table contents in their physical order.\nThe second is a heavier weight ordered iterator that performs a sort\nof the keys and then passes over the table in sorted key order.\n\nBoth iterators are safe in the presence of concurrent delete operations,\nbut exhibit undefined behavior if the table is resized.\n\n```\nph_ht_iter_t iter;\nph_ht_string **key, **val;\n\n\/\/ Lightweight iterator, order is undefined\nif (ph_ht_iter_first(&ht, &iter, (void*)&key, (void*)&val)) do {\n   ph_log(PH_LOG_DEBUG, \"`Ps%p -> `Ps%p\", *key, *val);\n} while (ph_ht_iter_next(&ht, &iter, (void*)&key, (void*)&val));\n```\n\n```\nph_ht_ordered_iter_t iter;\nph_ht_string **key, **val;\n\n\/\/ Iterate in sorted key order.  Slower than the unordered iteration\n\/\/ as it has to sort the keys at the start and then look up the value\n\/\/ on each iteration\nif (ph_ht_ordered_iter_first(&ht, &iter, (void*)&key, (void*)&val)) do {\n   ph_log(PH_LOG_DEBUG, \"`Ps%p -> `Ps%p\", *key, *val);\n} while (ph_ht_ordered_iter_next(&ht, &iter, (void*)&key, (void*)&val));\n\/\/ Release sorted keys\nph_ht_ordered_iter_end(&ht, &iter);\n```\n\n\n### struct ph_ht_key_def\n\n```c\nstruct ph_ht_key_def {\n  \/* size of keys in bytes *\/\n  uint32_t ksize;\n\n  \/* Hash function *\/\n  uint32_t (*hash_func)(const void *key);\n\n  \/* function to compare two keys.\n   * This is used both for equality and ordering comparisons.\n   * In the latter case, this function is passed as the compare\n   * function parameter to qsort().\n   *\n   * Receives the address of each key.\n   *\n   * If NULL, memcmp is used for maintaining the hash table,\n   * but the ordered_iter can not be used.\n   * *\/\n  int (*key_compare)(const void *a, const void *b);\n\n  \/* function to copy a key\n   * This is called to populate the key portion\n   * of an element during insertion, and also when using lookup.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform an addref operation.\n   *\n   * If NULL, memcpy is used *\/\n  bool (*key_copy)(const void *src, void *dest);\n\n  \/* function to free a key\n   * Called when deleting an entry.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform a delref operation.\n   *\n   * May be NULL *\/\n  void (*key_delete)(void *key);\n};\n```\n\n\n*hash table key definition*\n\n\nThis structure defines the size, hashing, comparison and memory\nmanagement of keys for a hash table instance.\n\n### struct ph_ht_val_def\n\n```c\nstruct ph_ht_val_def {\n  \/* size of values in bytes *\/\n  uint32_t vsize;\n\n  \/* function to copy a value\n   * This is called to populate the value portion\n   * of a element during insertion.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform an addref operation.\n   *\n   * If NULL, memcpy is used *\/\n  bool (*val_copy)(const void *src, void *dest);\n\n  \/* function to free a value\n   * Called when replacing or deleting an entry.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform a delref operation.\n   *\n   * May be NULL *\/\n  void (*val_delete)(void *val);\n};\n```\n\n\n*hash table value definition*\n\n\nThis structure defines the size and memory management of values\nfor a hash table instance.\n\n### ph_ht_init\n\n```c\nph_result_t ph_ht_init(ph_ht_t *ht, uint32_t size_hint,\n    const struct ph_ht_key_def *kdef,\n    const struct ph_ht_val_def *vdef);\n```\n\n\n*Initialize a hash table*\n\n\nConfigures the table pointed to by `ht` to using the supplied\ndefinition and sized to accomodate at least `size_hint` entries\n\nReturns `PH_OK` on success, or an error code on failure.\n\n### ph_ht_grow\n\n```c\nbool ph_ht_grow(ph_ht_t *ht, uint32_t nelems);\n```\n\n\n*Grow the table to accomodate nelems*\n\n\nIf you know that you will be inserting a number of elements that\nwould trigger more than a single resize of the table (for example,\nmoving from a small power of two elements through a couple of powers\nof two), it is advantageous to pre-allocate the ultimate size to\navoid reallocating and rebuilding the table multiple times.\n\nIf `nelems` is larger than the current capacity of the table,\nthis function will grow and rebuild the table to the ideal size\nfor `nelems`.\n\nReturns true if the table is can accomodate nelems, false if there\nwas an issue in growing and rebuilding the table.\n\n### ph_ht_destroy\n\n```c\nvoid ph_ht_destroy(ph_ht_t *ht);\n```\n\n\n*Tear down a hash table*\n\n\nFrees all elements and the table portion.\n\n### ph_ht_free_entries\n\n```c\nvoid ph_ht_free_entries(ph_ht_t *ht);\n```\n\n\n*Empty the hash table*\n\n\nFrees all elements but retains the table definition and current\nsize, ready for re-use.\n\n### ph_ht_set\n\n```c\nph_result_t ph_ht_set(ph_ht_t *ht, void *key, void *value);\n```\n\n\n*Set, but not replace, an entry in the table*\n\n\nEquivalent to calling ph_ht_insert() with the flags set to\n`PH_HT_NO_REPLACE|PH_HT_COPY`.\n\n### ph_ht_replace\n\n```c\nph_result_t ph_ht_replace(ph_ht_t *ht, void *key, void *value);\n```\n\n\n*Set or replace an entry in the table*\n\n\nEquivalent to calling ph_ht_insert() with the flags set to\n`PH_HT_REPLACE|PH_HT_COPY`.\n\n### ph_ht_insert\n\n```c\nph_result_t ph_ht_insert(ph_ht_t *ht, void *key, void *value, int flags);\n```\n\n\n*Insert an entry in the table*\n\n\n`key` is the address of the key, `value` is the address of the value.\n\nAttempts to allocate space as needed; this may fail and cause the insert\noperation to return `PH_NOMEM`.\n\nIf `key` would collide with an existing entry:\n\n* if flags contains `PH_HT_NO_REPLACE`,\n  this function will return `PH_EXISTS`\n* if flags contains `PH_HT_REPLACE`,\n  the del_val function is invoked for the currently\n  associated value prior to replacing the value.\n\nIf the insertion is creating this entry, rather than replacing:\n\n* if flags contains `PH_HT_COPY_KEY`, the copy_key function\n  defined for the key type for this hash table will be used to\n  obtain a copy of the key for the hash table.\n* if flags contains `PH_HT_CLAIM_KEY`, a default memcpy\n  operation will be used to copy the key into the table,\n  claiming ownership.\n\nWhen populating the value:\n\n* if flags contains `PH_HT_COPY_VAL`, the copy_val function\n  defined for the value type for this hash table will be used to\n  obtain a copy of the value for the hash table.\n* if flags contains `PH_HT_CLAIM_VAL`, a default memcpy\n  operation will be used to copy the value into the table,\n  claiming ownership.\n\nYou may use `PH_HT_COPY` as a shortcut for setting both\n`PH_HT_COPY_VAL` and `PH_HT_COPY_KEY` in flags.\n\nYou may use `PH_HT_CLAIM` as a shortcut for setting both\n`PH_HT_CLAIM_VAL` and `PH_HT_CLAIM_KEY` in flags.\n\nIf flags contains both `PH_HT_COPY_VAL` and `PH_HT_CLAIM_VAL`\nthe results of calling this function are undefined.\n\nIf flags contains both `PH_HT_COPY_KEY` and `PH_HT_CLAIM_KEY`\nthe results of calling this function are undefined.\n\nIf flags contains both `PH_HT_REPLACE` and `PH_HT_NO_REPLACE`\nthe results of calling this function are undefined.\n\nWhen successful, returns `PH_OK`.\n\n### ph_ht_get\n\n```c\nvoid *ph_ht_get(ph_ht_t *ht, const void *key);\n```\n\n\n*Looks up the value associated with key and returns its address.*\n\nReturns 0 if there was no matching value.\n\nThis function will NOT invoke copy_val on the returned value.\n\n### ph_ht_lookup\n\n```c\nph_result_t ph_ht_lookup(ph_ht_t *ht, const void *key, void *val, bool copy);\n```\n\n\n*Looks up the value associated with key.*\n\nIf found, stores the value into *VAL.\nIf copy==true and copy_val is defined, then it is invoked on the value\nprior to storing it to *VAL.\nReturns `PH_OK` if the value was found, `PH_NOENT` if it was not present,\nor an error code in case the value could not be copied.\n\n### ph_ht_del\n\n```c\nph_result_t ph_ht_del(ph_ht_t *ht, const void *key);\n```\n\n\n*Deletes the value associated with key.*\n\nIf del_val is defined, it is invoked on the value stored in the table.\nIf del_key is defined, it is invoked on the key stored in the table.\nReturns `PH_OK` if the element was present in the table and was removed,\n`PH_NOENT` otherwise.\n\n### ph_ht_size\n\n```c\nuint32_t ph_ht_size(ph_ht_t *ht);\n```\n\n\n*Returns the number of elements stored in the table*\n\n\n### struct ph_ht_iter\n\n```c\nstruct ph_ht_iter {\n  uint32_t slot;\n```\n\n\n*Iterator for hash elements.*\n\nIteration will be halted if the table size changes during\niteration.\n\n### ph_ht_iter_first\n\n```c\nbool ph_ht_iter_first(ph_ht_t *ht, ph_ht_iter_t *iter, void **key, void **val);\n```\n\n\n*Begin iterating a table*\n\n\nReturns false if the table is empty, otherwise updates the\niter such that a subsequent call to ph_ht_iter_next will\nretrieve the next value, and stores the address of the\nkey and value of this first element in the provided pointers.\n\nThe order of iteration is undefined.  For a defined iteration\norder, use ph_iter_ordered_iter_first().\n\n### ph_ht_iter_next\n\n```c\nbool ph_ht_iter_next(ph_ht_t *ht, ph_ht_iter_t *iter, void **key, void **val);\n```\n\n\n*Walk to the next entry in a table*\n\n\nReturns false if there are no more elements to iterate.\nOtherwise, updates the iter such that a subsequent call\nwill retrieve the next value, and stores the address of\nthe key and value of the current element in the provided\npointers.\n\n### struct ph_ht_ordered_iter\n\n```c\nstruct ph_ht_ordered_iter {\n  uint32_t slot;\n```\n\n\n*Iterating in a defined order*\n\n\nThis iterator performs a sort over the keys of the table and maintains\na copy of the sorted keys.\n\n### ph_ht_ordered_iter_first\n\n```c\nbool ph_ht_ordered_iter_first(ph_ht_t *ht, ph_ht_ordered_iter_t *iter,\n    void **key, void **val);\n```\n\n\n*Begin iterating a table in a defined order.*\n\n\nIf the table is empty, returns false and sets errno to ENOENT.\n\nOtherwise, allocates storage to hold keys of the table.  If the\nallocation fails, returns false and sets errno to ENOMEM.\n\nUses the key_compare function to sort the keys and stores the\naddress of the key and value of the first logical key\/value\ninto the provided pointers, and returns true.\n\nThe caller *must* call ph_ht_ordered_iter_end() to dispose of\nthe resources allocated by the iterator when it is no longer\nneeded.\n\n### ph_ht_ordered_iter_next\n\n```c\nbool ph_ht_ordered_iter_next(ph_ht_t *ht, ph_ht_ordered_iter_t *iter,\n    void **key, void **val);\n```\n\n\n*Walk to the next ordered entry in a table*\n\n\nReturns false if there are no more elements to iterate.\n\nOtherwise, updates the iter such that a subsequent call will\nretrieve the next value and stores the address of the key and value\nof the current element in the provided pointers.\n\nThe caller *must* call ph_ht_ordered_iter_end() to dispose of\nthe resources allocated by the iterator when it is no longer needed.\n\n### ph_ht_ordered_iter_end\n\n```c\nvoid ph_ht_ordered_iter_end(ph_ht_t *ht, ph_ht_ordered_iter_t *iter);\n```\n\n\n*Release resources associated with an ordered iterator*\n\n",
        "decl_titles": [
            "struct ph_ht_key_def",
            "struct ph_ht_val_def",
            "ph_ht_init",
            "ph_ht_grow",
            "ph_ht_destroy",
            "ph_ht_free_entries",
            "ph_ht_set",
            "ph_ht_replace",
            "ph_ht_insert",
            "ph_ht_get",
            "ph_ht_lookup",
            "ph_ht_del",
            "ph_ht_size",
            "struct ph_ht_iter",
            "ph_ht_iter_first",
            "ph_ht_iter_next",
            "struct ph_ht_ordered_iter",
            "ph_ht_ordered_iter_first",
            "ph_ht_ordered_iter_next",
            "ph_ht_ordered_iter_end"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_HASHTABLE_H\n#define PHENOM_HASHTABLE_H\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/**\n * # Hash Table\n *\n * libPhenom provides a hash table facility that allows the\n * construction of maps from an arbitrary key type to\n * an arbitrary value type.\n *\n * The hash table uses closed hashing \/ open addressing to reduce the volume\n * of discrete allocations required to maintain the table.\n *\n * Note: The tables have no built-in mutex or locking capability.  For a\n * concurrent map you might consider using the Concurrency Kit hash-set API.\n * You may alternatively wrap your hash table implementation in an appropriate\n * mutex or reader-writer lock.\n *\n * ## Defining a hash table\n *\n * This implementation uses separate key and value definition structures\n * so that you can factor out and re-use the code for keys\n * across different hash tables.  `ph_string_t*` key and value implementations\n * are provided:\n *\n * ```\n * ph_ht_t ht;\n *\n * \/\/ Declare a map from ph_string_t* -&gt; ph_string_t*\n * ph_ht_init(&amp;ht, 1, &amp;ph_ht_string_key_def, &amp;ph_ht_string_val_def);\n * ```\n *\n * The table allocates storage for each element based on the sum of\n * the key size and value size declared in the key and value definitions.\n *\n * The implementation is flexible enough to allow you to track pointers\n * to other structures or to embed them directly, provided that they\n * have a fixed size.\n *\n * ## Inserting data into the table\n *\n * All insert operations are expressed in terms of the ph_ht_insert()\n * function.  Two convenience functions are provided to make this less\n * verbose: ph_ht_set() and ph_ht_replace().\n *\n * Since the API is intended to handle arbitrary key or data types, it\n * is expressed in terms of `void*` types for keys and values.\n *\n * Note: you must pass the address of the keys and values\n * to be stored.\n *\n * For example, continuing with our string-&gt;string map above:\n *\n * ```COUNTEREXAMPLE\n * ph_string_t *key = ph_string_make_cstr(mt_mytype, &quot;key&quot;);\n * ph_string_t *val = ph_string_make_cstr(mt_mytype, &quot;val&quot;);\n *\n * ph_ht_set(&amp;ht, key, val);   \/\/ WRONG! will crash\n * ```\n *\n * ```\n * ph_string_t *key = ph_string_make_cstr(mt_mytype, &quot;key&quot;);\n * ph_string_t *val = ph_string_make_cstr(mt_mytype, &quot;val&quot;);\n *\n * ph_ht_set(&amp;ht, &amp;key, &amp;val); \/\/ CORRECT!\n *\n * \/\/ the set and replace APIs operate in COPY mode, so we need to\n * \/\/ clean up our string references\n * ph_string_delref(key);\n * ph_string_delref(val);\n * ```\n *\n * ## Inserting and claiming values\n *\n * If you&#039;re constructing refcounted keys\/values just to put them in the\n * table, it can be tedious to repitively bracket the inserts with\n * create and delref calls.\n *\n * For this situation you can use ph_ht_insert() and the `PH_HT_CLAIM`\n * flag.  When claiming, if the insertion was successful, the table will\n * take ownership of the references you passed to the table.  If the insert\n * fails, you still own your references so that you can print out a\n * meaningful error.\n *\n * ```\n * ph_string_t *key = ph_string_make_cstr(mt_mytype, &quot;key&quot;);\n * ph_string_t *val = ph_string_make_cstr(mt_mytype, &quot;val&quot;);\n *\n * if (ph_ht_insert(&amp;ht, &amp;key, &amp;val, PH_HT_CLAIM) != PH_OK) {\n *   ph_log(PH_LOG_ERR, &quot;failed to insert `Ps%p -&gt; `Ps%p&quot;,\n *         (void*)key, (void*)val);\n *   ph_string_delref(key);\n *   ph_string_delref(val);\n * }\n * ```\n *\n * Pragmatic commentary: if you know that your insert operation won&#039;t\n * collide with an existing key (or you are using `PH_HT_REPLACE`),\n * and your hash table is large enough (see ph_ht_grow()), the insert\n * operation cannot fail and you may elect to ignore the result of the\n * insert.  We won&#039;t judge you.\n *\n * ## Fetching Data by Key\n *\n * There are two functions for retrieving data from the table.  ph_ht_get()\n * returns the raw pointer to the value as stored in the table whereas\n * ph_ht_lookup() copies the value into a buffer that you provide.\n *\n * The differences are best illustrated by continuing our example:\n *\n * ```\n * ph_string_t **via_get;\n * ph_string_t *via_lookup;\n *\n * \/\/ Need to de-reference this, as we&#039;re pointing at the value in\n * \/\/ the internal table element\n * via_get = ph_ht_get(&amp;ht, &amp;key);\n * if (via_get) {\n *    ph_log(PH_LOG_DEBUG, &quot;got `Ps%p&quot;, *via_get);\n * }\n *\n * if (ph_ht_lookup(&amp;ht, &amp;key, &amp;via_lookup, true) == PH_OK) {\n *    ph_log(PH_LOG_DEBUG, &quot;got `Ps%p&quot;, via_lookup);\n *    ph_string_delref(via_lookup);\n * }\n * ```\n *\n * ## Iterating the table\n *\n * Two different iterators are provided; the first is a light weight\n * iterator that passes over the table contents in their physical order.\n * The second is a heavier weight ordered iterator that performs a sort\n * of the keys and then passes over the table in sorted key order.\n *\n * Both iterators are safe in the presence of concurrent delete operations,\n * but exhibit undefined behavior if the table is resized.\n *\n * ```\n * ph_ht_iter_t iter;\n * ph_ht_string **key, **val;\n *\n * \/\/ Lightweight iterator, order is undefined\n * if (ph_ht_iter_first(&amp;ht, &amp;iter, (void*)&amp;key, (void*)&amp;val)) do {\n *    ph_log(PH_LOG_DEBUG, &quot;`Ps%p -&gt; `Ps%p&quot;, *key, *val);\n * } while (ph_ht_iter_next(&amp;ht, &amp;iter, (void*)&amp;key, (void*)&amp;val));\n * ```\n *\n * ```\n * ph_ht_ordered_iter_t iter;\n * ph_ht_string **key, **val;\n *\n * \/\/ Iterate in sorted key order.  Slower than the unordered iteration\n * \/\/ as it has to sort the keys at the start and then look up the value\n * \/\/ on each iteration\n * if (ph_ht_ordered_iter_first(&amp;ht, &amp;iter, (void*)&amp;key, (void*)&amp;val)) do {\n *    ph_log(PH_LOG_DEBUG, &quot;`Ps%p -&gt; `Ps%p&quot;, *key, *val);\n * } while (ph_ht_ordered_iter_next(&amp;ht, &amp;iter, (void*)&amp;key, (void*)&amp;val));\n * \/\/ Release sorted keys\n * ph_ht_ordered_iter_end(&amp;ht, &amp;iter);\n * ```\n *\n *\/\n\n\/** hash table key definition\n *\n * This structure defines the size, hashing, comparison and memory\n * management of keys for a hash table instance.\n *\/\nstruct ph_ht_key_def {\n  \/* size of keys in bytes *\/\n  uint32_t ksize;\n\n  \/* Hash function *\/\n  uint32_t (*hash_func)(const void *key);\n\n  \/* function to compare two keys.\n   * This is used both for equality and ordering comparisons.\n   * In the latter case, this function is passed as the compare\n   * function parameter to qsort().\n   *\n   * Receives the address of each key.\n   *\n   * If NULL, memcmp is used for maintaining the hash table,\n   * but the ordered_iter can not be used.\n   * *\/\n  int (*key_compare)(const void *a, const void *b);\n\n  \/* function to copy a key\n   * This is called to populate the key portion\n   * of an element during insertion, and also when using lookup.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform an addref operation.\n   *\n   * If NULL, memcpy is used *\/\n  bool (*key_copy)(const void *src, void *dest);\n\n  \/* function to free a key\n   * Called when deleting an entry.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform a delref operation.\n   *\n   * May be NULL *\/\n  void (*key_delete)(void *key);\n};\n\n\/** hash table value definition\n *\n * This structure defines the size and memory management of values\n * for a hash table instance.\n *\/\nstruct ph_ht_val_def {\n  \/* size of values in bytes *\/\n  uint32_t vsize;\n\n  \/* function to copy a value\n   * This is called to populate the value portion\n   * of a element during insertion.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform an addref operation.\n   *\n   * If NULL, memcpy is used *\/\n  bool (*val_copy)(const void *src, void *dest);\n\n  \/* function to free a value\n   * Called when replacing or deleting an entry.\n   *\n   * If you are tracking refcounted pointers, this is the logical\n   * place to perform a delref operation.\n   *\n   * May be NULL *\/\n  void (*val_delete)(void *val);\n};\n\n#define PH_HT_ELEM_EMPTY     0\n#define PH_HT_ELEM_TAKEN     1\n#define PH_HT_ELEM_TOMBSTONE 2\nstruct ph_ht_elem {\n  uint32_t status;\n  \/* variable size: key followed by value embedded here *\/\n};\n\nstruct ph_ht {\n  uint32_t nelems;\n  uint64_t table_size, elem_size, mask;\n  const struct ph_ht_key_def *kdef;\n  const struct ph_ht_val_def *vdef;\n  \/* points to the table, an array of table_size elements *\/\n  char *table;\n};\n\ntypedef struct ph_ht ph_ht_t;\n\n\/** Initialize a hash table\n *\n * Configures the table pointed to by `ht` to using the supplied\n * definition and sized to accomodate at least `size_hint` entries\n *\n * Returns `PH_OK` on success, or an error code on failure.\n *\/\nph_result_t ph_ht_init(ph_ht_t *ht, uint32_t size_hint,\n    const struct ph_ht_key_def *kdef,\n    const struct ph_ht_val_def *vdef);\n\n\/** Grow the table to accomodate nelems\n *\n * If you know that you will be inserting a number of elements that\n * would trigger more than a single resize of the table (for example,\n * moving from a small power of two elements through a couple of powers\n * of two), it is advantageous to pre-allocate the ultimate size to\n * avoid reallocating and rebuilding the table multiple times.\n *\n * If `nelems` is larger than the current capacity of the table,\n * this function will grow and rebuild the table to the ideal size\n * for `nelems`.\n *\n * Returns true if the table is can accomodate nelems, false if there\n * was an issue in growing and rebuilding the table.\n *\/\nbool ph_ht_grow(ph_ht_t *ht, uint32_t nelems);\n\n\/** Tear down a hash table\n *\n * Frees all elements and the table portion.\n *\/\nvoid ph_ht_destroy(ph_ht_t *ht);\n\n\/** Empty the hash table\n *\n * Frees all elements but retains the table definition and current\n * size, ready for re-use.\n *\/\nvoid ph_ht_free_entries(ph_ht_t *ht);\n\n\/** Set, but not replace, an entry in the table\n *\n * Equivalent to calling ph_ht_insert() with the flags set to\n * `PH_HT_NO_REPLACE|PH_HT_COPY`.\n *\/\nph_result_t ph_ht_set(ph_ht_t *ht, void *key, void *value);\n\n\/** Set or replace an entry in the table\n *\n * Equivalent to calling ph_ht_insert() with the flags set to\n * `PH_HT_REPLACE|PH_HT_COPY`.\n *\/\nph_result_t ph_ht_replace(ph_ht_t *ht, void *key, void *value);\n\n#define PH_HT_REPLACE    1\n#define PH_HT_NO_REPLACE 0\n#define PH_HT_CLAIM_KEY 2\n#define PH_HT_COPY_KEY  0\n#define PH_HT_CLAIM_VAL 4\n#define PH_HT_COPY_VAL  0\n#define PH_HT_CLAIM (PH_HT_CLAIM_KEY|PH_HT_CLAIM_VAL)\n#define PH_HT_COPY  (PH_HT_COPY_KEY|PH_HT_COPY_VAL)\n\/** Insert an entry in the table\n *\n * `key` is the address of the key, `value` is the address of the value.\n *\n * Attempts to allocate space as needed; this may fail and cause the insert\n * operation to return `PH_NOMEM`.\n *\n * If `key` would collide with an existing entry:\n *\n * * if flags contains `PH_HT_NO_REPLACE`,\n *   this function will return `PH_EXISTS`\n * * if flags contains `PH_HT_REPLACE`,\n *   the del_val function is invoked for the currently\n *   associated value prior to replacing the value.\n *\n * If the insertion is creating this entry, rather than replacing:\n *\n * * if flags contains `PH_HT_COPY_KEY`, the copy_key function\n *   defined for the key type for this hash table will be used to\n *   obtain a copy of the key for the hash table.\n * * if flags contains `PH_HT_CLAIM_KEY`, a default memcpy\n *   operation will be used to copy the key into the table,\n *   claiming ownership.\n *\n * When populating the value:\n *\n * * if flags contains `PH_HT_COPY_VAL`, the copy_val function\n *   defined for the value type for this hash table will be used to\n *   obtain a copy of the value for the hash table.\n * * if flags contains `PH_HT_CLAIM_VAL`, a default memcpy\n *   operation will be used to copy the value into the table,\n *   claiming ownership.\n *\n * You may use `PH_HT_COPY` as a shortcut for setting both\n * `PH_HT_COPY_VAL` and `PH_HT_COPY_KEY` in flags.\n *\n * You may use `PH_HT_CLAIM` as a shortcut for setting both\n * `PH_HT_CLAIM_VAL` and `PH_HT_CLAIM_KEY` in flags.\n *\n * If flags contains both `PH_HT_COPY_VAL` and `PH_HT_CLAIM_VAL`\n * the results of calling this function are undefined.\n *\n * If flags contains both `PH_HT_COPY_KEY` and `PH_HT_CLAIM_KEY`\n * the results of calling this function are undefined.\n *\n * If flags contains both `PH_HT_REPLACE` and `PH_HT_NO_REPLACE`\n * the results of calling this function are undefined.\n *\n * When successful, returns `PH_OK`.\n *\/\nph_result_t ph_ht_insert(ph_ht_t *ht, void *key, void *value, int flags);\n\n\/** Looks up the value associated with key and returns its address.\n * Returns 0 if there was no matching value.\n *\n * This function will NOT invoke copy_val on the returned value.\n *\/\nvoid *ph_ht_get(ph_ht_t *ht, const void *key);\n\n\/** Looks up the value associated with key.\n * If found, stores the value into *VAL.\n * If copy==true and copy_val is defined, then it is invoked on the value\n * prior to storing it to *VAL.\n * Returns `PH_OK` if the value was found, `PH_NOENT` if it was not present,\n * or an error code in case the value could not be copied.\n *\/\nph_result_t ph_ht_lookup(ph_ht_t *ht, const void *key, void *val, bool copy);\n\n\/** Deletes the value associated with key.\n * If del_val is defined, it is invoked on the value stored in the table.\n * If del_key is defined, it is invoked on the key stored in the table.\n * Returns `PH_OK` if the element was present in the table and was removed,\n * `PH_NOENT` otherwise.\n *\/\nph_result_t ph_ht_del(ph_ht_t *ht, const void *key);\n\n\/** Returns the number of elements stored in the table *\/\nuint32_t ph_ht_size(ph_ht_t *ht);\n\n\/** Iterator for hash elements.\n * Iteration will be halted if the table size changes during\n * iteration. *\/\nstruct ph_ht_iter {\n  uint32_t slot;\n  uint32_t size;\n};\ntypedef struct ph_ht_iter ph_ht_iter_t;\n\n\/** Begin iterating a table\n *\n * Returns false if the table is empty, otherwise updates the\n * iter such that a subsequent call to ph_ht_iter_next will\n * retrieve the next value, and stores the address of the\n * key and value of this first element in the provided pointers.\n *\n * The order of iteration is undefined.  For a defined iteration\n * order, use ph_iter_ordered_iter_first().\n *\/\nbool ph_ht_iter_first(ph_ht_t *ht, ph_ht_iter_t *iter, void **key, void **val);\n\n\/** Walk to the next entry in a table\n *\n * Returns false if there are no more elements to iterate.\n * Otherwise, updates the iter such that a subsequent call\n * will retrieve the next value, and stores the address of\n * the key and value of the current element in the provided\n * pointers.\n *\/\nbool ph_ht_iter_next(ph_ht_t *ht, ph_ht_iter_t *iter, void **key, void **val);\n\n\/** Iterating in a defined order\n *\n * This iterator performs a sort over the keys of the table and maintains\n * a copy of the sorted keys.\n *\/\nstruct ph_ht_ordered_iter {\n  uint32_t slot;\n  uint32_t size;\n  char *slots;\n};\ntypedef struct ph_ht_ordered_iter ph_ht_ordered_iter_t;\n\n\/** Begin iterating a table in a defined order.\n *\n * If the table is empty, returns false and sets errno to ENOENT.\n *\n * Otherwise, allocates storage to hold keys of the table.  If the\n * allocation fails, returns false and sets errno to ENOMEM.\n *\n * Uses the key_compare function to sort the keys and stores the\n * address of the key and value of the first logical key\/value\n * into the provided pointers, and returns true.\n *\n * The caller *must* call ph_ht_ordered_iter_end() to dispose of\n * the resources allocated by the iterator when it is no longer\n * needed.\n *\/\nbool ph_ht_ordered_iter_first(ph_ht_t *ht, ph_ht_ordered_iter_t *iter,\n    void **key, void **val);\n\n\/** Walk to the next ordered entry in a table\n *\n * Returns false if there are no more elements to iterate.\n *\n * Otherwise, updates the iter such that a subsequent call will\n * retrieve the next value and stores the address of the key and value\n * of the current element in the provided pointers.\n *\n * The caller *must* call ph_ht_ordered_iter_end() to dispose of\n * the resources allocated by the iterator when it is no longer needed.\n *\/\nbool ph_ht_ordered_iter_next(ph_ht_t *ht, ph_ht_ordered_iter_t *iter,\n    void **key, void **val);\n\n\/** Release resources associated with an ordered iterator *\/\nvoid ph_ht_ordered_iter_end(ph_ht_t *ht, ph_ht_ordered_iter_t *iter);\n\n\/* String key definition for hash tables *\/\nextern struct ph_ht_key_def ph_ht_string_key_def;\n\n\/* String value definition for hash tables *\/\nextern struct ph_ht_val_def ph_ht_string_val_def;\n\n\/* Generic pointer value definition for hash tables *\/\nextern struct ph_ht_val_def ph_ht_ptr_val_def;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "hook": {
        "name": "hook",
        "title": "hook",
        "content": "\n### ph_hook_point_get\n\n```c\nph_hook_point_t *ph_hook_point_get(ph_string_t *name, bool create);\n```\n\n\n*Resolve a hook point by name*\n\n\nIf the hook point does not exist and `create` is true, creates\nthe hook point and returns it.\n\nOnce created, a hook point is never deleted.\n\n### ph_hook_point_get_cstr\n\n```c\nph_hook_point_t *ph_hook_point_get_cstr(const char *name, bool create);\n```\n\n\n*Resolve a hook point by c-string name*\n\n\nDelegates to ph_hook_point_get().\n\n### ph_hook_invoke_inner\n\n```c\nvoid ph_hook_invoke_inner(ph_hook_point_t *hook,\n    uint8_t nargs, void **args)\n```\n\n\n*Invoke a hook*\n\n\n### ph_hook_invokev\n\n```c\n#define PH_HOOK_MAX_VARGS 16\nstatic inline void ph_hook_invokev(ph_hook_point_t *hook,\n    uint8_t nargs, va_list ap)\n{\n  uint8_t n;\n```\n\n\n*Invoke a hook with varargs via va_list*\n\n\nEach argument MUST be a pointer to the value in question\n\n### ph_hook_invoke_vargs\n\n```c\nvoid ph_hook_invoke_vargs(ph_hook_point_t *hook, uint8_t nargs, ...);\n```\n\n\n*Invoke a hook with varargs*\n\n\nEach argument MUST be a pointer to the value in question\n\n### ph_hook_invocation_stop\n\n```c\nvoid ph_hook_invocation_stop(ph_hook_invocation_t *inv)\n```\n\n\n*Stop invoking the current hook*\n\n\nPrevents any later handlers from being called\n\n### ph_hook_register\n\n```c\nph_result_t ph_hook_register(ph_string_t *name, ph_hook_func func,\n    void *closure, int8_t pri, ph_hook_unreg_func unreg);\n```\n\n\n*Register a hook callback*\n\n\nCreates a hook point with the specified name, then registers\nan entry in the hook item list.\n\nEach registration call will add a hook entry, regardless of the currently\nregistered hooks, even if this would cause a duplicate entry to be made.\n\nThe `unreg` func will be invoked when a hook item is unregistered.\nThis allows for resources to be released at the appropriate time.\n\n`pri` specifies the priority of the item; it may be any value in the full\nrange of an `int8_t`.  The convention is to specify a `pri = 0` in the\ncase that you don't care when the item is invoked or `PH_HOOK_PRI_FIRST`\nif you want to make the item to be the first to be invoked, or\n`PH_HOOK_PRI_LAST` if you want it to be last.  These constants don't\nliterally map to first or last but put the priority in the right ballpark.\n\nThe hook items are sorted according to ascending priority value, with the\nmost negative `int8_t` value being the very first to run.  If two items\nhave the same `pri` value then they are run in an unspecified order with\nrespect to each other.  The implementation guarantees that this unspecified\norder will be consistent for any pair of hook items.  That is, if there\nare two hook items `tuple(N1, F1, C1)` and `tuple(N1, F2, C2)` that have the\nsame `pri` value, `F1` and `F2` will always be invoked in the same relative\norder for the lifetime of the process.\n\n### ph_hook_register_cstr\n\n```c\nph_result_t ph_hook_register_cstr(const char *name, ph_hook_func func,\n    void *closure, int8_t pri, ph_hook_unreg_func unreg);\n```\n\n\n*Register a hook callback*\n\n\nDelegates to ph_hook_register() but is declared in terms of a C-string\n\n### ph_hook_unregister\n\n```c\nph_result_t ph_hook_unregister(ph_string_t *name, ph_hook_func func,\n    void *closure);\n```\n\n\n*Unregister a previously registered hook item*\n\n\nReturns `PH_OK` if the item was present and has been removed, `PH_ERR`\notherwise.\n\nIf duplicate entries that match `func` and `closure` are present, at\nmost 1 of them will be removed.  It is undefined which will be removed.\nThis preserves the property that for each register call that was made,\nthere should be one call to unregister it.  You should avoid registering\nduplicates.\n\nThe `unreg` function associated with the item will be scheduled via\nph_thread_epoch_defer(), which typically means that it will be invoked\nat some pointer after the current stack frame unwinds.\n\n### ph_hook_unregister_cstr\n\n```c\nph_result_t ph_hook_unregister_cstr(const char *name, ph_hook_func func,\n    void *closure);\n```\n\n\n*Unregister a previously registered hook item*\n\n\nDelegates to ph_hook_unreg_func() but is declared in terms of a C-string\n",
        "decl_titles": [
            "ph_hook_point_get",
            "ph_hook_point_get_cstr",
            "ph_hook_invoke_inner",
            "ph_hook_invokev",
            "ph_hook_invoke_vargs",
            "ph_hook_invocation_stop",
            "ph_hook_register",
            "ph_hook_register_cstr",
            "ph_hook_unregister",
            "ph_hook_unregister_cstr"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_HOOK_H\n#define PHENOM_HOOK_H\n\n#include &quot;phenom\/string.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_hook_invocation;\ntypedef struct ph_hook_invocation ph_hook_invocation_t;\n\ntypedef void (*ph_hook_func)(ph_hook_invocation_t *inv,\n    void *closure, uint8_t nargs, void **args);\n\ntypedef void (*ph_hook_unreg_func)(void *closure, ph_hook_func func);\n\nstruct ph_hook_item {\n  void *closure;\n  ph_hook_func func;\n  int8_t pri;\n  ph_hook_unreg_func unreg;\n};\ntypedef struct ph_hook_item ph_hook_item_t;\n\nstruct ph_hook_point_head {\n  ck_epoch_entry_t entry;\n  uint16_t nitems;\n  ph_hook_item_t items[1];\n};\ntypedef struct ph_hook_point_head ph_hook_point_head_t;\n\nstruct ph_hook_point {\n  ph_hook_point_head_t *head;\n};\ntypedef struct ph_hook_point ph_hook_point_t;\n\nstruct ph_hook_invocation {\n  bool stopped;\n};\n\n\/** Resolve a hook point by name\n *\n * If the hook point does not exist and `create` is true, creates\n * the hook point and returns it.\n *\n * Once created, a hook point is never deleted.\n *\/\nph_hook_point_t *ph_hook_point_get(ph_string_t *name, bool create);\n\n\/** Resolve a hook point by c-string name\n *\n * Delegates to ph_hook_point_get().\n *\/\nph_hook_point_t *ph_hook_point_get_cstr(const char *name, bool create);\n\n\/** Invoke a hook\n *\/\nstatic inline void ph_hook_invoke_inner(ph_hook_point_t *hook,\n    uint8_t nargs, void **args)\n{\n  ph_hook_point_head_t *head = ck_pr_load_ptr(&amp;hook-&gt;head);\n  uint16_t n;\n  ph_hook_invocation_t inv;\n\n  if (!head) {\n    return;\n  }\n\n  inv.stopped = false;\n\n  for (n = 0; n &lt; head-&gt;nitems; n++) {\n    head-&gt;items[n].func(&amp;inv, head-&gt;items[n].closure, nargs, args);\n    if (inv.stopped) {\n      break;\n    }\n  }\n}\n\n\/** Invoke a hook with varargs via va_list\n *\n * Each argument MUST be a pointer to the value in question\n *\/\n#define PH_HOOK_MAX_VARGS 16\nstatic inline void ph_hook_invokev(ph_hook_point_t *hook,\n    uint8_t nargs, va_list ap)\n{\n  uint8_t n;\n\/* please rethink your API if you need more than this *\/\n  void *args[PH_HOOK_MAX_VARGS];\n\n  ph_debug_assert(nargs &lt; PH_HOOK_MAX_VARGS, &quot;nargs is too big&quot;);\n\n  for (n = 0; n &lt; nargs; n++) {\n    args[n] = va_arg(ap, void*);\n  }\n\n  ph_hook_invoke_inner(hook, nargs, args);\n}\n\n\/** Invoke a hook with varargs\n *\n * Each argument MUST be a pointer to the value in question\n *\/\nvoid ph_hook_invoke_vargs(ph_hook_point_t *hook, uint8_t nargs, ...);\n\n#define ph_hook_invoke(hook, nargs, ...) do { \\\n  ph_debug_assert(nargs &lt; PH_HOOK_MAX_VARGS, &quot;nargs too big&quot;); \\\n  ph_hook_invoke_vargs(hook, nargs, __VA_ARGS__); \\\n} while (0)\n\n\/** Stop invoking the current hook\n *\n * Prevents any later handlers from being called\n *\/\nstatic inline void ph_hook_invocation_stop(ph_hook_invocation_t *inv)\n{\n  inv-&gt;stopped = true;\n}\n\n#define PH_HOOK_PRI_FIRST (-100)\n#define PH_HOOK_PRI_LAST    100\n\n\/** Register a hook callback\n *\n * Creates a hook point with the specified name, then registers\n * an entry in the hook item list.\n *\n * Each registration call will add a hook entry, regardless of the currently\n * registered hooks, even if this would cause a duplicate entry to be made.\n *\n * The `unreg` func will be invoked when a hook item is unregistered.\n * This allows for resources to be released at the appropriate time.\n *\n * `pri` specifies the priority of the item; it may be any value in the full\n * range of an `int8_t`.  The convention is to specify a `pri = 0` in the\n * case that you don&#039;t care when the item is invoked or `PH_HOOK_PRI_FIRST`\n * if you want to make the item to be the first to be invoked, or\n * `PH_HOOK_PRI_LAST` if you want it to be last.  These constants don&#039;t\n * literally map to first or last but put the priority in the right ballpark.\n *\n * The hook items are sorted according to ascending priority value, with the\n * most negative `int8_t` value being the very first to run.  If two items\n * have the same `pri` value then they are run in an unspecified order with\n * respect to each other.  The implementation guarantees that this unspecified\n * order will be consistent for any pair of hook items.  That is, if there\n * are two hook items `tuple(N1, F1, C1)` and `tuple(N1, F2, C2)` that have the\n * same `pri` value, `F1` and `F2` will always be invoked in the same relative\n * order for the lifetime of the process.\n *\/\nph_result_t ph_hook_register(ph_string_t *name, ph_hook_func func,\n    void *closure, int8_t pri, ph_hook_unreg_func unreg);\n\n\/** Register a hook callback\n *\n * Delegates to ph_hook_register() but is declared in terms of a C-string\n *\/\nph_result_t ph_hook_register_cstr(const char *name, ph_hook_func func,\n    void *closure, int8_t pri, ph_hook_unreg_func unreg);\n\n\/** Unregister a previously registered hook item\n *\n * Returns `PH_OK` if the item was present and has been removed, `PH_ERR`\n * otherwise.\n *\n * If duplicate entries that match `func` and `closure` are present, at\n * most 1 of them will be removed.  It is undefined which will be removed.\n * This preserves the property that for each register call that was made,\n * there should be one call to unregister it.  You should avoid registering\n * duplicates.\n *\n * The `unreg` function associated with the item will be scheduled via\n * ph_thread_epoch_defer(), which typically means that it will be invoked\n * at some pointer after the current stack frame unwinds.\n *\/\nph_result_t ph_hook_unregister(ph_string_t *name, ph_hook_func func,\n    void *closure);\n\n\/** Unregister a previously registered hook item\n *\n * Delegates to ph_hook_unreg_func() but is declared in terms of a C-string\n *\/\nph_result_t ph_hook_unregister_cstr(const char *name, ph_hook_func func,\n    void *closure);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "job": {
        "name": "job",
        "title": "job",
        "content": "\n# Jobs\nJobs describe a parcel of work.  Jobs may be triggered or dispatched\nin one of a number of \"run classes\".  There are three run classes:\n\n- Immediate. The work is dispatched immediately on the calling thread.\n- NBIO. The work is dispatched when a descriptor is signalled for I\/O.\n- Pool. The work is queued to a thread pool and is dispatched as soon as a\n  worker becomes available.  libPhenom allows multiple pools to be defined to\n  better partition and prioritize your workload.\n\n# Affinity\n\nBy default, threads created by ph_thread_pool_define() and threads in the\nNBIO pool use an affinity policy that spreads out the threads and binds\nthem to the CPU cores based on their phenom `tid`.\n\nEach thread with a phenom TLS segment is assigned a `tid` starting with 0\nfor the main thread of the process, increasing by 1 for each additional\nthread.\n\nEach thread in a thread pool has a `wid` starting at 1 for the \"first\"\nthread in that pool, increasing by 1 for each additional thread.\n\nThe default affinity selector is based on the `tid` such that a process\nthat uses libphenom exclusively for its threads maps each thread across\nthe set of CPU cores.\n\nIn more complex environments, there may be threads created by other\nlibraries and the overall affinity configuration is made more complex.\nTo cater for this, you may specify the affinity selection in your phenom\nconfiguration file.\n\nFor the NBIO pool:\n\n```\n{\n  \"nbio\": {\n    \"affinity\": {\n      \"base\": 0,\n      \"selector\": \"tid\"\n    }\n  }\n}\n```\n\nFor any other thread pool, for example, the \"MYNAME\" pool:\n\n```\n{\n  \"threadpool\": {\n    \"MYNAME\": {\n      \"affinity\": {\n        \"base\": 0,\n        \"selector\": \"tid\"\n      }\n    }\n  }\n}\n```\n\nThe `base` parameter specifies the offset of the first CPU to bind.\nThe default is CPU `0`.\n\nPossible values for `selector` are:\n\n* `tid` - binds to `(base + thr->tid) % cores`\n* `wid` - binds to `(base + thr->wid - 1) % cores`\n* `none` - does not set CPU affinity\n* `[1,2,3]` allows the thread to bind to any CPU in the set\n  `[base + 1, base + 2, base + 3]`.  This specifies an affinity mask, so all\n  of the threads in this pool will be able to run on any of the CPUs in the\n  specified set.  libPhenom currently only supports this form on Linux and\n  BSDish systems; other platforms will bind to the first CPU in the set.\n* `2` - binds to CPU `base + 2`.  This causes all threads in the pool to\n  bind to the specified CPU.\n\nIf you need to bind a `POOL1` to processors 0-3 and `POOL2` to processors\n4-8, you'd set your configuration like this:\n\n```\n{\n  \"threadpool\": {\n    \"POOL1\": {\n      \"affinity\": { \"base\": 0, \"selector\": \"wid\" },\n      \"num_threads\": 4\n    },\n    \"POOL2\": {\n      \"affinity\": { \"base\": 4, \"selector\": \"wid\" },\n      \"num_threads\": 4\n    },\n  }\n}\n```\n\n### struct ph_job_def\n\n```c\nstruct ph_job_def {\n  \/\/ The callback to run when the job is dispatched.\n  \/\/ Will be copied to job->callback during ph_job_alloc()\n  ph_job_func_t callback;\n  \/\/ The memtype to use to allocate the job\n  ph_memtype_t memtype;\n  \/\/ Function to be called prior to freeing the job\n  void (*dtor)(ph_job_t *job);\n};\n```\n\n\n*Job definition*\n\n\nUse this to define a template for a job and then use ph_job_alloc() to allocate\nand safely dispose of the job via ph_job_free().  The template also allows you\nto pre-initialize the callback for the job.\n\n### struct ph_job\n\n```c\nstruct ph_job {\n  \/\/ data associated with job\n  void *data;\n  \/\/ the callback to run when the job is dispatched\n  ph_job_func_t callback;\n  \/\/ deferred apply list\n  PH_STAILQ_ENTRY(ph_job) q_ent;\n  \/\/ whether we're in a deferred apply\n  int in_apply;\n  \/\/ for PH_RUNCLASS_NBIO, trigger mask *\/\n  ph_iomask_t mask;\n  \/\/ use ph_job_get_kmask() to interpret\n  int kmask;\n  \/\/ Hashed over the scheduler threads; two jobs with\n  \/\/ the same emitter hash will run serially wrt. each other\n  uint32_t emitter_affinity;\n  \/\/ For nbio, the socket we're bound to for IO events\n  ph_socket_t fd;\n  \/\/ Holds timeout state\n  struct ph_timerwheel_timer timer;\n  \/\/ When targeting a thread pool, which pool\n  ph_thread_pool_t *pool;\n  \/\/ Counter of pending wakeups\n  uint32_t n_wakeups_pending;\n  \/\/ for SMR\n  ck_epoch_entry_t epoch_entry;\n  struct ph_job_def *def;\n};\n```\n\n\n*Job*\n\nUse either ph_job_alloc() to allocate and initialize, or allocate it yourself\nand use ph_job_init() to initialize the fields.\n\n### ph_job_init\n\n```c\nph_result_t ph_job_init(ph_job_t *job);\n```\n\n\n*Initializes a job structure.*\n\n\nWe allow for jobs to be embedded in a container structure.\nThis function correctly initializes the job.\n\n### ph_job_alloc\n\n```c\nph_job_t *ph_job_alloc(struct ph_job_def *def);\n```\n\n\n*Allocates a job structure using a template*\n\n\nA common case is to embed the job at the head of a struct and\nto manage that whole struct in a memtype based allocation.\n\nThis function will allocate and initialize a job using the\nprovided template; the template specifies a memtype to use for\nthe allocation (it must be a fixed size memtype) and a default value\nfor the callback function.\n\nWhen the job is no longer needed, you should call ph_job_free()\nto arrange for it to be freed during a grace period.\n\n### ph_job_free\n\n```c\nvoid ph_job_free(ph_job_t *job);\n```\n\n\n*Arranges to free a templated job structure*\n\n\nThe dtor from your job template will be invoked at a safe point.\nYou should treat the job as having been freed as soon as this\nfunction returns.\n\n### ph_job_set_nbio\n\n```c\nph_result_t ph_job_set_nbio(\n    ph_job_t *job,\n    ph_iomask_t mask,\n    struct timeval *abstime);\n```\n\n\n*Configure a job for NBIO.*\n\n\n### ph_job_set_nbio_timeout_in\n\n```c\nph_result_t ph_job_set_nbio_timeout_in(\n    ph_job_t *job,\n    ph_iomask_t mask,\n    struct timeval interval);\n```\n\n\n*Configure a job for NBIO with a relative timeout*\n\n\n### ph_job_get_kmask\n\n```c\nph_iomask_t ph_job_get_kmask(ph_job_t *job);\n```\n\n\n*Returns the currently active iomask*\n\n\nThis is useful in some situations where you want to know\nif the job is scheduled in the NBIO scheduler.\n\nThis API may change as it feels a bit klunky\n\n### ph_job_clear_timer\n\n```c\nph_result_t ph_job_clear_timer(ph_job_t *job);\n```\n\n\n*Clear a previously scheduled timer*\n\n\n### ph_job_dispatch_now\n\n```c\nvoid ph_job_dispatch_now(ph_job_t *job);\n```\n\n\n*Dispatch a job immediately in the current context*\n\n\n### ph_job_set_timer_at\n\n```c\nph_result_t ph_job_set_timer_at(\n    ph_job_t *job,\n    struct timeval abstime);\n```\n\n\n*Configure a job to run at a specific time*\n\n\n### ph_job_set_timer_in\n\n```c\nph_result_t ph_job_set_timer_in(\n    ph_job_t *job,\n    struct timeval interval);\n```\n\n\n*Configure a job to run after an interval*\n\n\n### ph_job_set_timer_in_ms\n\n```c\nph_result_t ph_job_set_timer_in_ms(\n    ph_job_t *job,\n    uint32_t interval);\n```\n\n\n*Configure a job to run after an interval expressed in milliseconds*\n\n\n### ph_job_set_pool\n\n```c\nph_result_t ph_job_set_pool(\n    ph_job_t *job,\n    ph_thread_pool_t *pool);\n```\n\n\n*Configure a job for pooled use and queue it to the*\n\npool.  It will be dispatched when the current dispatch\nframe is unwound.\n\n### ph_job_set_pool_immediate\n\n```c\nph_result_t ph_job_set_pool_immediate(ph_job_t *job,\n    ph_thread_pool_t *pool);\n```\n\n\n*Configure a job for pooled use and queue it to the*\n\npool.  It will be dispatched during or after the\nthe call to ph_job_set_pool_immediate returns.  Use\nwith caution as it is easy to experience race conditions\nwith the job finishing before you're done preparing for\nit to finish.\n\n### ph_thread_pool_define\n\n```c\nph_thread_pool_t *ph_thread_pool_define(\n    const char *name,\n    uint32_t max_queue_len,\n    uint32_t num_threads\n);\n```\n\n\n*Define a new job pool*\n\n\nThe pool is created in an offline state and will be brought\nonline when it is first assigned a job via ph_job_set_pool().\nmax_queue_len is used to size the producer ring buffers.  If\na ring buffer is full, this function will block until room\nbecomes available.\n\nmax_queue_len defines the upper bound on the number of items that can\nbe queued to the producer queue associated with the current\nthread.  There is no pool-wide maximum limit (it is too expensive\nto maintain and enforce), but there is a theoretical upper bound\nof MAX(4, ph_power_2(max_queue_len)) * 64 jobs that can be \"queued\",\nassuming that all 63 preferred threads and all the non-preferred\nthreads are busy saturating the pool.  On 32-bit systems, the multiplier\nis 32 instead of 64 and the preferred ring count is 31 instead of 63.\n\nNote that the actual values used for `max_queue_len` and `num_threads`\nwill be taken from the configuration values `$.threadpool.NAME.queue_len`\nand `$.threadpool.NAME.num_threads` respectively, where `NAME` is\nreplaced by the `name` parameter you specify.\n\n### ph_thread_pool_by_name\n\n```c\nph_thread_pool_t *ph_thread_pool_by_name(const char *name);\n```\n\n\n*Resolve a thread pool by name.*\n\nThis is O(number-of-pools); you should cache the result.\n\n### ph_thread_pool_signal_stop\n\n```c\nvoid ph_thread_pool_signal_stop(ph_thread_pool_t *pool);\n```\n\n\n*Signal that a thread pool should stop its workers*\n\n\nIn some workloads, we want to spawn a pool of threads to process\na bunch of jobs.  The number of jobs has a finite upper bound and\nonce they are all complete we no longer need to retain the pool.\n\nYou may use ph_thread_pool_signal_stop() to instruct the pool\nto shutdown and stop processing further items.  If you need\nto synchronize with the shutdown, you may use ph_thread_pool_wait_stop().\n\nIf all workers stop before consuming any pending jobs, then those\npending jobs will remain pending until the pool is re-enabled via\nph_thread_pool_start_workers().\n\n### ph_thread_pool_wait_stop\n\n```c\nvoid ph_thread_pool_wait_stop(ph_thread_pool_t *pool);\n```\n\n\n*Signal and wait for a thread pool to stop its workers*\n\n\nCalls ph_thread_pool_signal_stop() and then joins with all of the\nworker threads, returning only when the pool has no more remaining\nworkers.\n\nThis function blocks until there are no more workers.\n\nIt is undefined what will happen if you call ph_thread_pool_start_workers()\nbefore ph_thread_pool_wait_stop() completes.\n\n### ph_thread_pool_start_workers\n\n```c\nbool ph_thread_pool_start_workers(ph_thread_pool_t *pool);\n```\n\n\n*Cause a thread pool to spin up its workers*\n\n\nYou almost never need to call this function.  libPhenom will start all\ndefined thread pools as part of the initialization it performs in\nph_sched_run().\n\nThe only time that you might possibly need to call this function is if\nyou have called ph_thread_pool_wait_stop() and later want to restart\nthe pool and spin up its workers.\n\nIt is undefined what will happen if you call ph_thread_pool_start_workers()\nbefore ph_thread_pool_wait_stop() completes.\n\n### struct ph_thread_pool_stats\n\n```c\nstruct ph_thread_pool_stats {\n  \/\/ Number of jobs that have been dispatched\n  int64_t num_dispatched;\n  \/\/ How many times a worker thread has gone to sleep\n  int64_t consumer_sleeps;\n  \/\/ How many times a producer has been blocked by a full\n  \/\/ local ring buffer and gone to sleep\n  int64_t producer_sleeps;\n  \/\/ How many items are pending dispatch; includes items\n  \/\/ in the pool rings and threads attempting to enqueue\n  \/\/ to the pool\n  int64_t num_pending;\n};\n```\n\n\nThese are accumulated using ph_counter under the covers.\nThis means that the numbers are a snapshot across a number\nof per-thread views.\n\n### ph_thread_pool_stat\n\n```c\nvoid ph_thread_pool_stat(ph_thread_pool_t *pool,\n    struct ph_thread_pool_stats *stats);\n```\n\n\n*Return thread pool counters for a given pool*\n\n\n### ph_sched_run\n\n```c\nph_result_t ph_sched_run(void);\n```\n\n\n*Start the run loop.  Must be called from the main thread*\n\n\n### ph_sched_stop\n\n```c\nvoid ph_sched_stop(void);\n```\n\n\n*Requests that the run loop be halted.*\n\nCan be called from any thread. Once the scheduler is stopped, it cannot be restarted.\n\n### ph_nbio_queue_affine_func\n\n```c\nph_result_t ph_nbio_queue_affine_func(uint32_t emitter_affinity,\n    ph_nbio_affine_func func, intptr_t code, void *arg);\n```\n\n\n*Queue an affine function dispatch*\n\n\nArranges to call FUNC with the supplied CODE and ARG parameters.\nThe function will be called in the context of the emitter thread\nwith the specified emitter_affinity value.\n\nThis is useful in situations where you need to serialize the\nexecution of FUNC with respect to IO or timer based function\ndispatch.\n\nAffine functions are dispatched in FIFO order with respect\nto other affine functions for a given emitter, and are batched together\nbetween IO and timer dispatches for that emitter.\n\nNote: if your affine function is operating on a job that is scheduled for IO\nor timer callbacks, it is possible that that job will be dispatched for IO\nor timer callbacks between the time that your affine function is queued and\ndispatched.\n\nThe CODE and ARG parameters are passed through to your affine\nfunction callback; their use is entirely up to you.  Note that\nthe CODE parameter can hold an integer or a pointer value.\n\nShould you need to pass more than two parameters to the affine\nfunction, you will need to allocate storage to hold the information;\nif you do so, you must ensure that the storage is released at the\nappropriate time, as the affine function dispatcher does not\nknow how to release it for you.\n\nThe queue request can fail due to OOM conditions.\n\n### ph_job_wakeup\n\n```c\nph_result_t ph_job_wakeup(ph_job_t *job);\n```\n\n\n*Queue a request to dispatch the job with `PH_IOMASK_WAKEUP`*\n\n\nThe dispatch will happen as soon as the nbio emitter associated\nwith the job wakes up and processes the request.\n\nThe ph_job_wakeup request can fail due to OOM conditions or\nany condition that can cause ph_nbio_queue_affine_func() to fail.\n\nNote: it is possible that that job will be dispatched for\nIO or timer callbacks between the time that ph_job_wakeup() is\ncalled and when the `PH_IOMASK_WAKEUP` is dispatched.\n\n### ph_job_has_pending_wakeup\n\n```c\nbool ph_job_has_pending_wakeup(ph_job_t *job)\n```\n\n\n*Returns true if any wakeups are pending for this job*\n\n\n### ph_job_collector_register\n\n```c\nph_result_t ph_job_collector_register(ph_job_collector_func func);\n```\n\n\n*Register a worker collector callback*\n\n\nCertain workloads will benefit from aggressive caching or relaxed\ncleanup processing while the system is busy.  In order to provide\ntimely resource reclamation, an application may register one or\nmore collector callbacks.\n\nA collector callback is invoked by emitter threads in the NBIO\npool and worker threads in other thread pools when that thread\nreaches a quiescent state.  For NBIO threads, this is when a given\nemitter thread has not dispatched a job in the past `$.nbio.max_sleep`\nmilliseconds.  For worker threads, this is when a given thread waits\n`$.nbio.max_sleep` without being woken up.  These states are assessed\nper thread.  An idle system will trigger a collector once per thread\nevery `$.nbio.max_sleep` milliseconds while idle.\n\nThe collector callback is invoked in the context of the thread that\nis now quiescent and is passed the `ph_thread_t` for that thread.\n\nThe collector callback should ideally restrict itself to cleaning up data\nassociated with the current thread.\n\n### ph_nbio_init\n\n```c\nph_result_t ph_nbio_init(uint32_t sched_cores);\n```\n\n\n*Initialize the NBIO pool*\n\n\nThis MUST be called prior to setting any nbio jobs.\n`sched_cores` specifies how many threads should be used for\nNBIO.  Setting it to `0` selects a reasonable default based\non some experimentation of the core library.\n\nThe actual value used for sched_cores will be taken from\nthe configuration for `$.nbio.sched_cores`, if present,\notherwise your sched_cores parameter will be used.\n\nOther applicable parameters:\n\n`$.nbio.epoch_interval` specifies how often we'll schedule a\ncall to ph_thread_epoch_barrier().  The configuration is specified\nin milliseconds.  If you enabled Gimli support, libphenom will\nupdate the heartbeat after performing the barrier.  This ensures\nthat all worker threads are healthy and making progress.\nThe default value for this is `5000` milliseconds; it should be\nmore frequent than your Gimli watchdog interval.  You may disable\nbarrier and heartbeat by setting this option to `0`.\n\n`$.nbio.max_sleep` specifies the maximum duration that an nbio\nor worker thread will be idle.  The default value for this is\n`5000` milliseconds.  This is important when it comes to handling\ndeferred memory reclamation; after the max sleep expires, and if\nno events are due, the worker will call ph_thread_epoch_poll()\nto speculatively reclaim memory.\n",
        "decl_titles": [
            "struct ph_job_def",
            "struct ph_job",
            "ph_job_init",
            "ph_job_alloc",
            "ph_job_free",
            "ph_job_set_nbio",
            "ph_job_set_nbio_timeout_in",
            "ph_job_get_kmask",
            "ph_job_clear_timer",
            "ph_job_dispatch_now",
            "ph_job_set_timer_at",
            "ph_job_set_timer_in",
            "ph_job_set_timer_in_ms",
            "ph_job_set_pool",
            "ph_job_set_pool_immediate",
            "ph_thread_pool_define",
            "ph_thread_pool_by_name",
            "ph_thread_pool_signal_stop",
            "ph_thread_pool_wait_stop",
            "ph_thread_pool_start_workers",
            "struct ph_thread_pool_stats",
            "ph_thread_pool_stat",
            "ph_sched_run",
            "ph_sched_stop",
            "ph_nbio_queue_affine_func",
            "ph_job_wakeup",
            "ph_job_has_pending_wakeup",
            "ph_job_collector_register",
            "ph_nbio_init"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_JOB_H\n#define PHENOM_JOB_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/thread.h&quot;\n#include &quot;phenom\/timerwheel.h&quot;\n#include &quot;phenom\/queue.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/**\n * # Jobs\n * Jobs describe a parcel of work.  Jobs may be triggered or dispatched\n * in one of a number of &quot;run classes&quot;.  There are three run classes:\n *\n * - Immediate. The work is dispatched immediately on the calling thread.\n * - NBIO. The work is dispatched when a descriptor is signalled for I\/O.\n * - Pool. The work is queued to a thread pool and is dispatched as soon as a\n *   worker becomes available.  libPhenom allows multiple pools to be defined to\n *   better partition and prioritize your workload.\n *\n * # Affinity\n *\n * By default, threads created by ph_thread_pool_define() and threads in the\n * NBIO pool use an affinity policy that spreads out the threads and binds\n * them to the CPU cores based on their phenom `tid`.\n *\n * Each thread with a phenom TLS segment is assigned a `tid` starting with 0\n * for the main thread of the process, increasing by 1 for each additional\n * thread.\n *\n * Each thread in a thread pool has a `wid` starting at 1 for the &quot;first&quot;\n * thread in that pool, increasing by 1 for each additional thread.\n *\n * The default affinity selector is based on the `tid` such that a process\n * that uses libphenom exclusively for its threads maps each thread across\n * the set of CPU cores.\n *\n * In more complex environments, there may be threads created by other\n * libraries and the overall affinity configuration is made more complex.\n * To cater for this, you may specify the affinity selection in your phenom\n * configuration file.\n *\n * For the NBIO pool:\n *\n * ```\n * {\n *   &quot;nbio&quot;: {\n *     &quot;affinity&quot;: {\n *       &quot;base&quot;: 0,\n *       &quot;selector&quot;: &quot;tid&quot;\n *     }\n *   }\n * }\n * ```\n *\n * For any other thread pool, for example, the &quot;MYNAME&quot; pool:\n *\n * ```\n * {\n *   &quot;threadpool&quot;: {\n *     &quot;MYNAME&quot;: {\n *       &quot;affinity&quot;: {\n *         &quot;base&quot;: 0,\n *         &quot;selector&quot;: &quot;tid&quot;\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The `base` parameter specifies the offset of the first CPU to bind.\n * The default is CPU `0`.\n *\n * Possible values for `selector` are:\n *\n * * `tid` - binds to `(base + thr-&gt;tid) % cores`\n * * `wid` - binds to `(base + thr-&gt;wid - 1) % cores`\n * * `none` - does not set CPU affinity\n * * `[1,2,3]` allows the thread to bind to any CPU in the set\n *   `[base + 1, base + 2, base + 3]`.  This specifies an affinity mask, so all\n *   of the threads in this pool will be able to run on any of the CPUs in the\n *   specified set.  libPhenom currently only supports this form on Linux and\n *   BSDish systems; other platforms will bind to the first CPU in the set.\n * * `2` - binds to CPU `base + 2`.  This causes all threads in the pool to\n *   bind to the specified CPU.\n *\n * If you need to bind a `POOL1` to processors 0-3 and `POOL2` to processors\n * 4-8, you&#039;d set your configuration like this:\n *\n * ```\n * {\n *   &quot;threadpool&quot;: {\n *     &quot;POOL1&quot;: {\n *       &quot;affinity&quot;: { &quot;base&quot;: 0, &quot;selector&quot;: &quot;wid&quot; },\n *       &quot;num_threads&quot;: 4\n *     },\n *     &quot;POOL2&quot;: {\n *       &quot;affinity&quot;: { &quot;base&quot;: 4, &quot;selector&quot;: &quot;wid&quot; },\n *       &quot;num_threads&quot;: 4\n *     },\n *   }\n * }\n * ```\n *\/\n\n\/* NBIO trigger mask *\/\ntypedef uint8_t ph_iomask_t;\n\/* NBIO is disabled or not applicable *\/\n#define PH_IOMASK_NONE  0\n\/* NBIO will\/did dispatch for readable events *\/\n#define PH_IOMASK_READ  1\n\/* NBIO will\/did dispatch for writable events *\/\n#define PH_IOMASK_WRITE 2\n\/* NBIO dispatched due to IO error *\/\n#define PH_IOMASK_ERR   4\n\/* NBIO did not dispatch before timeout was met *\/\n#define PH_IOMASK_TIME  8\n\/* Dispatch triggered by ph_job_wakeup *\/\n#define PH_IOMASK_WAKEUP 16\n\nstruct ph_job;\ntypedef struct ph_job ph_job_t;\n\ntypedef void (*ph_job_func_t)(\n    ph_job_t *job,\n    ph_iomask_t why,\n    void *data\n);\n\n\/** Job definition\n *\n * Use this to define a template for a job and then use ph_job_alloc() to allocate\n * and safely dispose of the job via ph_job_free().  The template also allows you\n * to pre-initialize the callback for the job.\n *\/\nstruct ph_job_def {\n  \/\/ The callback to run when the job is dispatched.\n  \/\/ Will be copied to job-&gt;callback during ph_job_alloc()\n  ph_job_func_t callback;\n  \/\/ The memtype to use to allocate the job\n  ph_memtype_t memtype;\n  \/\/ Function to be called prior to freeing the job\n  void (*dtor)(ph_job_t *job);\n};\n\n\/** Job\n * Use either ph_job_alloc() to allocate and initialize, or allocate it yourself\n * and use ph_job_init() to initialize the fields.\n *\/\nstruct ph_job {\n  \/\/ data associated with job\n  void *data;\n  \/\/ the callback to run when the job is dispatched\n  ph_job_func_t callback;\n  \/\/ deferred apply list\n  PH_STAILQ_ENTRY(ph_job) q_ent;\n  \/\/ whether we&#039;re in a deferred apply\n  int in_apply;\n  \/\/ for PH_RUNCLASS_NBIO, trigger mask *\/\n  ph_iomask_t mask;\n  \/\/ use ph_job_get_kmask() to interpret\n  int kmask;\n  \/\/ Hashed over the scheduler threads; two jobs with\n  \/\/ the same emitter hash will run serially wrt. each other\n  uint32_t emitter_affinity;\n  \/\/ For nbio, the socket we&#039;re bound to for IO events\n  ph_socket_t fd;\n  \/\/ Holds timeout state\n  struct ph_timerwheel_timer timer;\n  \/\/ When targeting a thread pool, which pool\n  ph_thread_pool_t *pool;\n  \/\/ Counter of pending wakeups\n  uint32_t n_wakeups_pending;\n  \/\/ for SMR\n  ck_epoch_entry_t epoch_entry;\n  struct ph_job_def *def;\n};\n\n\/** Initializes a job structure.\n *\n * We allow for jobs to be embedded in a container structure.\n * This function correctly initializes the job.\n *\/\nph_result_t ph_job_init(ph_job_t *job);\n\n\/** Allocates a job structure using a template\n *\n * A common case is to embed the job at the head of a struct and\n * to manage that whole struct in a memtype based allocation.\n *\n * This function will allocate and initialize a job using the\n * provided template; the template specifies a memtype to use for\n * the allocation (it must be a fixed size memtype) and a default value\n * for the callback function.\n *\n * When the job is no longer needed, you should call ph_job_free()\n * to arrange for it to be freed during a grace period.\n *\/\nph_job_t *ph_job_alloc(struct ph_job_def *def);\n\n\/** Arranges to free a templated job structure\n *\n * The dtor from your job template will be invoked at a safe point.\n * You should treat the job as having been freed as soon as this\n * function returns.\n *\/\nvoid ph_job_free(ph_job_t *job);\n\n\/** Configure a job for NBIO.\n *\/\nph_result_t ph_job_set_nbio(\n    ph_job_t *job,\n    ph_iomask_t mask,\n    struct timeval *abstime);\n\n\/** Configure a job for NBIO with a relative timeout *\/\nph_result_t ph_job_set_nbio_timeout_in(\n    ph_job_t *job,\n    ph_iomask_t mask,\n    struct timeval interval);\n\n\/** Returns the currently active iomask\n *\n * This is useful in some situations where you want to know\n * if the job is scheduled in the NBIO scheduler.\n *\n * This API may change as it feels a bit klunky\n *\/\nph_iomask_t ph_job_get_kmask(ph_job_t *job);\n\n\/** Clear a previously scheduled timer\n *\/\nph_result_t ph_job_clear_timer(ph_job_t *job);\n\n\/** Dispatch a job immediately in the current context\n *\/\nvoid ph_job_dispatch_now(ph_job_t *job);\n\n\/** Configure a job to run at a specific time *\/\nph_result_t ph_job_set_timer_at(\n    ph_job_t *job,\n    struct timeval abstime);\n\n\/** Configure a job to run after an interval *\/\nph_result_t ph_job_set_timer_in(\n    ph_job_t *job,\n    struct timeval interval);\n\n\/** Configure a job to run after an interval expressed in milliseconds *\/\nph_result_t ph_job_set_timer_in_ms(\n    ph_job_t *job,\n    uint32_t interval);\n\n\/** Configure a job for pooled use and queue it to the\n * pool.  It will be dispatched when the current dispatch\n * frame is unwound.\n *\/\nph_result_t ph_job_set_pool(\n    ph_job_t *job,\n    ph_thread_pool_t *pool);\n\n\/** Configure a job for pooled use and queue it to the\n * pool.  It will be dispatched during or after the\n * the call to ph_job_set_pool_immediate returns.  Use\n * with caution as it is easy to experience race conditions\n * with the job finishing before you&#039;re done preparing for\n * it to finish.\n *\/\nph_result_t ph_job_set_pool_immediate(ph_job_t *job,\n    ph_thread_pool_t *pool);\n\n\/** Define a new job pool\n *\n * The pool is created in an offline state and will be brought\n * online when it is first assigned a job via ph_job_set_pool().\n * max_queue_len is used to size the producer ring buffers.  If\n * a ring buffer is full, this function will block until room\n * becomes available.\n *\n * max_queue_len defines the upper bound on the number of items that can\n * be queued to the producer queue associated with the current\n * thread.  There is no pool-wide maximum limit (it is too expensive\n * to maintain and enforce), but there is a theoretical upper bound\n * of MAX(4, ph_power_2(max_queue_len)) * 64 jobs that can be &quot;queued&quot;,\n * assuming that all 63 preferred threads and all the non-preferred\n * threads are busy saturating the pool.  On 32-bit systems, the multiplier\n * is 32 instead of 64 and the preferred ring count is 31 instead of 63.\n *\n * Note that the actual values used for `max_queue_len` and `num_threads`\n * will be taken from the configuration values `$.threadpool.NAME.queue_len`\n * and `$.threadpool.NAME.num_threads` respectively, where `NAME` is\n * replaced by the `name` parameter you specify.\n *\/\nph_thread_pool_t *ph_thread_pool_define(\n    const char *name,\n    uint32_t max_queue_len,\n    uint32_t num_threads\n);\n\n\/** Resolve a thread pool by name.\n * This is O(number-of-pools); you should cache the result.\n *\/\nph_thread_pool_t *ph_thread_pool_by_name(const char *name);\n\n\/** Signal that a thread pool should stop its workers\n *\n * In some workloads, we want to spawn a pool of threads to process\n * a bunch of jobs.  The number of jobs has a finite upper bound and\n * once they are all complete we no longer need to retain the pool.\n *\n * You may use ph_thread_pool_signal_stop() to instruct the pool\n * to shutdown and stop processing further items.  If you need\n * to synchronize with the shutdown, you may use ph_thread_pool_wait_stop().\n *\n * If all workers stop before consuming any pending jobs, then those\n * pending jobs will remain pending until the pool is re-enabled via\n * ph_thread_pool_start_workers().\n *\/\nvoid ph_thread_pool_signal_stop(ph_thread_pool_t *pool);\n\n\/** Signal and wait for a thread pool to stop its workers\n *\n * Calls ph_thread_pool_signal_stop() and then joins with all of the\n * worker threads, returning only when the pool has no more remaining\n * workers.\n *\n * This function blocks until there are no more workers.\n *\n * It is undefined what will happen if you call ph_thread_pool_start_workers()\n * before ph_thread_pool_wait_stop() completes.\n *\/\nvoid ph_thread_pool_wait_stop(ph_thread_pool_t *pool);\n\n\/** Cause a thread pool to spin up its workers\n *\n * You almost never need to call this function.  libPhenom will start all\n * defined thread pools as part of the initialization it performs in\n * ph_sched_run().\n *\n * The only time that you might possibly need to call this function is if\n * you have called ph_thread_pool_wait_stop() and later want to restart\n * the pool and spin up its workers.\n *\n * It is undefined what will happen if you call ph_thread_pool_start_workers()\n * before ph_thread_pool_wait_stop() completes.\n *\/\nbool ph_thread_pool_start_workers(ph_thread_pool_t *pool);\n\n\/**\n * These are accumulated using ph_counter under the covers.\n * This means that the numbers are a snapshot across a number\n * of per-thread views.\n *\/\nstruct ph_thread_pool_stats {\n  \/\/ Number of jobs that have been dispatched\n  int64_t num_dispatched;\n  \/\/ How many times a worker thread has gone to sleep\n  int64_t consumer_sleeps;\n  \/\/ How many times a producer has been blocked by a full\n  \/\/ local ring buffer and gone to sleep\n  int64_t producer_sleeps;\n  \/\/ How many items are pending dispatch; includes items\n  \/\/ in the pool rings and threads attempting to enqueue\n  \/\/ to the pool\n  int64_t num_pending;\n};\n\n\/** Return thread pool counters for a given pool *\/\nvoid ph_thread_pool_stat(ph_thread_pool_t *pool,\n    struct ph_thread_pool_stats *stats);\n\n\/* io scheduler thread pool stats *\/\nstruct ph_nbio_stats {\n  \/* how many threads are servicing NBIO *\/\n  int num_threads;\n  \/* how many NBIO dispatches have happened *\/\n  int64_t num_dispatched;\n  \/* how many timer ticks since process start (~1 every 100ms) *\/\n  int64_t timer_ticks;\n  \/* how many timer vs. event dispatch conflicts were detected,\n   * should be rare *\/\n  int64_t timer_busy;\n};\n\nvoid ph_nbio_stat(struct ph_nbio_stats *stats);\n\n\/** Start the run loop.  Must be called from the main thread *\/\nph_result_t ph_sched_run(void);\n\n\/** Requests that the run loop be halted.\n * Can be called from any thread. Once the scheduler is stopped, it cannot be restarted. *\/\nvoid ph_sched_stop(void);\n\ntypedef void (*ph_nbio_affine_func)(intptr_t code, void *arg);\n\n\/** Queue an affine function dispatch\n *\n * Arranges to call FUNC with the supplied CODE and ARG parameters.\n * The function will be called in the context of the emitter thread\n * with the specified emitter_affinity value.\n *\n * This is useful in situations where you need to serialize the\n * execution of FUNC with respect to IO or timer based function\n * dispatch.\n *\n * Affine functions are dispatched in FIFO order with respect\n * to other affine functions for a given emitter, and are batched together\n * between IO and timer dispatches for that emitter.\n *\n * Note: if your affine function is operating on a job that is scheduled for IO\n * or timer callbacks, it is possible that that job will be dispatched for IO\n * or timer callbacks between the time that your affine function is queued and\n * dispatched.\n *\n * The CODE and ARG parameters are passed through to your affine\n * function callback; their use is entirely up to you.  Note that\n * the CODE parameter can hold an integer or a pointer value.\n *\n * Should you need to pass more than two parameters to the affine\n * function, you will need to allocate storage to hold the information;\n * if you do so, you must ensure that the storage is released at the\n * appropriate time, as the affine function dispatcher does not\n * know how to release it for you.\n *\n * The queue request can fail due to OOM conditions.\n *\/\nph_result_t ph_nbio_queue_affine_func(uint32_t emitter_affinity,\n    ph_nbio_affine_func func, intptr_t code, void *arg);\n\n\/** Queue a request to dispatch the job with `PH_IOMASK_WAKEUP`\n *\n * The dispatch will happen as soon as the nbio emitter associated\n * with the job wakes up and processes the request.\n *\n * The ph_job_wakeup request can fail due to OOM conditions or\n * any condition that can cause ph_nbio_queue_affine_func() to fail.\n *\n * Note: it is possible that that job will be dispatched for\n * IO or timer callbacks between the time that ph_job_wakeup() is\n * called and when the `PH_IOMASK_WAKEUP` is dispatched.\n *\/\nph_result_t ph_job_wakeup(ph_job_t *job);\n\n\/** Returns true if any wakeups are pending for this job *\/\nstatic inline bool ph_job_has_pending_wakeup(ph_job_t *job) {\n  return ck_pr_load_32(&amp;job-&gt;n_wakeups_pending) &gt; 0;\n}\n\ntypedef void (*ph_job_collector_func)(ph_thread_t *me);\n\n\/** Register a worker collector callback\n *\n * Certain workloads will benefit from aggressive caching or relaxed\n * cleanup processing while the system is busy.  In order to provide\n * timely resource reclamation, an application may register one or\n * more collector callbacks.\n *\n * A collector callback is invoked by emitter threads in the NBIO\n * pool and worker threads in other thread pools when that thread\n * reaches a quiescent state.  For NBIO threads, this is when a given\n * emitter thread has not dispatched a job in the past `$.nbio.max_sleep`\n * milliseconds.  For worker threads, this is when a given thread waits\n * `$.nbio.max_sleep` without being woken up.  These states are assessed\n * per thread.  An idle system will trigger a collector once per thread\n * every `$.nbio.max_sleep` milliseconds while idle.\n *\n * The collector callback is invoked in the context of the thread that\n * is now quiescent and is passed the `ph_thread_t` for that thread.\n *\n * The collector callback should ideally restrict itself to cleaning up data\n * associated with the current thread.\n *\/\nph_result_t ph_job_collector_register(ph_job_collector_func func);\n\n\/* ----\n * the following are implementation specific and shouldn&#039;t\n * be called except by wizards\n *\/\nvoid ph_job_pool_shutdown(void);\nvoid ph_job_pool_apply_deferred_items(ph_thread_t *me);\n\n\/** Initialize the NBIO pool\n *\n * This MUST be called prior to setting any nbio jobs.\n * `sched_cores` specifies how many threads should be used for\n * NBIO.  Setting it to `0` selects a reasonable default based\n * on some experimentation of the core library.\n *\n * The actual value used for sched_cores will be taken from\n * the configuration for `$.nbio.sched_cores`, if present,\n * otherwise your sched_cores parameter will be used.\n *\n * Other applicable parameters:\n *\n * `$.nbio.epoch_interval` specifies how often we&#039;ll schedule a\n * call to ph_thread_epoch_barrier().  The configuration is specified\n * in milliseconds.  If you enabled Gimli support, libphenom will\n * update the heartbeat after performing the barrier.  This ensures\n * that all worker threads are healthy and making progress.\n * The default value for this is `5000` milliseconds; it should be\n * more frequent than your Gimli watchdog interval.  You may disable\n * barrier and heartbeat by setting this option to `0`.\n *\n * `$.nbio.max_sleep` specifies the maximum duration that an nbio\n * or worker thread will be idle.  The default value for this is\n * `5000` milliseconds.  This is important when it comes to handling\n * deferred memory reclamation; after the max sleep expires, and if\n * no events are due, the worker will call ph_thread_epoch_poll()\n * to speculatively reclaim memory.\n *\/\nph_result_t ph_nbio_init(uint32_t sched_cores);\n\nvoid _ph_job_set_pool_immediate(ph_job_t *job, ph_thread_t *me);\nvoid _ph_job_pool_start_threads(void);\n\nstatic inline bool ph_job_have_deferred_items(ph_thread_t *me)\n{\n  return PH_STAILQ_FIRST(&amp;me-&gt;pending_nbio) ||\n         PH_STAILQ_FIRST(&amp;me-&gt;pending_pool);\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "json": {
        "name": "json",
        "title": "json",
        "content": "\n# JSON Support\n\nlibPhenom provides JSON encoding and decoding support functions.\nThese are implemented in terms of the variant datatype; you\nmay encode from a variant to JSON and vice-versa.\n\n## Loading and decoding JSON\n\nThis is accomplished using ph_json_load_stream(), ph_json_load_string()\nor ph_json_load_cstr().\n\nYou may specify one or more of the following flags to alter the load\nbehavior:\n\n* `PH_JSON_REJECT_DUPLICATES` - fail to decode if objects contain\n  more than one copy of the same key.\n* `PH_JSON_DECODE_ANY` - the loader will normally only successfully\n  complete if the JSON represents either an array or an object.\n  Setting this flag allows any JSON value to be loaded.\n* `PH_JSON_DISABLE_EOF_CHECK` - the loader will normally look ahead\n  and expect to see EOF after it has successfully decoded a JSON value.\n  If EOF is not found, the decode will fail on the basis that there is\n  trailing garbage so the input is probably invalid.  Specifying this\n  flag will disable the EOF check.\n  If used together with `PH_JSON_DECODE_ANY`, the decoder may read\n  one extra code point (up to 4 bytes of input); for example, if the\n  input is `4true` the decoder correctly decodes `4` but also reads the\n  `t` character.  It is recommended that you separate such values by\n  whitespace if you are reading multiple consecutive non array, non object\n  values.\n\n### Handling load errors\n\nThe load functions allow you to specify an optional *error* parameter.\nIf present, it will be updated to hold some error context that you can\npresent to the user.\n\nIt has the following fields:\n\n* `line` - the line number of the problematic sequence\n* `column` - the offset within the line measured in code points\n* `position` - the byte offset within the JSON stream\n* `text` - a human readable error message explaining the problem\n* `transient` - if true, indicates that retrying later might yield success\n\nIf the load operation was successful, the `position` field is updated to\nhold the number of bytes consumed from the input.  This is useful in\nconjunction with `PH_JSON_DISABLE_EOF_CHECK` to read multiple consecutive\nJSON values.\n\n## Dumping and encoding JSON\n\nThis is accomplished using ph_json_dump_stream() or ph_json_dump_string().\n\nYou may specify one or more of the following flags to alter the dump\nbehavior:\n\n* `PH_JSON_INDENT(n)` - The default representation is a single line of\n  JSON text.  Using `PH_JSON_INDENT(2)` will use a two-space indentation\n  for objects and arrays, pretty-printing the output.\n* `PH_JSON_COMPACT` - when set, suppresses some spaces and makes the\n  output more compact and less human readable.\n* `PH_JSON_ENSURE_ASCII` - when set, causes the output to be restricted\n  to 7-bit ASCII characters, escaping any characters outside this range.\n* `PH_JSON_SORT_KEYS` - when set, object values are walked in a sorted\n  order.  This is more expensive but is useful for textual comparisons.\n* `PH_JSON_ESCAPE_SLASH` - escapes the `\/` character in strings, which\n  is useful in cases where the JSON will be embedded in e.g. HTML output.\n\n### ph_json_load_stream\n\n```c\nph_variant_t *ph_json_load_stream(ph_stream_t *stm, uint32_t flags,\n    ph_var_err_t *err);\n```\n\n\n*Parse JSON from a stream*\n\n\nAttempt to parse and decode a JSON encoded data stream.\nReturns a variant instance if successful.\nOn failure, updates the provided `err` pointer to contain\nsome context on the failure.\n\n### ph_json_load_string\n\n```c\nph_variant_t *ph_json_load_string(ph_string_t *str, uint32_t flags,\n    ph_var_err_t *err);\n```\n\n\n*Parse JSON from a string*\n\n\nAttempt to parse and decode a JSON encoded string.\nReturns a variant instance if successful.\nOn failure, updates the provided `err` pointer to contain\nsome context on the failure.\n\n### ph_json_load_cstr\n\n```c\nph_variant_t *ph_json_load_cstr(const char *cstr, uint32_t flags,\n    ph_var_err_t *err);\n```\n\n\n*Parse JSON from a C-string*\n\n\n### ph_json_dump_stream\n\n```c\nph_result_t ph_json_dump_stream(ph_variant_t *obj,\n    ph_stream_t *stm, uint32_t flags);\n```\n\n\n*Encode a variant as JSON, write to stream*\n\n\nGiven a variant, encodes it as JSON and writes to the provided\nstream.\n\n### ph_json_dump_string\n\n```c\nph_result_t ph_json_dump_string(ph_variant_t *var,\n    ph_string_t *str, uint32_t flags);\n```\n\n\n*Encode a variant as JSON, append to string*\n\n\nGiven a variant, encodes it as JSON and appends to the provided\nstring.\n",
        "decl_titles": [
            "ph_json_load_stream",
            "ph_json_load_string",
            "ph_json_load_cstr",
            "ph_json_dump_stream",
            "ph_json_dump_string"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_JSON_H\n#define PHENOM_JSON_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/stream.h&quot;\n#include &quot;phenom\/variant.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/**\n * # JSON Support\n *\n * libPhenom provides JSON encoding and decoding support functions.\n * These are implemented in terms of the variant datatype; you\n * may encode from a variant to JSON and vice-versa.\n *\n * ## Loading and decoding JSON\n *\n * This is accomplished using ph_json_load_stream(), ph_json_load_string()\n * or ph_json_load_cstr().\n *\n * You may specify one or more of the following flags to alter the load\n * behavior:\n *\n * * `PH_JSON_REJECT_DUPLICATES` - fail to decode if objects contain\n *   more than one copy of the same key.\n * * `PH_JSON_DECODE_ANY` - the loader will normally only successfully\n *   complete if the JSON represents either an array or an object.\n *   Setting this flag allows any JSON value to be loaded.\n * * `PH_JSON_DISABLE_EOF_CHECK` - the loader will normally look ahead\n *   and expect to see EOF after it has successfully decoded a JSON value.\n *   If EOF is not found, the decode will fail on the basis that there is\n *   trailing garbage so the input is probably invalid.  Specifying this\n *   flag will disable the EOF check.\n *   If used together with `PH_JSON_DECODE_ANY`, the decoder may read\n *   one extra code point (up to 4 bytes of input); for example, if the\n *   input is `4true` the decoder correctly decodes `4` but also reads the\n *   `t` character.  It is recommended that you separate such values by\n *   whitespace if you are reading multiple consecutive non array, non object\n *   values.\n *\n * ### Handling load errors\n *\n * The load functions allow you to specify an optional *error* parameter.\n * If present, it will be updated to hold some error context that you can\n * present to the user.\n *\n * It has the following fields:\n *\n * * `line` - the line number of the problematic sequence\n * * `column` - the offset within the line measured in code points\n * * `position` - the byte offset within the JSON stream\n * * `text` - a human readable error message explaining the problem\n * * `transient` - if true, indicates that retrying later might yield success\n *\n * If the load operation was successful, the `position` field is updated to\n * hold the number of bytes consumed from the input.  This is useful in\n * conjunction with `PH_JSON_DISABLE_EOF_CHECK` to read multiple consecutive\n * JSON values.\n *\n * ## Dumping and encoding JSON\n *\n * This is accomplished using ph_json_dump_stream() or ph_json_dump_string().\n *\n * You may specify one or more of the following flags to alter the dump\n * behavior:\n *\n * * `PH_JSON_INDENT(n)` - The default representation is a single line of\n *   JSON text.  Using `PH_JSON_INDENT(2)` will use a two-space indentation\n *   for objects and arrays, pretty-printing the output.\n * * `PH_JSON_COMPACT` - when set, suppresses some spaces and makes the\n *   output more compact and less human readable.\n * * `PH_JSON_ENSURE_ASCII` - when set, causes the output to be restricted\n *   to 7-bit ASCII characters, escaping any characters outside this range.\n * * `PH_JSON_SORT_KEYS` - when set, object values are walked in a sorted\n *   order.  This is more expensive but is useful for textual comparisons.\n * * `PH_JSON_ESCAPE_SLASH` - escapes the `\/` character in strings, which\n *   is useful in cases where the JSON will be embedded in e.g. HTML output.\n *\/\n\n\n#define PH_JSON_REJECT_DUPLICATES 0x1\n#define PH_JSON_DISABLE_EOF_CHECK 0x2\n#define PH_JSON_DECODE_ANY        0x4\n\n#define PH_JSON_INDENT(n)      (n &amp; 0x1F)\n#define PH_JSON_COMPACT        0x20\n#define PH_JSON_ENSURE_ASCII   0x40\n#define PH_JSON_SORT_KEYS      0x80\n#define PH_JSON_ESCAPE_SLASH   0x100\n\n\/** Parse JSON from a stream\n *\n * Attempt to parse and decode a JSON encoded data stream.\n * Returns a variant instance if successful.\n * On failure, updates the provided `err` pointer to contain\n * some context on the failure.\n *\/\nph_variant_t *ph_json_load_stream(ph_stream_t *stm, uint32_t flags,\n    ph_var_err_t *err);\n\n\/** Parse JSON from a string\n *\n * Attempt to parse and decode a JSON encoded string.\n * Returns a variant instance if successful.\n * On failure, updates the provided `err` pointer to contain\n * some context on the failure.\n *\/\nph_variant_t *ph_json_load_string(ph_string_t *str, uint32_t flags,\n    ph_var_err_t *err);\n\n\/** Parse JSON from a C-string\n *\/\nph_variant_t *ph_json_load_cstr(const char *cstr, uint32_t flags,\n    ph_var_err_t *err);\n\n\/** Encode a variant as JSON, write to stream\n *\n * Given a variant, encodes it as JSON and writes to the provided\n * stream.\n *\/\nph_result_t ph_json_dump_stream(ph_variant_t *obj,\n    ph_stream_t *stm, uint32_t flags);\n\n\/** Encode a variant as JSON, append to string\n *\n * Given a variant, encodes it as JSON and appends to the provided\n * string.\n *\/\nph_result_t ph_json_dump_string(ph_variant_t *var,\n    ph_string_t *str, uint32_t flags);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "listener": {
        "name": "listener",
        "title": "listener",
        "content": "\n### ph_listener_new\n\n```c\nph_listener_t *ph_listener_new(const char *name,\n    ph_listener_accept_func acceptor);\n```\n\n\n*Create a new listener*\n\n\n### ph_listener_bind\n\n```c\nph_result_t ph_listener_bind(ph_listener_t *lstn, const ph_sockaddr_t *addr);\n```\n\n\n*Bind a listener to a local address*\n\n\nIf no socket has been associated, associates one prior to calling bind(),\nand enables address\/port reuse socket options\n\n### ph_listener_get_fd\n\n```c\nph_socket_t ph_listener_get_fd(ph_listener_t *lstn);\n```\n\n\n*Returns the underlying socket descriptor for a listener*\n\n\n### ph_listener_set_backlog\n\n```c\nvoid ph_listener_set_backlog(ph_listener_t *lstn, int backlog);\n```\n\n\n*Set the listen backlog.*\n\n\nIf `backlog` is <= 0, attempts to determine the current kernel setting\nfor the `somaxconn` system parameter and uses that, otherwise falls back\nto the `SOMAXCONN` value from your system header, or if that is undefined,\nuses the value `128`.\n\n### ph_listener_enable\n\n```c\nvoid ph_listener_enable(ph_listener_t *lstn, bool enable);\n```\n\n\n*Enable\/Disable the listener*\n\n\nWhen enabled for the first time, calls listen(2) with the backlog that you\nset.  If you have not set a backlog, a default value will be computed per\nthe description in ph_listener_set_backlog().\n\nWhile enabled, the acceptor function will be invoked from any NBIO thread\neach time a client connection is accepted.\n\n### ph_listener_set_acceptor_data\n\n```c\nvoid ph_listener_set_acceptor_data(ph_listener_t *lstn, void *data);\n```\n\n\n*Set the acceptor data for the listener*\n\n\nThis allows data to be passed from the function that calls\nph_listener_new() to the accept callback function.\n\n```\nstatic void handle_recv(ph_sock_t *sock, ph_iomask_t why, void *arg) {\n  struct path *paths = arg;\n  \/\/ handle the request with the list of paths...\n}\n\nstatic void handle_accept(ph_listener_t *lstn, ph_sock_t* sock)\n{\n  struct path *paths = ph_listener_get_acceptor_data(lstn);\n  sock->job.data = paths;\n  sock->callback = handle_recv;\n  ph_log(PH_LOG_INFO, \"accepted `P{sockaddr:%p}\", (void*)&sock->peername);\n  ph_sock_enable(sock, true);\n}\n\nvoid http_start(char *name, char *address, uint32_t port, struct path *paths)\n{\n  ph_listener_t *listener = ph_listener_new(name, handle_accept);\n  ph_listener_set_acceptor_data(listener, routes);\n  \/\/ bind and enable listener...\n}\n```\n\n### ph_listener_get_acceptor_data\n\n```c\nvoid *ph_listener_get_acceptor_data(ph_listener_t *lstn);\n```\n\n\n*Get the acceptor data for the listener*\n\n",
        "decl_titles": [
            "ph_listener_new",
            "ph_listener_bind",
            "ph_listener_get_fd",
            "ph_listener_set_backlog",
            "ph_listener_enable",
            "ph_listener_set_acceptor_data",
            "ph_listener_get_acceptor_data"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_LISTENER_H\n#define PHENOM_LISTENER_H\n\n#include &quot;phenom\/socket.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_listener;\ntypedef struct ph_listener ph_listener_t;\n\ntypedef void (*ph_listener_accept_func)(\n    ph_listener_t *listener, ph_sock_t *sock);\n\nstruct ph_listener {\n  \/\/ Embedded job so we can participate in NBIO\n  ph_job_t job;\n\n  \/\/ When accepting, we default to setting the next\n  \/\/ emitter in a round robin fashion.  This holds\n  \/\/ our state\n  uint32_t emitter_affinity;\n\n  \/\/ Local address (to which we are bound)\n  ph_sockaddr_t addr;\n\n  \/\/ `PH_SOCK_CLOEXEC`, `PH_SOCK_NONBLOCK`\n  int flags;\n\n  bool enabled;\n  bool listening;\n\n  \/\/ Desired backlog\n  int backlog;\n\n  \/\/ Called as new connections are accepted\n  ph_listener_accept_func acceptor;\n\n  \/\/ Name: used for accounting\n  char name[64];\n\n  \/\/ data associated with the listener.\n  void *acceptor_data;\n};\n\n\/** Create a new listener *\/\nph_listener_t *ph_listener_new(const char *name,\n    ph_listener_accept_func acceptor);\n\n\/** Bind a listener to a local address\n *\n * If no socket has been associated, associates one prior to calling bind(),\n * and enables address\/port reuse socket options\n *\/\nph_result_t ph_listener_bind(ph_listener_t *lstn, const ph_sockaddr_t *addr);\n\n\/** Returns the underlying socket descriptor for a listener *\/\nph_socket_t ph_listener_get_fd(ph_listener_t *lstn);\n\n\/** Set the listen backlog.\n *\n * If `backlog` is &lt;= 0, attempts to determine the current kernel setting\n * for the `somaxconn` system parameter and uses that, otherwise falls back\n * to the `SOMAXCONN` value from your system header, or if that is undefined,\n * uses the value `128`.\n *\/\nvoid ph_listener_set_backlog(ph_listener_t *lstn, int backlog);\n\n\/** Enable\/Disable the listener\n *\n * When enabled for the first time, calls listen(2) with the backlog that you\n * set.  If you have not set a backlog, a default value will be computed per\n * the description in ph_listener_set_backlog().\n *\n * While enabled, the acceptor function will be invoked from any NBIO thread\n * each time a client connection is accepted.\n *\/\nvoid ph_listener_enable(ph_listener_t *lstn, bool enable);\n\n\/** Set the acceptor data for the listener\n *\n * This allows data to be passed from the function that calls\n * ph_listener_new() to the accept callback function.\n *\n * ```\n * static void handle_recv(ph_sock_t *sock, ph_iomask_t why, void *arg) {\n *   struct path *paths = arg;\n *   \/\/ handle the request with the list of paths...\n * }\n *\n * static void handle_accept(ph_listener_t *lstn, ph_sock_t* sock)\n * {\n *   struct path *paths = ph_listener_get_acceptor_data(lstn);\n *   sock-&gt;job.data = paths;\n *   sock-&gt;callback = handle_recv;\n *   ph_log(PH_LOG_INFO, &quot;accepted `P{sockaddr:%p}&quot;, (void*)&amp;sock-&gt;peername);\n *   ph_sock_enable(sock, true);\n * }\n *\n * void http_start(char *name, char *address, uint32_t port, struct path *paths)\n * {\n *   ph_listener_t *listener = ph_listener_new(name, handle_accept);\n *   ph_listener_set_acceptor_data(listener, routes);\n *   \/\/ bind and enable listener...\n * }\n * ```\n *\/\nvoid ph_listener_set_acceptor_data(ph_listener_t *lstn, void *data);\n\n\/** Get the acceptor data for the listener *\/\nvoid *ph_listener_get_acceptor_data(ph_listener_t *lstn);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n"
    },
    "log": {
        "name": "log",
        "title": "log",
        "content": "\n# Logging\nlibPhenom provides simple but useful logging utilities.\n\nEach logged message is associated with one of the following\nseverity levels:\n\n* `PH_LOG_PANIC` - the world is going to end\n* `PH_LOG_ALERT` - take notice this is very import\n* `PH_LOG_CRIT`  - almost as important as alert\n* `PH_LOG_ERR`   - something bad happened; you should probably look at it\n* `PH_LOG_WARN`  - something happened but it may not be actionable\n* `PH_LOG_NOTICE` - somewhat noisy notification about something\n* `PH_LOG_INFO` - rather more noisy notification of something\n* `PH_LOG_DEBUG` - noisy diagnostic mode\n\nThe system has an overall log level that specifies the threshold for\nwhich log messages will be allowed to hit the underyling logs.\n\nThe default is `PH_LOG_ERR`, meaning that a log event must be `PH_LOG_ERR`\nor higher for the message to hit the logs.\n\nExpanded log messages have a maximum length of 1024 bytes in the\ncurrent implementation.\n\n## Logging Hook\n\nYou may register to observe log messages.  The constant `PH_LOG_HOOK_NAME`\nidentifies the hook point.  The hook receives 2 parameters:\n\n* `args[0]` -> `uint8_t *level` the requested log level\n* `args[1]` -> `ph_string_t *str` the string being logged\n\nNote that the string is only valid for the duration of the call to the hookpoint.\nIt is stored in transient storage and will be freed after the hookpoint returns.\nIf you need to retain the string contents for async work, you should copy it\nusing ph_string_make_copy().\n\nLogging hooks receive only messages that are at or above the current logging level\nsetting.\n\n## Default Logging\n\nBy default, logs are written to the STDERR file descriptor.  You can turn off\nthis default by calling ph_log_disable_stderr().\n\n### ph_log_level_set\n\n```c\nuint8_t ph_log_level_set(uint8_t level);\n```\n\n\n*set the logging level*\n\n\n### ph_log_level_get\n\n```c\nuint8_t ph_log_level_get(void);\n```\n\n\n*get the logging level*\n\n\n### ph_log\n\n```c\nvoid ph_log(uint8_t level, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n```\n\n\n*log something*\n\n\n* `level` - the severity level of the event\n* `fmt` - a ph_printf compatible format string\n\nExpands the format string and decorates it with the\ncurrent timestamp, executing thread name and id,\nnormalizes the line (a missing newline will be added)\nand sends the result to the log.\n\n### ph_logv\n\n```c\nvoid ph_logv(uint8_t level, const char *fmt, va_list ap);\n```\n\n\n*log something (va_list)*\n\n\nExactly like `ph_log` but accepts a `va_list` for simpler\nuse in composing functions that also log things.\n\n* `level` - the severity level\n* `fmt` - the ph_printf compatible format string\n* `ap` - a va_list representing the arguments for the format string\n\n### ph_log_stacktrace\n\n```c\nvoid ph_log_stacktrace(uint8_t level);\n```\n\n\n*Logs the current call stack at the specified log level.*\n\nThis may block or trigger IO while symbols are loaded.\nIt is intended to be used in last-resort or debug situations,\nand not in the hot-path.\nIt may be a NOP on some systems.\n\n### ph_log_disable_stderr\n\n```c\nvoid ph_log_disable_stderr(void);\n```\n\n\n*Disable logging to STDERR*\n\n",
        "decl_titles": [
            "ph_log_level_set",
            "ph_log_level_get",
            "ph_log",
            "ph_logv",
            "ph_log_stacktrace",
            "ph_log_disable_stderr"
        ],
        "raw_content": "\/*\n * Copyright 2012-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n\/**\n * # Logging\n * libPhenom provides simple but useful logging utilities.\n *\n * Each logged message is associated with one of the following\n * severity levels:\n *\n * * `PH_LOG_PANIC` - the world is going to end\n * * `PH_LOG_ALERT` - take notice this is very import\n * * `PH_LOG_CRIT`  - almost as important as alert\n * * `PH_LOG_ERR`   - something bad happened; you should probably look at it\n * * `PH_LOG_WARN`  - something happened but it may not be actionable\n * * `PH_LOG_NOTICE` - somewhat noisy notification about something\n * * `PH_LOG_INFO` - rather more noisy notification of something\n * * `PH_LOG_DEBUG` - noisy diagnostic mode\n *\n * The system has an overall log level that specifies the threshold for\n * which log messages will be allowed to hit the underyling logs.\n *\n * The default is `PH_LOG_ERR`, meaning that a log event must be `PH_LOG_ERR`\n * or higher for the message to hit the logs.\n *\n * Expanded log messages have a maximum length of 1024 bytes in the\n * current implementation.\n *\n * ## Logging Hook\n *\n * You may register to observe log messages.  The constant `PH_LOG_HOOK_NAME`\n * identifies the hook point.  The hook receives 2 parameters:\n *\n * * `args[0]` -&gt; `uint8_t *level` the requested log level\n * * `args[1]` -&gt; `ph_string_t *str` the string being logged\n *\n * Note that the string is only valid for the duration of the call to the hookpoint.\n * It is stored in transient storage and will be freed after the hookpoint returns.\n * If you need to retain the string contents for async work, you should copy it\n * using ph_string_make_copy().\n *\n * Logging hooks receive only messages that are at or above the current logging level\n * setting.\n *\n * ## Default Logging\n *\n * By default, logs are written to the STDERR file descriptor.  You can turn off\n * this default by calling ph_log_disable_stderr().\n *\/\n\n#ifndef PHENOM_LOG_H\n#define PHENOM_LOG_H\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n#define PH_LOG_HOOK_NAME &quot;phenom::log::ph_log&quot;\n\n#define PH_LOG_PANIC    0\n#define PH_LOG_ALERT    1\n#define PH_LOG_CRIT     2\n#define PH_LOG_ERR      3\n#define PH_LOG_WARN     4\n#define PH_LOG_NOTICE   5\n#define PH_LOG_INFO     6\n#define PH_LOG_DEBUG    7\n\n\/** set the logging level *\/\nuint8_t ph_log_level_set(uint8_t level);\n\n\/** get the logging level *\/\nuint8_t ph_log_level_get(void);\n\n\/** log something\n *\n * * `level` - the severity level of the event\n * * `fmt` - a ph_printf compatible format string\n *\n * Expands the format string and decorates it with the\n * current timestamp, executing thread name and id,\n * normalizes the line (a missing newline will be added)\n * and sends the result to the log.\n *\/\nvoid ph_log(uint8_t level, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n\n\/** log something (va_list)\n *\n * Exactly like `ph_log` but accepts a `va_list` for simpler\n * use in composing functions that also log things.\n *\n * * `level` - the severity level\n * * `fmt` - the ph_printf compatible format string\n * * `ap` - a va_list representing the arguments for the format string\n *\/\nvoid ph_logv(uint8_t level, const char *fmt, va_list ap);\n\n\/** Logs the current call stack at the specified log level.\n * This may block or trigger IO while symbols are loaded.\n * It is intended to be used in last-resort or debug situations,\n * and not in the hot-path.\n * It may be a NOP on some systems.\n *\/\nvoid ph_log_stacktrace(uint8_t level);\n\n\/** Disable logging to STDERR *\/\nvoid ph_log_disable_stderr(void);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "memory": {
        "name": "memory",
        "title": "memory",
        "content": "\n# Memory management facility\n\nIt is important for long-running infrastructure software to maintain\ninformation about its memory usage.  This facility allows named memory\ntypes to be registered and have stats maintained against them.\n\n### struct ph_memtype_def\n\n```c\nstruct ph_memtype_def {\n  \/* General category of allocations.\n   * Convention is to name it after the module or subsystem.\n   * This will be used to construct a counter name of the form:\n   * memory\/<facility>\/<name>\n   *\/\n  const char *facility;\n  \/* Name of this memtype.\n   * See note in facility above *\/\n  const char *name;\n  \/* Size of each distinct object of this type of memory.\n   * This may be used as a hint to the underlying allocator,\n   * and impacts the metrics that are collected about the\n   * allocations.\n   * If the item_size is zero, then allocations may be\n   * of any size *\/\n  uint64_t item_size;\n  \/* One of the PH_MEM_FLAGS:\n   * PH_MEM_FLAGS_ZERO - implicitly zero out the memory before\n   *   returning it from ph_mem_alloc() or ph_mem_alloc_size()\n   * PH_MEM_FLAGS_PANIC - if the allocation fails, call `ph_panic`.\n   *   Use this only for extremely critical allocations with no reasonable\n   *   recovery path.\n   *\/\n  unsigned flags;\n};\n```\n\n\n*defines a memory type.*\n\n\nThis data structure is used to define a named memory type.\n\n### ph_memtype_register\n\n```c\nph_memtype_t ph_memtype_register(const ph_memtype_def_t *def);\n```\n\n\n*Registers a memtype*\n\n\nReturns the memtype identifier, or PH_MEMTYPE_INVALID if\nregistration failed.\n\n### ph_memtype_register_block\n\n```c\nph_memtype_t ph_memtype_register_block(\n    uint8_t num_types,\n    const ph_memtype_def_t *defs,\n    ph_memtype_t *types);\n```\n\n\n*Registers a block of memtypes in one operation.*\n\n\nThe definitions MUST all have the same facility name.\n\n\"defs\" must point to the start of an array of \"num_types\" memtype definition\nstructures.\n\nThe \"types\" parameter may be NULL.  If it is not NULL, it must\npoint to the start of an array of \"num_types\" elements to receive\nthe assigned memtype identifier for each of the registered\nmemtypes.\n\nThis function always assigns a contiguous block of memtype identifiers.\n\nReturns the memtype identifier corresponding to the first definition, or\nPH_MEMTYPE_INVALID if the registration failed.\n```\nph_memtype_def_t defs[] = {\n  { \"example\", \"one\", 0, 0 },\n  { \"example\", \"two\", 0, 0 }\n};\nstruct {\n  ph_memtype_t one, two\n} mt;\nph_memtype_register_block(\n  sizeof(defs) \/ sizeof(defs[0]),\n  defs,\n  &mt.one);\n\/\/ Now I can use mt.one and mt.two to allocate\n```\n\n### ph_mem_alloc\n\n```c\nvoid *ph_mem_alloc(ph_memtype_t memtype)\n#ifdef __GNUC__\n  __attribute__((malloc))\n#endif\n  ;\n```\n\n\n*Allocates a fixed-size memory chunk*\n\n\nGiven a memory type, allocates a block of memory of its defined\nsize and returns it.\n\nif PH_MEM_FLAGS_ZERO was specified in the flags of the memtype,\nthe memory region will be cleared to zero before it is returned.\n\nIt is an error to call this for a memtype that was defined with\na 0 size.\n\n### ph_mem_alloc_size\n\n```c\nvoid *ph_mem_alloc_size(ph_memtype_t memtype, uint64_t size)\n#ifdef __GNUC__\n  __attribute__((malloc))\n#endif\n  ;\n```\n\n\n*Allocates a variable-size memory chunk*\n\n\nGiven a memory type that was registered with size 0, allocates\na chunk of the specified size and returns it.\n\nif PH_MEM_FLAGS_ZERO was specified in the flags of the memtype,\nthe memory region will be cleared to zero before it is returned.\n\nIt is an error to call this for a memtype that was not defined with\na 0 size.\n\n### ph_mem_realloc\n\n```c\nvoid *ph_mem_realloc(ph_memtype_t memtype, void *ptr, uint64_t size);\n```\n\n\n*Reallocates a variable-size memory chunk.*\n\n\nChanges the size of the memory pointed to by \"ptr\" to \"size\" bytes.\nThe contents of the memory at \"ptr\" are unchanged to the minimum\nof the old and new sizes.\n\nIf the block is grown, the remaining space will hold undefined\nvalues unless PH_MEM_FLAGS_ZERO was specified in the memtype.\n\nIf ptr is NULL, this is equivalent to ph_mem_alloc_size().\n\nIf size is 0, this is equivalent to ph_mem_free().\n\nIt is an error if ptr was allocated against a different memtype.\n\nIf the memory was moved, the original ptr value will be freed.\n\n### ph_mem_free\n\n```c\nvoid ph_mem_free(ph_memtype_t memtype, void *ptr);\n```\n\n\n*Frees a memory chunk*\n\n\nThe memory MUST have been allocated via ph_mem_alloc()\nor ph_mem_alloc_size().\n\n### ph_mem_strdup\n\n```c\nchar *ph_mem_strdup(ph_memtype_t memtype, const char *str);\n```\n\n\n*Duplicates a C-String using a memtype*\n\n\nBehaves like strdup(3), except that the storage is allocated\nagainst the specified memtype.\n\nIt is an error to call this for a memtype that was not defined\nwith a 0 size.\n\n### struct ph_mem_stats\n\n```c\nstruct ph_mem_stats {\n  \/* the definition *\/\n  const ph_memtype_def_t *def;\n  \/* current amount of allocated memory in bytes *\/\n  uint64_t bytes;\n  \/* total number of out-of-memory events (allocation failures) *\/\n  uint64_t oom;\n  \/* total number of successful allocation events *\/\n  uint64_t allocs;\n  \/* total number of calls to free *\/\n  uint64_t frees;\n  \/* total number of calls to realloc (that are not themselves\n   * equivalent to an alloc or free) *\/\n  uint64_t reallocs;\n};\n```\n\n\n*Data structure for querying memory usage information.*\n\n\nThis is implemented on top of the counter subsytem\n\n### ph_mem_stat\n\n```c\nbool ph_mem_stat(ph_memtype_t memtype, ph_mem_stats_t *stats);\n```\n\n\n*Queries information about the specified memtype.*\n\n\n* `memtype` - the memtype being interrogated\n* `stats` - receives the usage information\n\n### ph_mem_stat_facility\n\n```c\nint ph_mem_stat_facility(const char *facility,\n    int num_stats, ph_mem_stats_t *stats);\n```\n\n\n*Queries information about memtypes in the specified facility.*\n\n\n* `facility` - the facility name of interest\n* `num_stats` - the number of elements in the stats array\n* `stats` - array of num_stats elements, receives the stats\n\nReturns the number of stats that were populated.\n\n### ph_mem_stat_range\n\n```c\nint ph_mem_stat_range(ph_memtype_t start,\n    ph_memtype_t end, ph_mem_stats_t *stats);\n```\n\n\n*Queries information about a range of memtypes in the system.*\n\n\n* `start` - starting memtype in the range\n* `end` - ending memtype of the range (exclusive)\n* `stats` - array of (end - start) elements to receive stats\n\nReturns the number of stats that were populated.\nA short return value indicates that there are no more memtypes beyond\nthe \"end\" parameter.\n\n### ph_mem_type_by_name\n\n```c\nph_memtype_t ph_mem_type_by_name(const char *facility,\n    const char *name);\n```\n\n\n*Resolves a memory type by name*\n\n\nIntended as a diagnostic\/testing aid.\n",
        "decl_titles": [
            "struct ph_memtype_def",
            "ph_memtype_register",
            "ph_memtype_register_block",
            "ph_mem_alloc",
            "ph_mem_alloc_size",
            "ph_mem_realloc",
            "ph_mem_free",
            "ph_mem_strdup",
            "struct ph_mem_stats",
            "ph_mem_stat",
            "ph_mem_stat_facility",
            "ph_mem_stat_range",
            "ph_mem_type_by_name"
        ],
        "raw_content": "\/*\n * Copyright 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n\/**\n * # Memory management facility\n *\n * It is important for long-running infrastructure software to maintain\n * information about its memory usage.  This facility allows named memory\n * types to be registered and have stats maintained against them.\n *\/\n#ifndef PHENOM_MEMORY_H\n#define PHENOM_MEMORY_H\n\n#include &lt;phenom\/defs.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/* represents a registered memory type *\/\ntypedef int ph_memtype_t;\n#define PH_MEMTYPE_INVALID  0\n#define PH_MEMTYPE_FIRST    2\n\n\/* requests that allocations are zero&#039;d out before being returned *\/\n#define PH_MEM_FLAGS_ZERO 1\n\n\/* panic if memory could not be allocated *\/\n#define PH_MEM_FLAGS_PANIC 2\n\n\/** defines a memory type.\n *\n * This data structure is used to define a named memory type.\n *\/\nstruct ph_memtype_def {\n  \/* General category of allocations.\n   * Convention is to name it after the module or subsystem.\n   * This will be used to construct a counter name of the form:\n   * memory\/&lt;facility&gt;\/&lt;name&gt;\n   *\/\n  const char *facility;\n  \/* Name of this memtype.\n   * See note in facility above *\/\n  const char *name;\n  \/* Size of each distinct object of this type of memory.\n   * This may be used as a hint to the underlying allocator,\n   * and impacts the metrics that are collected about the\n   * allocations.\n   * If the item_size is zero, then allocations may be\n   * of any size *\/\n  uint64_t item_size;\n  \/* One of the PH_MEM_FLAGS:\n   * PH_MEM_FLAGS_ZERO - implicitly zero out the memory before\n   *   returning it from ph_mem_alloc() or ph_mem_alloc_size()\n   * PH_MEM_FLAGS_PANIC - if the allocation fails, call `ph_panic`.\n   *   Use this only for extremely critical allocations with no reasonable\n   *   recovery path.\n   *\/\n  unsigned flags;\n};\ntypedef struct ph_memtype_def ph_memtype_def_t;\n\n\/** Registers a memtype\n *\n * Returns the memtype identifier, or PH_MEMTYPE_INVALID if\n * registration failed.\n *\/\nph_memtype_t ph_memtype_register(const ph_memtype_def_t *def);\n\n\/** Registers a block of memtypes in one operation.\n *\n * The definitions MUST all have the same facility name.\n *\n * &quot;defs&quot; must point to the start of an array of &quot;num_types&quot; memtype definition\n * structures.\n *\n * The &quot;types&quot; parameter may be NULL.  If it is not NULL, it must\n * point to the start of an array of &quot;num_types&quot; elements to receive\n * the assigned memtype identifier for each of the registered\n * memtypes.\n *\n * This function always assigns a contiguous block of memtype identifiers.\n *\n * Returns the memtype identifier corresponding to the first definition, or\n * PH_MEMTYPE_INVALID if the registration failed.\n```\nph_memtype_def_t defs[] = {\n  { &quot;example&quot;, &quot;one&quot;, 0, 0 },\n  { &quot;example&quot;, &quot;two&quot;, 0, 0 }\n};\nstruct {\n  ph_memtype_t one, two\n} mt;\nph_memtype_register_block(\n  sizeof(defs) \/ sizeof(defs[0]),\n  defs,\n  &amp;mt.one);\n\/\/ Now I can use mt.one and mt.two to allocate\n```\n *\/\nph_memtype_t ph_memtype_register_block(\n    uint8_t num_types,\n    const ph_memtype_def_t *defs,\n    ph_memtype_t *types);\n\n\/** Allocates a fixed-size memory chunk\n *\n * Given a memory type, allocates a block of memory of its defined\n * size and returns it.\n *\n * if PH_MEM_FLAGS_ZERO was specified in the flags of the memtype,\n * the memory region will be cleared to zero before it is returned.\n *\n * It is an error to call this for a memtype that was defined with\n * a 0 size.\n *\/\nvoid *ph_mem_alloc(ph_memtype_t memtype)\n#ifdef __GNUC__\n  __attribute__((malloc))\n#endif\n  ;\n\n\/** Allocates a variable-size memory chunk\n *\n * Given a memory type that was registered with size 0, allocates\n * a chunk of the specified size and returns it.\n *\n * if PH_MEM_FLAGS_ZERO was specified in the flags of the memtype,\n * the memory region will be cleared to zero before it is returned.\n *\n * It is an error to call this for a memtype that was not defined with\n * a 0 size.\n *\/\nvoid *ph_mem_alloc_size(ph_memtype_t memtype, uint64_t size)\n#ifdef __GNUC__\n  __attribute__((malloc))\n#endif\n  ;\n\n\/** Reallocates a variable-size memory chunk.\n *\n * Changes the size of the memory pointed to by &quot;ptr&quot; to &quot;size&quot; bytes.\n * The contents of the memory at &quot;ptr&quot; are unchanged to the minimum\n * of the old and new sizes.\n *\n * If the block is grown, the remaining space will hold undefined\n * values unless PH_MEM_FLAGS_ZERO was specified in the memtype.\n *\n * If ptr is NULL, this is equivalent to ph_mem_alloc_size().\n *\n * If size is 0, this is equivalent to ph_mem_free().\n *\n * It is an error if ptr was allocated against a different memtype.\n *\n * If the memory was moved, the original ptr value will be freed.\n *\/\nvoid *ph_mem_realloc(ph_memtype_t memtype, void *ptr, uint64_t size);\n\n\/** Frees a memory chunk\n *\n * The memory MUST have been allocated via ph_mem_alloc()\n * or ph_mem_alloc_size().\n *\/\nvoid ph_mem_free(ph_memtype_t memtype, void *ptr);\n\n\/** Duplicates a C-String using a memtype\n *\n * Behaves like strdup(3), except that the storage is allocated\n * against the specified memtype.\n *\n * It is an error to call this for a memtype that was not defined\n * with a 0 size.\n *\/\nchar *ph_mem_strdup(ph_memtype_t memtype, const char *str);\n\n\/** Data structure for querying memory usage information.\n *\n * This is implemented on top of the counter subsytem\n *\/\nstruct ph_mem_stats {\n  \/* the definition *\/\n  const ph_memtype_def_t *def;\n  \/* current amount of allocated memory in bytes *\/\n  uint64_t bytes;\n  \/* total number of out-of-memory events (allocation failures) *\/\n  uint64_t oom;\n  \/* total number of successful allocation events *\/\n  uint64_t allocs;\n  \/* total number of calls to free *\/\n  uint64_t frees;\n  \/* total number of calls to realloc (that are not themselves\n   * equivalent to an alloc or free) *\/\n  uint64_t reallocs;\n};\ntypedef struct ph_mem_stats ph_mem_stats_t;\n\n\/** Queries information about the specified memtype.\n *\n * * `memtype` - the memtype being interrogated\n * * `stats` - receives the usage information\n *\/\nbool ph_mem_stat(ph_memtype_t memtype, ph_mem_stats_t *stats);\n\n\/** Queries information about memtypes in the specified facility.\n *\n * * `facility` - the facility name of interest\n * * `num_stats` - the number of elements in the stats array\n * * `stats` - array of num_stats elements, receives the stats\n *\n * Returns the number of stats that were populated.\n *\/\nint ph_mem_stat_facility(const char *facility,\n    int num_stats, ph_mem_stats_t *stats);\n\n\/** Queries information about a range of memtypes in the system.\n *\n * * `start` - starting memtype in the range\n * * `end` - ending memtype of the range (exclusive)\n * * `stats` - array of (end - start) elements to receive stats\n *\n * Returns the number of stats that were populated.\n * A short return value indicates that there are no more memtypes beyond\n * the &quot;end&quot; parameter.\n *\/\nint ph_mem_stat_range(ph_memtype_t start,\n    ph_memtype_t end, ph_mem_stats_t *stats);\n\n\/** Resolves a memory type by name\n *\n * Intended as a diagnostic\/testing aid.\n *\/\nph_memtype_t ph_mem_type_by_name(const char *facility,\n    const char *name);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "openssl": {
        "name": "openssl",
        "title": "openssl",
        "content": "\n### ph_library_init_openssl\n\n```c\nvoid ph_library_init_openssl(void);\n```\n\n\n*Initialize multi-threaded OpenSSL for the process*\n\n\nIf you are building an application that owns the process, as opposed\nto a library that is loaded into an existing process, you will need\nto correctly configure OpenSSL for multithreaded use.\n\nlibPhenom provides this function as a convenience; you should only\ncall it if you don't already have code to configure the locking\ncallbacks required by OpenSSL.\n\n### ph_openssl_bio_wrap_stream\n\n```c\nBIO *ph_openssl_bio_wrap_stream(ph_stream_t *stm);\n```\n\n\n*Wrap a phenom stream in an OpenSSL BIO*\n\n\nThe BIO is intended to be used for SSL.  The BIO holds a weak\nreference on the stream and will never close the underlying\nstream.\n\n### ph_stm_ssl_open\n\n```c\nph_stream_t *ph_stm_ssl_open(SSL *ssl);\n```\n\n\n*Wrap an OpenSSL SSL object in a phenom stream*\n\n\nThe stream is unbuffered since this is intended to be used with the\nph_sock_t implementation, which implements buffering using `ph_bufq_t`.\n\nClosing the stream will cause SSL_free() to be invoked on the underlying\nssl object.\n\n### ph_openssl_bio_wrap_bufq\n\n```c\nBIO *ph_openssl_bio_wrap_bufq(ph_bufq_t *bufq);\n```\n\n\n*Wrap a phenom bufq in an OpenSSL BIO*\n\n\nThe BIO is intended to be used for SSL.  The BIO holds a weak\nreference to the bufq and will never free the underlying bufq.\n",
        "decl_titles": [
            "ph_library_init_openssl",
            "ph_openssl_bio_wrap_stream",
            "ph_stm_ssl_open",
            "ph_openssl_bio_wrap_bufq"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n\n#ifndef PHENOM_OPENSSL_H\n#define PHENOM_OPENSSL_H\n\n#include &quot;phenom\/buffer.h&quot;\n\n\/\/ Avoid fatal compilation error due to an #if TARGET_OS_MAC line in\n\/\/ a kerberos related include\n#pragma GCC diagnostic ignored &quot;-Wundef&quot;\n#ifdef __APPLE__\n#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;\n#endif\n#include &lt;openssl\/err.h&gt;\n#include &lt;openssl\/engine.h&gt;\n#include &lt;openssl\/ssl.h&gt;\n#pragma GCC diagnostic error &quot;-Wundef&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/** Initialize multi-threaded OpenSSL for the process\n *\n * If you are building an application that owns the process, as opposed\n * to a library that is loaded into an existing process, you will need\n * to correctly configure OpenSSL for multithreaded use.\n *\n * libPhenom provides this function as a convenience; you should only\n * call it if you don&#039;t already have code to configure the locking\n * callbacks required by OpenSSL.\n *\/\nvoid ph_library_init_openssl(void);\n\n\/** Wrap a phenom stream in an OpenSSL BIO\n *\n * The BIO is intended to be used for SSL.  The BIO holds a weak\n * reference on the stream and will never close the underlying\n * stream.\n *\/\nBIO *ph_openssl_bio_wrap_stream(ph_stream_t *stm);\n\n\/** Wrap an OpenSSL SSL object in a phenom stream\n *\n * The stream is unbuffered since this is intended to be used with the\n * ph_sock_t implementation, which implements buffering using `ph_bufq_t`.\n *\n * Closing the stream will cause SSL_free() to be invoked on the underlying\n * ssl object.\n *\/\nph_stream_t *ph_stm_ssl_open(SSL *ssl);\n\n\/** Wrap a phenom bufq in an OpenSSL BIO\n *\n * The BIO is intended to be used for SSL.  The BIO holds a weak\n * reference to the bufq and will never free the underlying bufq.\n *\/\nBIO *ph_openssl_bio_wrap_bufq(ph_bufq_t *bufq);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "printf": {
        "name": "printf",
        "title": "printf",
        "content": "\n### ph_vprintf_named_formatter_func\n\n```c\ntypedef size_t (*ph_vprintf_named_formatter_func)(\n    void *formatter_arg,\n    void *object,\n    void *print_arg,\n    const struct ph_vprintf_funcs *funcs);\n```\n\n\n*Defines a named formatter*\n\n`formatter_arg` is the `arg` that was registered by\nph_vprintf_register().\n`object` is the value identified by the %p in the format string.\n`print_arg` should be passed as the first arg to `funcs->print`.\n`funcs` is used to carry out the printing\n\n### ph_vprintf_register\n\n```c\nbool ph_vprintf_register(const char *name, void *formatter_arg,\n    ph_vprintf_named_formatter_func func);\n```\n\n\n*Register a named formatter*\n\n\nThe suggested usage is:\n\n```\nPH_TYPE_FORMATTER_FUNC(myfunc) {\n  \/\/ available locals are per ph_vprintf_named_formatter_func\n  funcs->print(funcs->print_arg, \"myfunc\", strlen(\"myfunc\"));\n  return strlen(\"myfunc\");\n}\n```\n\nThis will automatically register your formatting function during\nph_library_init().\n\n### ph_vprintf_core\n\n```c\nint ph_vprintf_core(void *print_arg,\n    const struct ph_vprintf_funcs *print_funcs,\n    const char *fmt0, va_list ap);\n```\n\n\n*Portable string formatting.*\n\nThis handles things like NULL string pointers without faulting.\nIt does not support long doubles nor does it support hex double\nformatting.  It does not support locale for decimal points;\nwe always print those as `.`\n\nExtensions: some helpers are provided to format information\nfrom the phenom library.  These extensions are designed such\nthat the gcc printf format type checking can still be used;\nwe prefix the extended format specifier with a backtick and\na 'P' character.\n\nFor instance, \\`Pe%d is seen as `%d` by GCC's checker\nbut the entire \\`Pe%d is replaced by the strerror expansion.\n\n```none\n `Pe%d -   replaced by the return from strerror(arg), using\n           strerror_r() when present, where arg is an errno\n           argument supplied by you.\n `Pv%s%p - recursively expands a format string and a va_list.\n           Arguments are a char* and ph_vaptr(va_list)\n `Ps%p -   replaced by the contents of the ph_string_t* argument\n `Ps%d%p - replaced by the first n bytes specified by the integer\n           argument of the ph_string_t* argument.\n `P{name:%p} - Looks up \"name\" in the formatting callback table.\n               Passes the object specified by the pointer argument\n               to the formatted and is replaced by the result\n```\n\n\n### ph_vsnprintf\n\n```c\nint ph_vsnprintf(char *buf, size_t size, const char *fmt, va_list ap);\n```\n\n\n*Like vsnprintf(), except that it uses ph_vprintf_core()*\n\n\n### ph_snprintf\n\n```c\nint ph_snprintf(char *buf, size_t size, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 3, 4)))\n#endif\n  ;\n```\n\n\n*Like snprintf(), except that it uses ph_vprintf_core()*\n\n\n### ph_vfdprintf\n\n```c\nint ph_vfdprintf(int fd, const char *fmt, va_list ap);\n```\n\n\n*Uses ph_vprintf_core to print to a file descriptor.*\n\nUses a 1k buffer internally to reduce the number of calls\nto the write() syscall.\n\n### ph_fdprintf\n\n```c\nint ph_fdprintf(int fd, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n```\n\n\n*Uses ph_vprintf_core to print to a file descriptor*\n\n\n### ph_vasprintf\n\n```c\nint ph_vasprintf(char **strp, const char *fmt, va_list ap);\n```\n\n\n*Like asprintf, except that it uses ph_vprintf_core().*\n\nOn error, returns -1 and sets strp to NULL\n\n### ph_vmtsprintf\n\n```c\nint ph_vmtsprintf(ph_memtype_t memtype, char **strp,\n    const char *fmt, va_list ap);\n```\n\n\n*Like ph_asprintf, except that it uses the specified*\n\nmemtype for the memory it allocates.\nOn error, returns -1 and sets strp to NULL\n",
        "decl_titles": [
            "ph_vprintf_named_formatter_func",
            "ph_vprintf_register",
            "ph_vprintf_core",
            "ph_vsnprintf",
            "ph_snprintf",
            "ph_vfdprintf",
            "ph_fdprintf",
            "ph_vasprintf",
            "ph_vmtsprintf"
        ],
        "raw_content": "\/*\n * Copyright 2012-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_PRINTF_H\n#define PHENOM_PRINTF_H\n\n#include &quot;phenom\/defs.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_vprintf_funcs {\n  bool (*print)(void *arg, const char *buf, size_t len);\n  bool (*flush)(void *arg);\n};\n\n\/** Defines a named formatter\n * `formatter_arg` is the `arg` that was registered by\n * ph_vprintf_register().\n * `object` is the value identified by the %p in the format string.\n * `print_arg` should be passed as the first arg to `funcs-&gt;print`.\n * `funcs` is used to carry out the printing\n *\/\ntypedef size_t (*ph_vprintf_named_formatter_func)(\n    void *formatter_arg,\n    void *object,\n    void *print_arg,\n    const struct ph_vprintf_funcs *funcs);\n\n\/** Register a named formatter\n *\n * The suggested usage is:\n *\n * ```\n * PH_TYPE_FORMATTER_FUNC(myfunc) {\n *   \/\/ available locals are per ph_vprintf_named_formatter_func\n *   funcs-&gt;print(funcs-&gt;print_arg, &quot;myfunc&quot;, strlen(&quot;myfunc&quot;));\n *   return strlen(&quot;myfunc&quot;);\n * }\n * ```\n *\n * This will automatically register your formatting function during\n * ph_library_init().\n *\/\nbool ph_vprintf_register(const char *name, void *formatter_arg,\n    ph_vprintf_named_formatter_func func);\n\n#define PH_TYPE_FORMATTER_REGISTER(tname) \\\nstatic void ph_vprintf_named_formatter_register_##tname(void) { \\\n  ph_vprintf_register(#tname, NULL, \\\n      ph_vprintf_named_formatter_func_##tname); \\\n} \\\nPH_LIBRARY_INIT(ph_vprintf_named_formatter_register_##tname, 0)\n\n#define PH_TYPE_FORMATTER_FUNC(tname) \\\nsize_t ph_vprintf_named_formatter_func_##tname(void*, void*, void*, \\\n    const struct ph_vprintf_funcs*); \\\nPH_TYPE_FORMATTER_REGISTER(tname) \\\nsize_t ph_vprintf_named_formatter_func_##tname(\\\n    CK_CC_UNUSED void *formatter_arg, void *object, void *print_arg, \\\n    const struct ph_vprintf_funcs *funcs)\n\n\/** Portable string formatting.\n * This handles things like NULL string pointers without faulting.\n * It does not support long doubles nor does it support hex double\n * formatting.  It does not support locale for decimal points;\n * we always print those as `.`\n *\n * Extensions: some helpers are provided to format information\n * from the phenom library.  These extensions are designed such\n * that the gcc printf format type checking can still be used;\n * we prefix the extended format specifier with a backtick and\n * a &#039;P&#039; character.\n *\n * For instance, \\`Pe%d is seen as `%d` by GCC&#039;s checker\n * but the entire \\`Pe%d is replaced by the strerror expansion.\n *\n * ```none\n *  `Pe%d -   replaced by the return from strerror(arg), using\n *            strerror_r() when present, where arg is an errno\n *            argument supplied by you.\n *  `Pv%s%p - recursively expands a format string and a va_list.\n *            Arguments are a char* and ph_vaptr(va_list)\n *  `Ps%p -   replaced by the contents of the ph_string_t* argument\n *  `Ps%d%p - replaced by the first n bytes specified by the integer\n *            argument of the ph_string_t* argument.\n *  `P{name:%p} - Looks up &quot;name&quot; in the formatting callback table.\n *                Passes the object specified by the pointer argument\n *                to the formatted and is replaced by the result\n * ```\n *\n *\/\nint ph_vprintf_core(void *print_arg,\n    const struct ph_vprintf_funcs *print_funcs,\n    const char *fmt0, va_list ap);\n\n#define ph_vaptr(ap)    (void*)&amp;ap\n\n\/** Like vsnprintf(), except that it uses ph_vprintf_core() *\/\nint ph_vsnprintf(char *buf, size_t size, const char *fmt, va_list ap);\n\/** Like snprintf(), except that it uses ph_vprintf_core() *\/\nint ph_snprintf(char *buf, size_t size, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 3, 4)))\n#endif\n  ;\n\n\/** Uses ph_vprintf_core to print to a file descriptor.\n * Uses a 1k buffer internally to reduce the number of calls\n * to the write() syscall. *\/\nint ph_vfdprintf(int fd, const char *fmt, va_list ap);\n\/** Uses ph_vprintf_core to print to a file descriptor *\/\nint ph_fdprintf(int fd, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n\n\/** Like asprintf, except that it uses ph_vprintf_core().\n * On error, returns -1 and sets strp to NULL *\/\nint ph_vasprintf(char **strp, const char *fmt, va_list ap);\nint ph_asprintf(char **strp, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n\n\/** Like ph_asprintf, except that it uses the specified\n * memtype for the memory it allocates.\n * On error, returns -1 and sets strp to NULL *\/\nint ph_vmtsprintf(ph_memtype_t memtype, char **strp,\n    const char *fmt, va_list ap);\nint ph_mtsprintf(ph_memtype_t memtype, char **strp,\n    const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 3, 4)))\n#endif\n  ;\n\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "refcnt": {
        "name": "refcnt",
        "title": "refcnt",
        "content": "\n# Reference Counting\n\nHelpers for working with reference counters in C.\nThese delegate to Concurrency Kit and use the\nprimitive fetch-and-add functions (ck_pr_faa_XXX).\n\n* * *\n\n```c\ntypedef int ph_refcnt_t;\n```\n\n\n*holds a reference count*\n\n\n### ph_refcnt_add\n\n```c\nvoid ph_refcnt_add(ph_refcnt_t *ref)\n```\n\n\n*adds a reference*\n\n\n### ph_refcnt_del\n\n```c\nbool ph_refcnt_del(ph_refcnt_t *ref)\n```\n\n\n*releases a reference*\n\nReturns true if we just released the final reference\n",
        "decl_titles": [
            "ph_refcnt_add",
            "ph_refcnt_del"
        ],
        "raw_content": "\/*\n * Copyright 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_REFCNT_H\n#define PHENOM_REFCNT_H\n\n\/**\n * # Reference Counting\n *\n * Helpers for working with reference counters in C.\n * These delegate to Concurrency Kit and use the\n * primitive fetch-and-add functions (ck_pr_faa_XXX).\n *\/\n\n#include &lt;ck_pr.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/** holds a reference count *\/\ntypedef int ph_refcnt_t;\n\n\/** adds a reference *\/\nstatic inline void ph_refcnt_add(ph_refcnt_t *ref)\n{\n  ck_pr_inc_int(ref);\n}\n\n\/** releases a reference\n * Returns true if we just released the final reference *\/\nstatic inline bool ph_refcnt_del(ph_refcnt_t *ref)\n{\n  return ck_pr_faa_int(ref, -1) == 1;\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "socket": {
        "name": "socket",
        "title": "socket",
        "content": "\n### struct phenom_sockaddr\n\n```c\nstruct phenom_sockaddr {\n  sa_family_t family;\n```\n\n\n*Represents a socket address*\n\n\n### ph_sockaddr_socklen\n\n```c\nint ph_sockaddr_socklen(const ph_sockaddr_t *addr)\n```\n\n\n*Returns the length of the underlying sockaddr*\n\n\nThis is useful when passing the sockaddr to lower level\nsocket syscalls\n\n### ph_sockaddr_set_v4\n\n```c\nph_result_t ph_sockaddr_set_v4(ph_sockaddr_t *sa,\n    const char *addr, uint16_t port);\n```\n\n\n*Set a sockaddr to the specified IPv4 address string and port.*\n\nThe address string must be an IPv4 address.  This function\ndoes *not* perform DNS resolution.  It uses inet_pton() under\nthe covers.\n\nIf addr == NULL, then sa is initialized to INADDR_ANY\n\n\n### ph_sockaddr_set_v6\n\n```c\nph_result_t ph_sockaddr_set_v6(\n    ph_sockaddr_t *sa,\n    const char *addr,\n    uint16_t port);\n```\n\n\n*Set a sockaddr to the specified IPv6 address string and port.*\n\nThe address string must be an IPv6 address.  This function\ndoes *not* perform DNS resolution.  It uses getaddrinfo() under\nthe covers, with AI_NUMERICHOST|AI_V4MAPPED as flags.\nThe sockaddr may be set to a v4 mapped address depending on\nthe configuration of the system.\n\nIf addr == NULL, then sa is initialized to in6addr_any\n\n### ph_sockaddr_set_unix\n\n```c\nph_result_t ph_sockaddr_set_unix(\n    ph_sockaddr_t *addr,\n    const char *path,\n    unsigned int pathlen);\n```\n\n\n*Set a sockaddr to the specified UNIX domain address.*\n\nThe address string must be a valid UNIX domain socket path.\nThis function does not support the Linux specific abstract\nnamespace feature, and only supports paths that fit directly\nin sa->sa.nix.sun_path.\n\nIf pathlen == 0, strlen(path) will be assumed.\n\n### ph_sockaddr_set_from_addrinfo\n\n```c\nph_result_t ph_sockaddr_set_from_addrinfo(\n    ph_sockaddr_t *addr,\n    struct addrinfo *ai);\n```\n\n\n*Set a sockaddr to the first entry from an addrinfo*\n\n\n### ph_sockaddr_set_from_hostent\n\n```c\nph_result_t ph_sockaddr_set_from_hostent(\n    ph_sockaddr_t *addr,\n    struct hostent *ent);\n```\n\n\n*Set a sockaddr to the first address from a hostent*\n\n\n### ph_sockaddr_set_port\n\n```c\nvoid ph_sockaddr_set_port(ph_sockaddr_t *addr, uint16_t port);\n```\n\n\n*Set the port number of a sockaddr*\n\n\n### ph_sockaddr_print\n\n```c\nph_result_t ph_sockaddr_print(ph_sockaddr_t *addr,\n    ph_string_t *str, bool want_port);\n```\n\n\n*Print a human readable version of a sockaddr to a string*\n\n\n### ph_socket_set_nonblock\n\n```c\nvoid ph_socket_set_nonblock(ph_socket_t fd, bool enable);\n```\n\n\n*Set or disable non-blocking mode for a file descriptor*\n\n\n### ph_socket_for_addr\n\n```c\nph_socket_t ph_socket_for_addr(const ph_sockaddr_t *addr, int type, int flags);\n```\n\n\n*Creates a socket that can be used to connect to a sockaddr*\n\n\nThe socket is created of the appropriate type and the flags\nare applied:\n\n* `PH_SOCK_CLOEXEC` causes the socket to have CLOEXEC set\n* `PH_SOCK_NONBLOCK` causes the socket to be set to nonblocking mode\n\n```\nph_socket_t s = ph_socket_for_addr(&addr, SOCK_STREAM,\n                   PH_SOCK_CLOEXEC|PH_SOCK_NONBLOCK);\n```\n\n### ph_socket_connect_func\n\n```c\ntypedef void (*ph_socket_connect_func)(\n    ph_socket_t s, const ph_sockaddr_t *addr, int status,\n    struct timeval *elapsed, void *arg);\n```\n\n\n*Handles the results of ph_socket_connect()*\n\n\nIf successful, `s != -1` and `status == 0`.\n\n`addr` points to the address that we attempted to connect.\n\n`status` holds the errno value from the connect syscall.\n\n`elapsed` holds the amount of time that elapsed since the connect\ncall was started.\n\n`arg` passes through the `arg` parameter from ph_socket_connect().\n\n### ph_socket_connect\n\n```c\nvoid ph_socket_connect(ph_socket_t s, const ph_sockaddr_t *addr,\n  struct timeval *timeout, ph_socket_connect_func func, void *arg);\n```\n\n\n*Initiate an async connect() call*\n\n\nThe results will be delivered to your connect func.\nIn some immediate failure cases, this will be called before\nph_socket_connect has returned, but in the common case, this\nwill happen asynchronously from an NBIO thread once the connect\ncall has resolved.\n\nThe `timeout` parameter allows you to specify an upper bound on\nthe time spent waiting for the connect.  If `timeout` is NULL\na implementation dependent default timeout will be used.\n\n### ph_sock_func\n\n```c\ntypedef void (*ph_sock_func)(ph_sock_t *sock, ph_iomask_t why, void *data);\n```\n\n\n*The socket object callback function*\n\n\n### ph_sock_openssl_handshake_func\n\n```c\ntypedef void (*ph_sock_openssl_handshake_func)(\n    ph_sock_t *sock, int res);\n```\n\n\n*Called when we complete a handshake*\n\n\n### struct ph_sock\n\n```c\nstruct ph_sock {\n  \/\/ Embedded job so we can participate in NBIO\n  ph_job_t job;\n\n  \/\/ Buffers for output, input\n  ph_bufq_t *wbuf, *rbuf;\n\n  \/\/ The per IO operation timeout duration\n  struct timeval timeout_duration;\n\n  \/\/ A stream for writing to the underlying connection\n  ph_stream_t *conn;\n  \/\/ A stream representation of myself.  Writing bytes into the\n  \/\/ stream causes the data to be buffered in wbuf\n  ph_stream_t *stream;\n\n  \/\/ Dispatcher\n  ph_sock_func callback;\n  bool enabled;\n\n  \/\/ sockname, peername as seen from this host.\n  \/\/ These correspond to the raw connection we see; if we are\n  \/\/ proxied, these are the names of our connection to the proxy.\n  \/\/ If we are not proxied, these are the same as the equivalents below\n  ph_sockaddr_t via_sockname, via_peername;\n  \/\/ sockname, peername as seen from the connected peer\n  \/\/ These are the actual outgoing address endpoints, independent of\n  \/\/ any proxying that may be employed\n  ph_sockaddr_t sockname, peername;\n\n  \/\/ If we've switched up to SSL, holds our SSL context\n  SSL *ssl;\n  ph_stream_t *ssl_stream;\n  ph_sock_openssl_handshake_func handshake_cb;\n  ph_bufq_t *sslwbuf;\n  \/\/ Whether we should free the associated SSL_CTX on destruction.\n  \/\/ This defaults to true for backwards compatibility.\n  \/\/ If you're building SSL enabled listeners, you probably want to keep\n  \/\/ a global SSL_CTX and set this to false.  For clients, it is often\n  \/\/ easier to leave this set to true.\n  bool free_ssl_ctx;\n};\n```\n\n\n*Socket Object*\n\n\nA socket object is a higher level representation of an underlying\nsocket descriptor.\n\nIt is the preferred way to build higher level socket clients and\nservers, as it takes the boilerplate of managing read\/write buffers\nand async dispatch away from you.\n\nA socket object is either enabled or disabled; when enabled, the\nunderlying descriptor is managed by the NBIO pool and any pending\nwrite data will be sent as and when it is ready to go.  Any pending\nreads will trigger a wakup and you can use the sock functions to\nread chunks or delimited records (such as lines).\n\nIf your client\/server needs to perform some blocking work, you may\nsimply disable the sock until that work is complete.\n\n### ph_sock_new_from_socket\n\n```c\nph_sock_t *ph_sock_new_from_socket(ph_socket_t s, const ph_sockaddr_t *sockname,\n  const ph_sockaddr_t *peername);\n```\n\n\n*Create a new sock object from a socket descriptor*\n\n\nCreates and initialize a socket object using the specified descriptor,\nsockname and peername.\n\n### ph_sock_enable\n\n```c\nvoid ph_sock_enable(ph_sock_t *sock, bool enable);\n```\n\n\n*Enable or disable IO dispatching for a socket object*\n\n\nWhile enabled, the sock will trigger callbacks when it is readable\/writable\nor timed out.  While disabled, none of these conditions will trigger.\n\n### ph_sock_wakeup\n\n```c\nph_result_t ph_sock_wakeup(ph_sock_t *sock);\n```\n\n\n*Wakeup the socket object*\n\n\nQueues an PH_IOMASK_WAKEUP to the sock.  This is primarily useful in cases\nwhere some asynchronous processing has completed and you wish to ping the\nsock job so that it can consume the results.\n\nDelegates to ph_job_wakeup() and can fail for the same reasons as that\nfunction.\n\n### ph_sock_free\n\n```c\nvoid ph_sock_free(ph_sock_t *sock);\n```\n\n\n*Release all resources associated with a socket object*\n\n\nImplicitly disables the socket.\n\n### ph_sock_read_bytes_exact\n\n```c\nph_buf_t *ph_sock_read_bytes_exact(ph_sock_t *sock, uint64_t len);\n```\n\n\n*Read exactly the specified number of bytes*\n\n\nReturns a buffer containing the requested number of bytes, or NULL if they\nare not available.\n\nNever returns a partial read.\n\n### ph_sock_read_record\n\n```c\nph_buf_t *ph_sock_read_record(ph_sock_t *sock, const char *delim,\n    uint32_t delim_len);\n```\n\n\n*Read a delimited record*\n\n\nSearch for the delimiter in the buffer; if found, returns a buffer containing\nthe record and its delimiter text.\n\n### ph_sock_read_line\n\n```c\nph_buf_t *ph_sock_read_line(ph_sock_t *sock);\n```\n\n\n*Read a CRLF delimited line*\n\n\nSearch for the canonical CRLF in the buffer.  If found, returns a buffer\ncontaining the line and its CRLF delimiter.\n\n### ph_sock_connect_func\n\n```c\ntypedef void (*ph_sock_connect_func)(\n    ph_sock_t *sock, int overall_status, int errcode,\n    const ph_sockaddr_t *addr,\n    struct timeval *elapsed, void *arg);\n```\n\n\n*Indicates the results of an async sock connect*\n\n\nIf successful, `sock` will be non-NULL and `overall_status` will be set\nto `PH_SOCK_CONNECT_SUCCESS`.\n\nOn failure `overall_status` will be set to one of `PH_SOCK_CONNECT_GAI_ERR`\nor `PH_SOCK_CONNECT_ERRNO` to indicate how to\ninterpret the `errcode` parameter; they indicate that the errcode can be\nrendered to human readable form via gai_strerror(), ares_strerror() or strerror()\nrespectively.\n\n`addr` may be NULL.  If it is not NULL, it holds the address that we attempted\nto connect to.  It may be set if we didn't successfully connect.\n\n`elapsed` holds the amount of time that has elapsed since we attempted to initiate\nthe connection.\n\n`arg` passes through the arg parameter from ph_sock_resolve_and_connect().\n\n### ph_sock_resolve_and_connect\n\n```c\nvoid ph_sock_resolve_and_connect(const char *name, uint16_t port,\n    struct timeval *timeout, int resolver, ph_sock_connect_func func,\n    void *arg);\n```\n\n\n*Given a name and port, resolve and connect a socket object to it*\n\n\nThis convenience function resolves the name using the specified resolver\n(`PH_SOCK_CONNECT_RESOLVE_SYSTEM` for getaddrinfo)\nand attempts to connect to the first address resolved.\n\nSuccess or failure is communicated to your ph_sock_connect_func.\n\n`timeout` specifies an upper bound on the connection attempt.  If left as NULL,\na default value will be used.\n\n### ph_sock_shutdown\n\n```c\nint ph_sock_shutdown(ph_sock_t *sock, int how)\n```\n\n\n*Perform a shutdown operation on a socket object*\n\n\n### ph_sock_openssl_enable\n\n```c\nvoid ph_sock_openssl_enable(ph_sock_t *sock, SSL *ssl,\n    bool is_client, ph_sock_openssl_handshake_func handshake_cb);\n```\n\n\n*Enable SSL for the sock*\n\n\nConfigures the sock to act as an SSL client or server.\n\nThis will amend the struct to reference SSL variants of the\nstreams and set the session to act as an SSL client or server,\ndepending on the value of the `is_client` parameter.\n\nThis puts the socket into a pending connect or accept state;\nthe socket will work to satisfy this state before dispatching\nany further calls to the sock callback function.\n\nOnce the handshake is complete, the dispatcher will call\nhandshake_cb with the result of the completed SSL_do_handshake()\nfunction call.\n\nYou may use this opportunity to perform additional validation\nof the session.\n\nYou must supply the SSL object for use by this function and ensure\nthat it is correctly configured (certificates and keys loaded, ciphers\nselected and so on).\n",
        "decl_titles": [
            "struct phenom_sockaddr",
            "ph_sockaddr_socklen",
            "ph_sockaddr_set_v4",
            "ph_sockaddr_set_v6",
            "ph_sockaddr_set_unix",
            "ph_sockaddr_set_from_addrinfo",
            "ph_sockaddr_set_from_hostent",
            "ph_sockaddr_set_port",
            "ph_sockaddr_print",
            "ph_socket_set_nonblock",
            "ph_socket_for_addr",
            "ph_socket_connect_func",
            "ph_socket_connect",
            "ph_sock_func",
            "ph_sock_openssl_handshake_func",
            "struct ph_sock",
            "ph_sock_new_from_socket",
            "ph_sock_enable",
            "ph_sock_wakeup",
            "ph_sock_free",
            "ph_sock_read_bytes_exact",
            "ph_sock_read_record",
            "ph_sock_read_line",
            "ph_sock_connect_func",
            "ph_sock_resolve_and_connect",
            "ph_sock_shutdown",
            "ph_sock_openssl_enable"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n\n#ifndef PHENOM_SOCKET_H\n#define PHENOM_SOCKET_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/job.h&quot;\n\n#include &lt;sys\/types.h&gt;\n#include &lt;sys\/socket.h&gt;\n#include &lt;sys\/un.h&gt;\n#include &lt;netinet\/in.h&gt;\n#include &lt;netinet\/ip.h&gt;\n#include &lt;arpa\/inet.h&gt;\n#include &lt;netdb.h&gt;\n\n#include &quot;phenom\/string.h&quot;\n#include &quot;phenom\/buffer.h&quot;\n#include &quot;phenom\/openssl.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n\/** Represents a socket address *\/\nstruct phenom_sockaddr {\n  sa_family_t family;\n  union {\n    struct sockaddr sa;\n    struct sockaddr_un nix;\n    struct sockaddr_in v4;\n    struct sockaddr_in6 v6;\n  } sa;\n};\ntypedef struct phenom_sockaddr ph_sockaddr_t;\n\n\/** Returns the length of the underlying sockaddr\n *\n * This is useful when passing the sockaddr to lower level\n * socket syscalls\n *\/\nstatic inline int ph_sockaddr_socklen(const ph_sockaddr_t *addr) {\n  switch (addr-&gt;family) {\n    case AF_UNIX:\n      return sizeof(addr-&gt;sa.nix);\n    case AF_INET:\n      return sizeof(addr-&gt;sa.v4);\n    case AF_INET6:\n      return sizeof(addr-&gt;sa.v6);\n    default:\n      return sizeof(addr-&gt;sa.sa);\n  }\n}\n\n\/** Set a sockaddr to the specified IPv4 address string and port.\n * The address string must be an IPv4 address.  This function\n * does *not* perform DNS resolution.  It uses inet_pton() under\n * the covers.\n *\n * If addr == NULL, then sa is initialized to INADDR_ANY\n * *\/\nph_result_t ph_sockaddr_set_v4(ph_sockaddr_t *sa,\n    const char *addr, uint16_t port);\n\n\/** Set a sockaddr to the specified IPv6 address string and port.\n * The address string must be an IPv6 address.  This function\n * does *not* perform DNS resolution.  It uses getaddrinfo() under\n * the covers, with AI_NUMERICHOST|AI_V4MAPPED as flags.\n * The sockaddr may be set to a v4 mapped address depending on\n * the configuration of the system.\n *\n * If addr == NULL, then sa is initialized to in6addr_any\n *\/\nph_result_t ph_sockaddr_set_v6(\n    ph_sockaddr_t *sa,\n    const char *addr,\n    uint16_t port);\n\n\/** Set a sockaddr to the specified UNIX domain address.\n * The address string must be a valid UNIX domain socket path.\n * This function does not support the Linux specific abstract\n * namespace feature, and only supports paths that fit directly\n * in sa-&gt;sa.nix.sun_path.\n *\n * If pathlen == 0, strlen(path) will be assumed.\n *\/\nph_result_t ph_sockaddr_set_unix(\n    ph_sockaddr_t *addr,\n    const char *path,\n    unsigned int pathlen);\n\n\/** Set a sockaddr to the first entry from an addrinfo *\/\nph_result_t ph_sockaddr_set_from_addrinfo(\n    ph_sockaddr_t *addr,\n    struct addrinfo *ai);\n\n\/** Set a sockaddr to the first address from a hostent *\/\nph_result_t ph_sockaddr_set_from_hostent(\n    ph_sockaddr_t *addr,\n    struct hostent *ent);\n\n\/** Set the port number of a sockaddr *\/\nvoid ph_sockaddr_set_port(ph_sockaddr_t *addr, uint16_t port);\n\n\/** Print a human readable version of a sockaddr to a string *\/\nph_result_t ph_sockaddr_print(ph_sockaddr_t *addr,\n    ph_string_t *str, bool want_port);\n\n\/** Set or disable non-blocking mode for a file descriptor *\/\nvoid ph_socket_set_nonblock(ph_socket_t fd, bool enable);\n\n#define PH_SOCK_CLOEXEC  1\n#define PH_SOCK_NONBLOCK 2\n\n\/** Creates a socket that can be used to connect to a sockaddr\n *\n * The socket is created of the appropriate type and the flags\n * are applied:\n *\n * * `PH_SOCK_CLOEXEC` causes the socket to have CLOEXEC set\n * * `PH_SOCK_NONBLOCK` causes the socket to be set to nonblocking mode\n *\n *```\n * ph_socket_t s = ph_socket_for_addr(&amp;addr, SOCK_STREAM,\n *                    PH_SOCK_CLOEXEC|PH_SOCK_NONBLOCK);\n *```\n *\/\nph_socket_t ph_socket_for_addr(const ph_sockaddr_t *addr, int type, int flags);\n\n\/** Handles the results of ph_socket_connect()\n *\n * If successful, `s != -1` and `status == 0`.\n *\n * `addr` points to the address that we attempted to connect.\n *\n * `status` holds the errno value from the connect syscall.\n *\n * `elapsed` holds the amount of time that elapsed since the connect\n * call was started.\n *\n * `arg` passes through the `arg` parameter from ph_socket_connect().\n *\/\ntypedef void (*ph_socket_connect_func)(\n    ph_socket_t s, const ph_sockaddr_t *addr, int status,\n    struct timeval *elapsed, void *arg);\n\n\/** Initiate an async connect() call\n *\n * The results will be delivered to your connect func.\n * In some immediate failure cases, this will be called before\n * ph_socket_connect has returned, but in the common case, this\n * will happen asynchronously from an NBIO thread once the connect\n * call has resolved.\n *\n * The `timeout` parameter allows you to specify an upper bound on\n * the time spent waiting for the connect.  If `timeout` is NULL\n * a implementation dependent default timeout will be used.\n *\/\nvoid ph_socket_connect(ph_socket_t s, const ph_sockaddr_t *addr,\n  struct timeval *timeout, ph_socket_connect_func func, void *arg);\n\nstruct ph_sock;\ntypedef struct ph_sock ph_sock_t;\n\n\/** The socket object callback function *\/\ntypedef void (*ph_sock_func)(ph_sock_t *sock, ph_iomask_t why, void *data);\n\n\/** Called when we complete a handshake *\/\ntypedef void (*ph_sock_openssl_handshake_func)(\n    ph_sock_t *sock, int res);\n\n\/** Socket Object\n *\n * A socket object is a higher level representation of an underlying\n * socket descriptor.\n *\n * It is the preferred way to build higher level socket clients and\n * servers, as it takes the boilerplate of managing read\/write buffers\n * and async dispatch away from you.\n *\n * A socket object is either enabled or disabled; when enabled, the\n * underlying descriptor is managed by the NBIO pool and any pending\n * write data will be sent as and when it is ready to go.  Any pending\n * reads will trigger a wakup and you can use the sock functions to\n * read chunks or delimited records (such as lines).\n *\n * If your client\/server needs to perform some blocking work, you may\n * simply disable the sock until that work is complete.\n *\/\nstruct ph_sock {\n  \/\/ Embedded job so we can participate in NBIO\n  ph_job_t job;\n\n  \/\/ Buffers for output, input\n  ph_bufq_t *wbuf, *rbuf;\n\n  \/\/ The per IO operation timeout duration\n  struct timeval timeout_duration;\n\n  \/\/ A stream for writing to the underlying connection\n  ph_stream_t *conn;\n  \/\/ A stream representation of myself.  Writing bytes into the\n  \/\/ stream causes the data to be buffered in wbuf\n  ph_stream_t *stream;\n\n  \/\/ Dispatcher\n  ph_sock_func callback;\n  bool enabled;\n\n  \/\/ sockname, peername as seen from this host.\n  \/\/ These correspond to the raw connection we see; if we are\n  \/\/ proxied, these are the names of our connection to the proxy.\n  \/\/ If we are not proxied, these are the same as the equivalents below\n  ph_sockaddr_t via_sockname, via_peername;\n  \/\/ sockname, peername as seen from the connected peer\n  \/\/ These are the actual outgoing address endpoints, independent of\n  \/\/ any proxying that may be employed\n  ph_sockaddr_t sockname, peername;\n\n  \/\/ If we&#039;ve switched up to SSL, holds our SSL context\n  SSL *ssl;\n  ph_stream_t *ssl_stream;\n  ph_sock_openssl_handshake_func handshake_cb;\n  ph_bufq_t *sslwbuf;\n  \/\/ Whether we should free the associated SSL_CTX on destruction.\n  \/\/ This defaults to true for backwards compatibility.\n  \/\/ If you&#039;re building SSL enabled listeners, you probably want to keep\n  \/\/ a global SSL_CTX and set this to false.  For clients, it is often\n  \/\/ easier to leave this set to true.\n  bool free_ssl_ctx;\n};\n\n\/** Create a new sock object from a socket descriptor\n *\n * Creates and initialize a socket object using the specified descriptor,\n * sockname and peername.\n *\/\nph_sock_t *ph_sock_new_from_socket(ph_socket_t s, const ph_sockaddr_t *sockname,\n  const ph_sockaddr_t *peername);\n\n\/** Enable or disable IO dispatching for a socket object\n *\n * While enabled, the sock will trigger callbacks when it is readable\/writable\n * or timed out.  While disabled, none of these conditions will trigger.\n *\/\nvoid ph_sock_enable(ph_sock_t *sock, bool enable);\n\n\/** Wakeup the socket object\n *\n * Queues an PH_IOMASK_WAKEUP to the sock.  This is primarily useful in cases\n * where some asynchronous processing has completed and you wish to ping the\n * sock job so that it can consume the results.\n *\n * Delegates to ph_job_wakeup() and can fail for the same reasons as that\n * function.\n *\/\nph_result_t ph_sock_wakeup(ph_sock_t *sock);\n\n\/** Release all resources associated with a socket object\n *\n * Implicitly disables the socket.\n *\/\nvoid ph_sock_free(ph_sock_t *sock);\n\n\/** Read exactly the specified number of bytes\n *\n * Returns a buffer containing the requested number of bytes, or NULL if they\n * are not available.\n *\n * Never returns a partial read.\n *\/\nph_buf_t *ph_sock_read_bytes_exact(ph_sock_t *sock, uint64_t len);\n\n\n\/** Read a delimited record\n *\n * Search for the delimiter in the buffer; if found, returns a buffer containing\n * the record and its delimiter text.\n *\/\nph_buf_t *ph_sock_read_record(ph_sock_t *sock, const char *delim,\n    uint32_t delim_len);\n\n\/** Read a CRLF delimited line\n *\n * Search for the canonical CRLF in the buffer.  If found, returns a buffer\n * containing the line and its CRLF delimiter.\n *\/\nph_buf_t *ph_sock_read_line(ph_sock_t *sock);\n\n#define PH_SOCK_CONNECT_RESOLVE_SYSTEM 0\n\n\/\/ Succeeded\n#define PH_SOCK_CONNECT_SUCCESS  0\n\/\/ Failed; errcode per gai_strerror\n#define PH_SOCK_CONNECT_GAI_ERR  1\n\/\/ Failed; errcode per strerror\n#define PH_SOCK_CONNECT_ERRNO    3\n\n\/** Indicates the results of an async sock connect\n *\n * If successful, `sock` will be non-NULL and `overall_status` will be set\n * to `PH_SOCK_CONNECT_SUCCESS`.\n *\n * On failure `overall_status` will be set to one of `PH_SOCK_CONNECT_GAI_ERR`\n * or `PH_SOCK_CONNECT_ERRNO` to indicate how to\n * interpret the `errcode` parameter; they indicate that the errcode can be\n * rendered to human readable form via gai_strerror(), ares_strerror() or strerror()\n * respectively.\n *\n * `addr` may be NULL.  If it is not NULL, it holds the address that we attempted\n * to connect to.  It may be set if we didn&#039;t successfully connect.\n *\n * `elapsed` holds the amount of time that has elapsed since we attempted to initiate\n * the connection.\n *\n * `arg` passes through the arg parameter from ph_sock_resolve_and_connect().\n *\/\ntypedef void (*ph_sock_connect_func)(\n    ph_sock_t *sock, int overall_status, int errcode,\n    const ph_sockaddr_t *addr,\n    struct timeval *elapsed, void *arg);\n\n\/** Given a name and port, resolve and connect a socket object to it\n *\n * This convenience function resolves the name using the specified resolver\n * (`PH_SOCK_CONNECT_RESOLVE_SYSTEM` for getaddrinfo)\n * and attempts to connect to the first address resolved.\n *\n * Success or failure is communicated to your ph_sock_connect_func.\n *\n * `timeout` specifies an upper bound on the connection attempt.  If left as NULL,\n * a default value will be used.\n *\/\nvoid ph_sock_resolve_and_connect(const char *name, uint16_t port,\n    struct timeval *timeout, int resolver, ph_sock_connect_func func,\n    void *arg);\n\n#define PH_SOCK_SHUT_RD   0\n#define PH_SOCK_SHUT_WR   1\n#define PH_SOCK_SHUT_RDWR 2\n\n\/** Perform a shutdown operation on a socket object *\/\nstatic inline int ph_sock_shutdown(ph_sock_t *sock, int how) {\n  return shutdown(sock-&gt;job.fd, how);\n}\n\n\/** Enable SSL for the sock\n *\n * Configures the sock to act as an SSL client or server.\n *\n * This will amend the struct to reference SSL variants of the\n * streams and set the session to act as an SSL client or server,\n * depending on the value of the `is_client` parameter.\n *\n * This puts the socket into a pending connect or accept state;\n * the socket will work to satisfy this state before dispatching\n * any further calls to the sock callback function.\n *\n * Once the handshake is complete, the dispatcher will call\n * handshake_cb with the result of the completed SSL_do_handshake()\n * function call.\n *\n * You may use this opportunity to perform additional validation\n * of the session.\n *\n * You must supply the SSL object for use by this function and ensure\n * that it is correctly configured (certificates and keys loaded, ciphers\n * selected and so on).\n *\/\nvoid ph_sock_openssl_enable(ph_sock_t *sock, SSL *ssl,\n    bool is_client, ph_sock_openssl_handshake_func handshake_cb);\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "stream": {
        "name": "stream",
        "title": "stream",
        "content": "\n# Streams\n\nlibPhenom provides a portable layer over streaming IO\n\n### struct ph_stream\n\n```c\nstruct ph_stream {\n  const struct ph_stream_funcs *funcs;\n```\n\n\n*Represents a stream*\n\n\nStreams maintain a buffer for read\/write operations.\n\n### ph_stm_read\n\n```c\nbool ph_stm_read(ph_stream_t *stm, void *buf,\n    uint64_t count, uint64_t *nread);\n```\n\n\n*Reads data into the provided memory buffer*\n\n\nReturns true and sets nread to 0 on EOF.\n\nReturns false on error. errno is set accordingly, and ph_stm_errno() can\nalso be used to access that value.\n\nOtherwise stores the number of bytes that were read into nread\nand returns true.\n\n### ph_stm_readahead\n\n```c\nbool ph_stm_readahead(ph_stream_t *stm, uint64_t count);\n```\n\n\n*Requests pre-fetching of data into the read buffer*\n\n\nSignals an intent to read `count` bytes of data. If the read buffer\nalready contains >= `count` bytes of data, returns true immediately.\n\nIf there is no available buffer space (or the stream is unbuffered),\nreturns true immediately.\n\nOtherwise, will attempt to fill the available buffer space.\nReturns false if there was an error performing the underlying read, sets\nerrno accordingly and makes the error code available via ph_stm_errno().\n\nOn a successful read, returns true.\n\nNote that `count` is only used as a hint as to whether we need to issue\na read call; it doesn't influence how much data we read.  If the buffer\nsize is smaller than `count`, we can only fill the available buffer size.\n\n### ph_stm_write\n\n```c\nbool ph_stm_write(ph_stream_t *stm, const void *buf,\n    uint64_t count, uint64_t *nwrote);\n```\n\n\n*Writes data from the provided memory buffer*\n\n\nReturns false on error. errno is set accordingly, and ph_stm_errno() can\nalso be used to access that value.\n\nOn success, returns true and stores the number of bytes that were written,\nwhich may be less than requested due to constraints on buffer space or\nsignal interruption, into nwrote.\n\n### ph_stm_writev\n\n```c\nbool ph_stm_writev(ph_stream_t *stm, const struct iovec *iov,\n    int iovcnt, uint64_t *nwrote);\n```\n\n\n*Writes data via scatter-gather interface*\n\n\nReturns false on error. errno is set accordingly, and ph_stm_errno() can\nalso be used to access that value.\n\nOn success, returns true and stores the number of bytes that were written,\nwhich may be less than requested due to constraints on buffer space or\nsignal interruption, into nwrote.\n\n### ph_stm_vprintf\n\n```c\nint ph_stm_vprintf(ph_stream_t *stm, const char *fmt, va_list ap);\n```\n\n\n*Formatted print to a stream.*\n\n\nuses ph_vprintf_core().  Returns true on success, false on error.\nStores the number of bytes that were written into nwrote.\n\n### ph_stm_printf\n\n```c\nint ph_stm_printf(ph_stream_t *stm, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n```\n\n\n*Formatted print to a stream.*\n\n\nuses ph_vprintf_core()\n\n### ph_stm_flush\n\n```c\nbool ph_stm_flush(ph_stream_t *stm);\n```\n\n\n*Flush buffers*\n\n\n### ph_stm_seek\n\n```c\nbool ph_stm_seek(ph_stream_t *stm, int64_t delta, int whence, uint64_t *newpos);\n```\n\n\n*Reposition the file offset*\n\n\nEquivalent to lseek(2) but with an unambiguous function signature.\nThe whence values are taken from the system\nwhence values and passed to the underlying implementation.\n\nThe new file position is stored into *newpos unless it is NULL.\nThe return value is 0 on success, -1 on error.\n\n### ph_stm_rewind\n\n```c\nbool ph_stm_rewind(ph_stream_t *stm)\n```\n\n\n*Seek back to the start of a stream*\n\n\n### ph_stm_copy\n\n```c\nbool ph_stm_copy(ph_stream_t *src, ph_stream_t *dest,\n    uint64_t num_bytes, uint64_t *nread, uint64_t *nwrote);\n```\n\n\n*Read data from src and write to dest*\n\n\nReads up to the specified number of bytes from `src` and writes\nthem to `dest`.  If `num_bytes` is the special value\n`PH_STREAM_READ_ALL` then all remaining data from `src` will\nbe read.\n\nReturns `true` on success, which is considered to be that no IO\nerrors except EOF when reading from `src` were encountered, or\n`false` otherwise.\n\nSets `*nread` to the number of bytes read from `src`, unless\n`nread` is NULL.\n\nSets `*nwrote` to the number of bytes successfully written to `dest`,\nunless `nwrote` is NULL.\n\n### ph_stm_close\n\n```c\nbool ph_stm_close(ph_stream_t *stm);\n```\n\n\n*Close the stream and release resources*\n\n\nRequests that the stream be closed.  On success, the stream handle\nis invalidated and should no longer be used.\n\n### ph_stm_errno\n\n```c\nint ph_stm_errno(ph_stream_t *stm)\n```\n\n\n*Returns the errno value from the last error*\n\n\nEach IO operation clears the stored error to 0, setting it again\nonly in case of an IO failure.  Calling ph_stm_errno() will thus\nreturn 0 if there was no prior error, or the errno from the last\nerror condition.\n\n### ph_stm_fd_open\n\n```c\nph_stream_t *ph_stm_fd_open(int fd, int sflags, uint32_t bufsize);\n```\n\n\n*Construct a stream around a pre-existing file descriptor*\n\n\n### ph_stm_file_open\n\n```c\nph_stream_t *ph_stm_file_open(const char *filename, int oflags, int mode);\n```\n\n\n*Open a file stream*\n\n\noflags are passed to the open(2) syscall.\n\n### ph_stm_string_open\n\n```c\nph_stream_t *ph_stm_string_open(ph_string_t *str);\n```\n\n\n*Open a stream over a string object*\n\n\nThe returned string will start at position 0; reads will read the\nstring buffer, hitting EOF when the end of the string is reached.\n\nWrites will replace string bytes at the current position.  If a\nwrite would overflow the string, the overflown portion will be\nappended to the string, provided that the underlying append operation\nsucceeds.\n\nThe stream will add and retain its own reference to the string\nobject that will be released when the stream is closed.\n\n* * *\n\n# Implementation Details\n\nIf you're simply consuming streams, you can stop reading now.\n\n### struct ph_stream_funcs\n\n```c\nstruct ph_stream_funcs {\n  bool (*close)(ph_stream_t *stm);\n```\n\n\n*Defines a stream implementation.*\n\n\nIf any of these return false, it indicates an error.\nThe implementation must set stm->last_err to the corresponding\nerrno value in that case (and only in the failure case).\n\n### ph_stm_make\n\n```c\nph_stream_t *ph_stm_make(const struct ph_stream_funcs *funcs,\n    void *cookie, int sflags, uint32_t bufsize);\n```\n\n\n*Construct a stream.*\n\nIf bufsize is 0, the stream will be unbuffered\n\n### ph_stm_destroy\n\n```c\nvoid ph_stm_destroy(ph_stream_t *stm);\n```\n\n\n*Destruct a stream.*\n\nDoes not call close, forces destruction of the stm.\n",
        "decl_titles": [
            "struct ph_stream",
            "ph_stm_read",
            "ph_stm_readahead",
            "ph_stm_write",
            "ph_stm_writev",
            "ph_stm_vprintf",
            "ph_stm_printf",
            "ph_stm_flush",
            "ph_stm_seek",
            "ph_stm_rewind",
            "ph_stm_copy",
            "ph_stm_close",
            "ph_stm_errno",
            "ph_stm_fd_open",
            "ph_stm_file_open",
            "ph_stm_string_open",
            "struct ph_stream_funcs",
            "ph_stm_make",
            "ph_stm_destroy"
        ],
        "raw_content": "\/*\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_STREAM_H\n#define PHENOM_STREAM_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/string.h&quot;\n#include &quot;phenom\/job.h&quot;\n#include &lt;unistd.h&gt; \/\/ For SEEK_SET\n\n\/**\n * # Streams\n *\n * libPhenom provides a portable layer over streaming IO\n *\/\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_stream;\ntypedef struct ph_stream ph_stream_t;\nstruct ph_stream_funcs;\n\n\/* size of unget buffer *\/\n#define PH_STM_UNGET      8\n\n\/* size of default stream buffer *\/\n#define PH_STM_BUFSIZE    8192\n\n\/* If set in flags, the stream instance must not be freed *\/\n#define PH_STM_FLAG_ONSTACK    1\n\n\/** Represents a stream\n *\n * Streams maintain a buffer for read\/write operations.\n *\/\nstruct ph_stream {\n  const struct ph_stream_funcs *funcs;\n  void *cookie;\n  unsigned flags;\n  pthread_mutex_t lock;\n  \/\/ if data is in the read buffer, these are non-NULL\n  unsigned char *rpos, *rend;\n  \/\/ if data is in the write buffer, these are non-NULL\n  unsigned char *wpos, *wend;\n  unsigned char *wbase;\n  \/\/ associated buffer.  It can be either used in read mode\n  \/\/ or write mode, but not both\n  unsigned char *buf;\n  uint32_t bufsize;\n  int last_err;\n  ph_iomask_t need_mask;\n};\n\n\/** Reads data into the provided memory buffer\n *\n * Returns true and sets nread to 0 on EOF.\n *\n * Returns false on error. errno is set accordingly, and ph_stm_errno() can\n * also be used to access that value.\n *\n * Otherwise stores the number of bytes that were read into nread\n * and returns true.\n *\/\nbool ph_stm_read(ph_stream_t *stm, void *buf,\n    uint64_t count, uint64_t *nread);\n\n\/** Requests pre-fetching of data into the read buffer\n *\n * Signals an intent to read `count` bytes of data. If the read buffer\n * already contains &gt;= `count` bytes of data, returns true immediately.\n *\n * If there is no available buffer space (or the stream is unbuffered),\n * returns true immediately.\n *\n * Otherwise, will attempt to fill the available buffer space.\n * Returns false if there was an error performing the underlying read, sets\n * errno accordingly and makes the error code available via ph_stm_errno().\n *\n * On a successful read, returns true.\n *\n * Note that `count` is only used as a hint as to whether we need to issue\n * a read call; it doesn&#039;t influence how much data we read.  If the buffer\n * size is smaller than `count`, we can only fill the available buffer size.\n *\/\nbool ph_stm_readahead(ph_stream_t *stm, uint64_t count);\n\n\/** Writes data from the provided memory buffer\n *\n * Returns false on error. errno is set accordingly, and ph_stm_errno() can\n * also be used to access that value.\n *\n * On success, returns true and stores the number of bytes that were written,\n * which may be less than requested due to constraints on buffer space or\n * signal interruption, into nwrote.\n *\/\nbool ph_stm_write(ph_stream_t *stm, const void *buf,\n    uint64_t count, uint64_t *nwrote);\n\n\/** Writes data via scatter-gather interface\n *\n * Returns false on error. errno is set accordingly, and ph_stm_errno() can\n * also be used to access that value.\n *\n * On success, returns true and stores the number of bytes that were written,\n * which may be less than requested due to constraints on buffer space or\n * signal interruption, into nwrote.\n *\/\nbool ph_stm_writev(ph_stream_t *stm, const struct iovec *iov,\n    int iovcnt, uint64_t *nwrote);\n\n\/** Formatted print to a stream.\n *\n * uses ph_vprintf_core().  Returns true on success, false on error.\n * Stores the number of bytes that were written into nwrote.\n *\/\nint ph_stm_vprintf(ph_stream_t *stm, const char *fmt, va_list ap);\n\n\/** Formatted print to a stream.\n *\n * uses ph_vprintf_core()\n *\/\nint ph_stm_printf(ph_stream_t *stm, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n\n\/** Flush buffers *\/\nbool ph_stm_flush(ph_stream_t *stm);\n\n\/** Reposition the file offset\n *\n * Equivalent to lseek(2) but with an unambiguous function signature.\n * The whence values are taken from the system\n * whence values and passed to the underlying implementation.\n *\n * The new file position is stored into *newpos unless it is NULL.\n * The return value is 0 on success, -1 on error.\n *\/\nbool ph_stm_seek(ph_stream_t *stm, int64_t delta, int whence, uint64_t *newpos);\n\n\/** Seek back to the start of a stream\n *\/\nstatic inline bool ph_stm_rewind(ph_stream_t *stm) {\n  return ph_stm_seek(stm, 0, SEEK_SET, NULL);\n}\n\n\/** Read data from src and write to dest\n *\n * Reads up to the specified number of bytes from `src` and writes\n * them to `dest`.  If `num_bytes` is the special value\n * `PH_STREAM_READ_ALL` then all remaining data from `src` will\n * be read.\n *\n * Returns `true` on success, which is considered to be that no IO\n * errors except EOF when reading from `src` were encountered, or\n * `false` otherwise.\n *\n * Sets `*nread` to the number of bytes read from `src`, unless\n * `nread` is NULL.\n *\n * Sets `*nwrote` to the number of bytes successfully written to `dest`,\n * unless `nwrote` is NULL.\n *\/\nbool ph_stm_copy(ph_stream_t *src, ph_stream_t *dest,\n    uint64_t num_bytes, uint64_t *nread, uint64_t *nwrote);\n\n#define PH_STREAM_READ_ALL UINT64_MAX\n\n\/** Close the stream and release resources\n *\n * Requests that the stream be closed.  On success, the stream handle\n * is invalidated and should no longer be used.\n *\/\nbool ph_stm_close(ph_stream_t *stm);\n\n\/** Returns the errno value from the last error\n *\n * Each IO operation clears the stored error to 0, setting it again\n * only in case of an IO failure.  Calling ph_stm_errno() will thus\n * return 0 if there was no prior error, or the errno from the last\n * error condition.\n *\/\nstatic inline int ph_stm_errno(ph_stream_t *stm) {\n  return stm-&gt;last_err;\n}\n\n\/** Construct a stream around a pre-existing file descriptor *\/\nph_stream_t *ph_stm_fd_open(int fd, int sflags, uint32_t bufsize);\n\nvoid ph_stm_lock(ph_stream_t *stm);\nvoid ph_stm_unlock(ph_stream_t *stm);\n\n\/** Open a file stream\n *\n * oflags are passed to the open(2) syscall.\n *\/\nph_stream_t *ph_stm_file_open(const char *filename, int oflags, int mode);\n\n\/** Open a stream over a string object\n *\n * The returned string will start at position 0; reads will read the\n * string buffer, hitting EOF when the end of the string is reached.\n *\n * Writes will replace string bytes at the current position.  If a\n * write would overflow the string, the overflown portion will be\n * appended to the string, provided that the underlying append operation\n * succeeds.\n *\n * The stream will add and retain its own reference to the string\n * object that will be released when the stream is closed.\n *\/\nph_stream_t *ph_stm_string_open(ph_string_t *str);\n\n\/**\n * # Implementation Details\n *\n * If you&#039;re simply consuming streams, you can stop reading now.\n *\/\n\n\/** Defines a stream implementation.\n *\n * If any of these return false, it indicates an error.\n * The implementation must set stm-&gt;last_err to the corresponding\n * errno value in that case (and only in the failure case).\n *\/\nstruct ph_stream_funcs {\n  bool (*close)(ph_stream_t *stm);\n  bool (*readv)(ph_stream_t *stm, const struct iovec *iov,\n      int iovcnt, uint64_t *nread);\n  bool (*writev)(ph_stream_t *stm, const struct iovec *iov,\n      int iovcnt, uint64_t *nwrote);\n  bool (*seek)(ph_stream_t *stm, int64_t delta,\n      int whence, uint64_t *newpos);\n};\n\n\/** Construct a stream.\n * If bufsize is 0, the stream will be unbuffered\n *\/\nph_stream_t *ph_stm_make(const struct ph_stream_funcs *funcs,\n    void *cookie, int sflags, uint32_t bufsize);\n\n\/** Destruct a stream.\n * Does not call close, forces destruction of the stm.\n *\/\nvoid ph_stm_destroy(ph_stream_t *stm);\n\n\/* functions that operate on a file descriptor *\/\nextern struct ph_stream_funcs ph_stm_funcs_fd;\n\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "string": {
        "name": "string",
        "title": "string",
        "content": "\n# Strings\n\nC strings are somewhat bare, so we provide some helpers that aim to\nassist with:\n\n* avoiding heap allocations where possible\n* tracking heap allocations when not avoidable\n* safely manage string expansion and growth\n\n# Stack-based strings\n\nTo avoid touching the allocator in hot code paths, it is desirable\nto construct and operate on strings local to the stack.  There are\ntwo special kinds of string that can aid you in this case.\n\n## Statically allocated fixed size buffers\n\nIf you know that you will never exceed a maximum length for your string\ndata in a given function, you can declare a stack based string buffer\nlike this:\n\n```\nvoid myfunc(void) {\n   PH_STRING_DECLARE_STACK(mystr, 128);\n\n   ph_string_printf(&mystr, \"Hello %s\", \"world\");\n}\n```\n\nThe above creates a string that can hold up to 128 bytes of text.\nAttempting to print beyond the end of it will be silently ignored.\n\nSince the buffer resides on the stack, it doesn't require any\ncleanup.\n\n## Statically allocated growable buffers\n\nIf you know that the common case for your function is that the data\nwill typically fit within a reasonably small threshold but you also\nneed to be able to deal with occasional values that exceed it,\nyou can declare a stack based string buffer that will be promoted\nto a heap allocated string if the size overflows:\n\n```\nvoid myfunc(void) {\n   ph_memtype_t my_memtype; \/\/ you need to arrange for this to be valid\n   PH_STRING_DECLARE_GROW(mystr, 128, my_memtype);\n\n   ph_string_printf(&mystr, \"Hello %s\", \"world\");\n\n   ph_string_delref(&mystr);\n}\n```\n\nSince the string may end up referencing heap allocated memory, we\n*MUST* call `ph_string_delref` before the stack unwinds so that we\ncan avoid a memory leak.\n\n# Static constant strings\n\nSometimes you'll want to define a string to represent a constant c-string\nvalue in your code, for instance, as a fall back for a hash table key.\nYou may use `PH_STRING_DECLARE_STATIC` as a shortcut for this case; it\ncan only be used with a string literal parameter; this is to avoid calling\nstrlen at runtime:\n\n```\nvoid myfunc(void) {\n  PH_STRING_DECLARE_STATIC(mystr, \"Hello world\");\n}\n```\n\n```COUNTEREXAMPLE\nvoid myfunc(const char *str) {\n  PH_STRING_DECLARE_STATIC(mystr, str); \/\/ BAD: will get the wrong size\n}\n```\n\nIf you want\/need to use it with a variable (not a string literal), then you\ncan and should use `PH_STRING_DECLARE_STATIC_CSTR` instead:\n\n```\nvoid myfunc(const char *str) {\n  PH_STRING_DECLARE_STATIC_CSTR(mystr, str);\n}\n```\n\n# Embedding in structs\n\nIt is sometimes desirable to embed an instance inside another structure.\nTo facilitate this, you may use the following pattern:\n\n```\nstruct mystruct {\n  char mybuf[128];\n  ph_string_t mystr;\n};\n\nstruct mystruct *myfunc(void) {\n  struct mystruct *s = calloc(1, sizeof(*s));\n\n  ph_string_init_claim(&s->mystr, PH_STRING_STATIC,\n      &s->mybuf, 0, sizeof(s->mybuf));\n\n  return s;\n}\n\nvoid myfreefunc(struct mystruct *s) {\n   ph_string_delref(&s->mystr);\n   free(s);\n}\n```\n\nYou may substitute `PH_STRING_STATIC` with `PH_STRING_GROW_MT(mymemtype)`\nto configure the string to switch to using heap allocated buffers using\nyour specified memtype if they overflow the static size.\n\n# Referencing in printf functions\n\n```none\n `Ps%p -   replaced by the contents of the ph_string_t* argument\n `Ps%d%p - replaced by the first n bytes specified by the integer\n           argument of the ph_string_t* argument.\n```\n\n\n### ph_string_init_claim\n\n```c\nvoid ph_string_init_claim(ph_string_t *str,\n    ph_memtype_t mt, char *buf, uint32_t len, uint32_t size);\n```\n\n\n*Initialize a string from a static or unmanaged buffer*\n\n\nSimilar to `ph_string_make_claim` except that the string\nis either a stack based string or is embedded in some other\nstorage.\n\nWhen the final reference on such a string is released,\nonly the buffers that it points to will be released, not\nthe string object itself.\n\n### ph_string_init_slice\n\n```c\nvoid ph_string_init_slice(ph_string_t *str,\n    ph_string_t *slice, uint32_t start, uint32_t len);\n```\n\n\n*Initialize a string as a slice over another string.*\n\n\nMaintains a reference to the sliced string that is released\nwhen this one is released.\n\n### ph_string_make_slice\n\n```c\nph_string_t *ph_string_make_slice(ph_string_t *str,\n    uint32_t start, uint32_t len);\n```\n\n\n*Make a new string instance by slicing over another string.*\n\n\nMaintains a reference to the sliced string that is released\nwhen this one is released.\n\n### ph_string_make_claim\n\n```c\nph_string_t *ph_string_make_claim(ph_memtype_t mt,\n    char *buf, uint32_t len, uint32_t size);\n```\n\n\n*Make a new string instance from a source buffer*\n\n\nAllocates a new string object that claims ownership\nof the provided buffer.\n\nThe returned string object has a single reference;\ncall ph_string_delref() on it to destroy it.  At that\ntime, the buffer it claimed will be freed against the\nthe specified memtype.\n\nIf the memtype is PH_STRING_STATIC, the buffer will\nbe referenced but not freed or grown by the string functions.\n\n### ph_string_make_copy\n\n```c\nph_string_t *ph_string_make_copy(ph_memtype_t mt,\n    const char *buf, uint32_t len, uint32_t size);\n```\n\n\n*Make a new string instance by copying a buffer*\n\n\nA convenience function that is logically equivalent to allocating\na buffer of `size` bytes, copying `len` bytes from `buf` into it,\nand then claiming that buffer via ph_string_make_claim\n\n### ph_string_make_cstr\n\n```c\nph_string_t *ph_string_make_cstr(ph_memtype_t mt, const char *str);\n```\n\n\n*Make a new string from a C-String*\n\n\n### ph_string_make_empty\n\n```c\nph_string_t *ph_string_make_empty(ph_memtype_t mt,\n    uint32_t size);\n```\n\n\n*Make a new empty string instance*\n\n\nThe string will be configured to grow on demand, using\nthe specified memtype.\n\nThe string will allocate `size` buffer to initialize the\nstring.\n\n### ph_string_addref\n\n```c\nvoid ph_string_addref(ph_string_t *str)\n```\n\n\n*Add a reference to a string*\n\n\n### ph_string_delref\n\n```c\nvoid ph_string_delref(ph_string_t *str);\n```\n\n\n*Release a reference to a string*\n\n\nWhen the final reference is released, the string is\ndestroyed and its resources released.\n\n### ph_string_append_buf\n\n```c\nph_result_t ph_string_append_buf(ph_string_t *str,\n    const char *buf, uint32_t len);\n```\n\n\n*Append a memory buffer to a ph_string_t instance*\n\n\n### ph_string_append_str\n\n```c\nph_result_t ph_string_append_str(ph_string_t *target,\n    ph_string_t *str)\n```\n\n\n*Append a string to a string*\n\n\nThe contents of `str` are appended to `target`\n\n### ph_string_append_cstr\n\n```c\nph_result_t ph_string_append_cstr(\n    ph_string_t *str, const char *cstr);\n```\n\n\n*Append a C-string to a ph_string_t instance*\n\n\n### ph_string_append_utf16_as_utf8\n\n```c\nph_result_t ph_string_append_utf16_as_utf8(\n    ph_string_t *str, int32_t *codepoints, uint32_t numpoints,\n    uint32_t *bytes);\n```\n\n\n*Append a series of UTF-16 code points to a string and encode as UTF-8*\n\n\n* `codepoints` points to a buffer of code points\n* `numpoints` specifies the number of code points\n* `bytes` if not NULL, receives the number of UTF-8 bytes that were\n  appended to the string\n\n### ph_string_iterate_utf8_as_utf16\n\n```c\nph_result_t ph_string_iterate_utf8_as_utf16(\n    ph_string_t *str, uint32_t *offset, int32_t *codepoint);\n```\n\n\n*Iterate a sequence of UTF-8 characters, returning UTF-16 codepoints*\n\n\nThis function implements an iterator that knows how to decode UTF-8\nencoded multibyte text into UTF-16 code points.\n\nTo begin iterating, set `offset` to the starting offset of the UTF-8\ntext.  This offset is measured in bytes from the start of the data\nin the string.\n\nUTF-8 bytes will be decoded from that position and a UTF-16 codepoint\nwill be stored into `*codepoint`.  `*offset` will be updated so that\nit holds the offset of the next UTF-8 byte.\n\nIf a UTF-16 byte was successfully decoded, returns `PH_OK`.\nIf a partial or invalid UTF-8 sequence was detected, returns `PH_ERR`.\nIf the end of the string was reached, returns `PH_DONE`.\n\n```\nuint32_t off = 0;\nint32_t cp;\n\nwhile (ph_string_iterate_utf8_as_utf16(str, &off, &cp) == PH_OK) {\n  \/\/ got a codepoint in cp\n}\n```\n\n### ph_string_is_valid_utf8\n\n```c\nbool ph_string_is_valid_utf8(ph_string_t *str);\n```\n\n\n*Returns true if the string is valid UTF-8*\n\n\nChecks the content of the string buffer, returns true if\nwe can iterate the length of the string and produce a valid\nseries of UTF-16 codepoints from it, or false otherwise.\n\n### ph_string_len\n\n```c\nuint32_t ph_string_len(const ph_string_t *str)\n```\n\n\n*Returns the length of the string contents, in bytes*\n\n\n### ph_string_reset\n\n```c\nvoid ph_string_reset(ph_string_t *str)\n```\n\n\n*Resets the string length to zero*\n\n\nSets the length to zero, effectively clearly the string\ncontents and rewinding the append position to the start\nof the string.\n\nThis is useful in cases where you desire to reuse the string\nbuffer and avoid additional heap allocations.\n\n### ph_string_equal\n\n```c\nbool ph_string_equal(const ph_string_t *a, const ph_string_t *b);\n```\n\n\n*Compare the value of two strings for equality*\n\n\nReturn true if the strings are equal based on a raw binary\ncomparison of the string buffers.  This function ignores locale\nand other nuances of multi-byte encodings.\n\n### ph_string_equal_caseless\n\n```c\nbool ph_string_equal_caseless(const ph_string_t *a, const ph_string_t *b);\n```\n\n\n*Compare the value of two strings for equality, case insensitive*\n\n\nReturn true the strings compare equal, with each byte passed\nto the tolower() function.  Aside form lower casing each byte,\nthis function ignores locale and other nuances of multi-byte\nencodings.\n\n### ph_string_equal_cstr\n\n```c\nbool ph_string_equal_cstr(ph_string_t *a, const char *b);\n```\n\n\n*Compare the value of the string against a C-string for equality*\n\n\n### ph_string_compare\n\n```c\nint ph_string_compare(const ph_string_t *a, const ph_string_t *b);\n```\n\n\n*Compare the value of two strings*\n\n\nCompares two strings, returning an integer value less than\nzero if `a` is considered less than `b`, 0 if `a` == `b` or\ngreater than zero if `a` is considered greater than `b`.\n\nThis function ignores locale and other nuances of multi-byte encodings.\n\n### ph_string_vprintf\n\n```c\nint ph_string_vprintf(ph_string_t *a, const char *fmt, va_list ap);\n```\n\n\n*Formatted print to string*\n\n\n### ph_string_printf\n\n```c\nint ph_string_printf(ph_string_t *a, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n```\n\n\n*Formatted print to string*\n\n\nUses ph_vprintf_core()\n\n### ph_string_make_printf\n\n```c\nph_string_t *ph_string_make_printf(ph_memtype_t mt, uint32_t size,\n    const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 3, 4)))\n#endif\n  ;\n```\n\n\n*Make a string from a formatted string*\n\n\n### PH_STRING_DECLARE_AND_COPY_CSTR\n\n```c\nvoid PH_STRING_DECLARE_AND_COPY_CSTR(localvarname, ph_string_t *str);\n```\n\n\n*Copy a NUL-terminated C-string from a ph_string to a stack buffer*\n\n\nSince ph_string_t does not maintain C-string NUL termination,\nand many library functions require a C-string representation,\nthere will be times where you need to get one.\n\nThis macro declares a local variable named `localvarname` using\nthe C99 variable sized array feature to create a stack buffer,\nand copies the string data to the stack buffer and null terminates\nthe buffer.\n\nUsage:\n\n```\nvoid open_a_file(ph_string_t *name) {\n  PH_STRING_DECLARE_AND_COPY_CSTR(filename, name);\n  int fd = open(filename, O_RDONLY);\n}\n```\n\n### PH_STRING_DECLARE_CSTR_AVOID_COPY\n\n```c\nvoid PH_STRING_DECLARE_CSTR_AVOID_COPY(localvarname, ph_string_t *str);\n```\n\n\n*Obtain a NUL-terminated C-string pointer from a ph_string*\n\n\nThis macro declares a local `const char *` variable named\n`localvarname` and initializes it to reference a C-string representation\nof the provided `str` parameter.\n\nIf `str` happens to be NUL terminated, or can be safely NUL terminated,\n`localvarname` is set to point to the buffer in `str` and no copying is\nperformed.\n\nIf `str` cannot be NUL terminated, uses the C99 variable sized array\nfeature to create storage on the stack, copies the string data to\nthe stack, NUL-terminates it and sets `localvarname` to reference it.\n\n`localvarname` is a const variable because it may reference the internal\nstring buffer.  `localvarname` should be considered to be invalidated\nby any changes made to the `str`.\n\nUsage:\n\n```\nvoid open_a_file(ph_string_t *name) {\n  PH_STRING_DECLARE_CSTR_AVOID_COPY(filename, name);\n  int fd = open(filename, O_RDONLY);\n}\n```\n\nThis is invalid usage because the string is modified:\n\n```COUNTEREXAMPLE\nvoid do_something(ph_string_t *name) {\n  PH_STRING_DECLARE_CSTR_AVOID_COPY(namecstr, name);\n  ph_string_append_cstr(name, \"woot\");\n  \/\/ WRONG! because the append above means that namecstr was invalidated\n  \/\/ and is no longer safe to use\n  ph_fd_printf(STDOUT_FILENO, \"namecstr is %s\", namecstr);\n}\n```\n",
        "decl_titles": [
            "ph_string_init_claim",
            "ph_string_init_slice",
            "ph_string_make_slice",
            "ph_string_make_claim",
            "ph_string_make_copy",
            "ph_string_make_cstr",
            "ph_string_make_empty",
            "ph_string_addref",
            "ph_string_delref",
            "ph_string_append_buf",
            "ph_string_append_str",
            "ph_string_append_cstr",
            "ph_string_append_utf16_as_utf8",
            "ph_string_iterate_utf8_as_utf16",
            "ph_string_is_valid_utf8",
            "ph_string_len",
            "ph_string_reset",
            "ph_string_equal",
            "ph_string_equal_caseless",
            "ph_string_equal_cstr",
            "ph_string_compare",
            "ph_string_vprintf",
            "ph_string_printf",
            "ph_string_make_printf",
            "PH_STRING_DECLARE_AND_COPY_CSTR",
            "PH_STRING_DECLARE_CSTR_AVOID_COPY"
        ],
        "raw_content": "\/*\n * Copyright 2013-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_STRING_H\n#define PHENOM_STRING_H\n\n\/**\n * # Strings\n *\n * C strings are somewhat bare, so we provide some helpers that aim to\n * assist with:\n *\n * * avoiding heap allocations where possible\n * * tracking heap allocations when not avoidable\n * * safely manage string expansion and growth\n *\n * # Stack-based strings\n *\n * To avoid touching the allocator in hot code paths, it is desirable\n * to construct and operate on strings local to the stack.  There are\n * two special kinds of string that can aid you in this case.\n *\n * ## Statically allocated fixed size buffers\n *\n * If you know that you will never exceed a maximum length for your string\n * data in a given function, you can declare a stack based string buffer\n * like this:\n *\n * ```\n * void myfunc(void) {\n *    PH_STRING_DECLARE_STACK(mystr, 128);\n *\n *    ph_string_printf(&amp;mystr, &quot;Hello %s&quot;, &quot;world&quot;);\n * }\n * ```\n *\n * The above creates a string that can hold up to 128 bytes of text.\n * Attempting to print beyond the end of it will be silently ignored.\n *\n * Since the buffer resides on the stack, it doesn&#039;t require any\n * cleanup.\n *\n * ## Statically allocated growable buffers\n *\n * If you know that the common case for your function is that the data\n * will typically fit within a reasonably small threshold but you also\n * need to be able to deal with occasional values that exceed it,\n * you can declare a stack based string buffer that will be promoted\n * to a heap allocated string if the size overflows:\n *\n * ```\n * void myfunc(void) {\n *    ph_memtype_t my_memtype; \/\/ you need to arrange for this to be valid\n *    PH_STRING_DECLARE_GROW(mystr, 128, my_memtype);\n *\n *    ph_string_printf(&amp;mystr, &quot;Hello %s&quot;, &quot;world&quot;);\n *\n *    ph_string_delref(&amp;mystr);\n * }\n * ```\n *\n * Since the string may end up referencing heap allocated memory, we\n * *MUST* call `ph_string_delref` before the stack unwinds so that we\n * can avoid a memory leak.\n *\n * # Static constant strings\n *\n * Sometimes you&#039;ll want to define a string to represent a constant c-string\n * value in your code, for instance, as a fall back for a hash table key.\n * You may use `PH_STRING_DECLARE_STATIC` as a shortcut for this case; it\n * can only be used with a string literal parameter; this is to avoid calling\n * strlen at runtime:\n *\n * ```\n * void myfunc(void) {\n *   PH_STRING_DECLARE_STATIC(mystr, &quot;Hello world&quot;);\n * }\n * ```\n *\n * ```COUNTEREXAMPLE\n * void myfunc(const char *str) {\n *   PH_STRING_DECLARE_STATIC(mystr, str); \/\/ BAD: will get the wrong size\n * }\n * ```\n *\n * If you want\/need to use it with a variable (not a string literal), then you\n * can and should use `PH_STRING_DECLARE_STATIC_CSTR` instead:\n *\n * ```\n * void myfunc(const char *str) {\n *   PH_STRING_DECLARE_STATIC_CSTR(mystr, str);\n * }\n * ```\n *\n * # Embedding in structs\n *\n * It is sometimes desirable to embed an instance inside another structure.\n * To facilitate this, you may use the following pattern:\n *\n * ```\n * struct mystruct {\n *   char mybuf[128];\n *   ph_string_t mystr;\n * };\n *\n * struct mystruct *myfunc(void) {\n *   struct mystruct *s = calloc(1, sizeof(*s));\n *\n *   ph_string_init_claim(&amp;s-&gt;mystr, PH_STRING_STATIC,\n *       &amp;s-&gt;mybuf, 0, sizeof(s-&gt;mybuf));\n *\n *   return s;\n * }\n *\n * void myfreefunc(struct mystruct *s) {\n *    ph_string_delref(&amp;s-&gt;mystr);\n *    free(s);\n * }\n * ```\n *\n * You may substitute `PH_STRING_STATIC` with `PH_STRING_GROW_MT(mymemtype)`\n * to configure the string to switch to using heap allocated buffers using\n * your specified memtype if they overflow the static size.\n *\n * # Referencing in printf functions\n *\n * ```none\n *  `Ps%p -   replaced by the contents of the ph_string_t* argument\n *  `Ps%d%p - replaced by the first n bytes specified by the integer\n *            argument of the ph_string_t* argument.\n * ```\n *\n *\/\n\n#include &quot;phenom\/refcnt.h&quot;\n#include &quot;phenom\/memory.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_string;\ntypedef struct ph_string ph_string_t;\n\nstruct ph_string {\n  ph_refcnt_t ref;\n  ph_memtype_t mt;\n  uint32_t len, alloc;\n  char *buf;\n  ph_string_t *slice;\n  bool onstack;\n};\n\n#define PH_STRING_STATIC       PH_MEMTYPE_INVALID\n#define PH_STRING_GROW_MT(mt)  -(mt)\n\n#define PH_STRING_DECLARE_GROW(name, size, mt) \\\n  char _str_buf_grow_##name[size]; \\\n  ph_string_t name = { 1, PH_STRING_GROW_MT(mt), 0, size, \\\n    _str_buf_grow_##name, 0, true }\n\n#define PH_STRING_DECLARE_STACK(name, size) \\\n  char _str_buf_static_##name[size]; \\\n  ph_string_t name = { 1, PH_STRING_STATIC, 0, size, \\\n    _str_buf_static_##name, 0, true }\n\n#define PH_STRING_DECLARE_STATIC(name, cstr) \\\n  ph_string_t name = { 1, PH_STRING_STATIC, sizeof(cstr)-1, \\\n    sizeof(cstr), (char*)cstr, 0, true }\n\n#define PH_STRING_DECLARE_STATIC_CSTR_INNER(name, cstr, len) \\\n  uint32_t len = strlen(cstr); \\\n  ph_string_t name = { 1, PH_STRING_STATIC, len, \\\n    len + 1, (char*)cstr, 0, true }\n#define PH_STRING_DECLARE_STATIC_CSTR(name, cstr) \\\n  PH_STRING_DECLARE_STATIC_CSTR_INNER(name, cstr, ph_defs_gen_symbol(len))\n\n\/** Initialize a string from a static or unmanaged buffer\n *\n * Similar to `ph_string_make_claim` except that the string\n * is either a stack based string or is embedded in some other\n * storage.\n *\n * When the final reference on such a string is released,\n * only the buffers that it points to will be released, not\n * the string object itself.\n *\/\nvoid ph_string_init_claim(ph_string_t *str,\n    ph_memtype_t mt, char *buf, uint32_t len, uint32_t size);\n\n\/** Initialize a string as a slice over another string.\n *\n * Maintains a reference to the sliced string that is released\n * when this one is released.\n *\/\nvoid ph_string_init_slice(ph_string_t *str,\n    ph_string_t *slice, uint32_t start, uint32_t len);\n\n\/** Make a new string instance by slicing over another string.\n *\n * Maintains a reference to the sliced string that is released\n * when this one is released.\n *\/\nph_string_t *ph_string_make_slice(ph_string_t *str,\n    uint32_t start, uint32_t len);\n\n\/** Make a new string instance from a source buffer\n *\n * Allocates a new string object that claims ownership\n * of the provided buffer.\n *\n * The returned string object has a single reference;\n * call ph_string_delref() on it to destroy it.  At that\n * time, the buffer it claimed will be freed against the\n * the specified memtype.\n *\n * If the memtype is PH_STRING_STATIC, the buffer will\n * be referenced but not freed or grown by the string functions.\n *\/\nph_string_t *ph_string_make_claim(ph_memtype_t mt,\n    char *buf, uint32_t len, uint32_t size);\n\n\/** Make a new string instance by copying a buffer\n *\n * A convenience function that is logically equivalent to allocating\n * a buffer of `size` bytes, copying `len` bytes from `buf` into it,\n * and then claiming that buffer via ph_string_make_claim\n *\/\nph_string_t *ph_string_make_copy(ph_memtype_t mt,\n    const char *buf, uint32_t len, uint32_t size);\n\n\/** Make a new string from a C-String\n *\/\nph_string_t *ph_string_make_cstr(ph_memtype_t mt, const char *str);\n\n\/** Make a new empty string instance\n *\n * The string will be configured to grow on demand, using\n * the specified memtype.\n *\n * The string will allocate `size` buffer to initialize the\n * string.\n *\/\nph_string_t *ph_string_make_empty(ph_memtype_t mt,\n    uint32_t size);\n\n\/** Add a reference to a string\n *\/\nstatic inline void ph_string_addref(ph_string_t *str)\n{\n  ph_refcnt_add(&amp;str-&gt;ref);\n}\n\n\/** Release a reference to a string\n *\n * When the final reference is released, the string is\n * destroyed and its resources released.\n *\/\nvoid ph_string_delref(ph_string_t *str);\n\n\/** Append a memory buffer to a ph_string_t instance\n *\/\nph_result_t ph_string_append_buf(ph_string_t *str,\n    const char *buf, uint32_t len);\n\n\/** Append a string to a string\n *\n * The contents of `str` are appended to `target`\n *\/\nstatic inline ph_result_t ph_string_append_str(ph_string_t *target,\n    ph_string_t *str)\n{\n  return ph_string_append_buf(target, str-&gt;buf, str-&gt;len);\n}\n\n\/** Append a C-string to a ph_string_t instance\n *\/\nph_result_t ph_string_append_cstr(\n    ph_string_t *str, const char *cstr);\n\n\/** Append a series of UTF-16 code points to a string and encode as UTF-8\n *\n * * `codepoints` points to a buffer of code points\n * * `numpoints` specifies the number of code points\n * * `bytes` if not NULL, receives the number of UTF-8 bytes that were\n *   appended to the string\n *\/\nph_result_t ph_string_append_utf16_as_utf8(\n    ph_string_t *str, int32_t *codepoints, uint32_t numpoints,\n    uint32_t *bytes);\n\n\/** Iterate a sequence of UTF-8 characters, returning UTF-16 codepoints\n *\n * This function implements an iterator that knows how to decode UTF-8\n * encoded multibyte text into UTF-16 code points.\n *\n * To begin iterating, set `offset` to the starting offset of the UTF-8\n * text.  This offset is measured in bytes from the start of the data\n * in the string.\n *\n * UTF-8 bytes will be decoded from that position and a UTF-16 codepoint\n * will be stored into `*codepoint`.  `*offset` will be updated so that\n * it holds the offset of the next UTF-8 byte.\n *\n * If a UTF-16 byte was successfully decoded, returns `PH_OK`.\n * If a partial or invalid UTF-8 sequence was detected, returns `PH_ERR`.\n * If the end of the string was reached, returns `PH_DONE`.\n *\n * ```\n * uint32_t off = 0;\n * int32_t cp;\n *\n * while (ph_string_iterate_utf8_as_utf16(str, &amp;off, &amp;cp) == PH_OK) {\n *   \/\/ got a codepoint in cp\n * }\n * ```\n *\/\nph_result_t ph_string_iterate_utf8_as_utf16(\n    ph_string_t *str, uint32_t *offset, int32_t *codepoint);\n\n\/** Returns true if the string is valid UTF-8\n *\n * Checks the content of the string buffer, returns true if\n * we can iterate the length of the string and produce a valid\n * series of UTF-16 codepoints from it, or false otherwise.\n *\/\nbool ph_string_is_valid_utf8(ph_string_t *str);\n\nstatic inline uint8_t ph_utf8_seq_len(uint8_t first) {\n  if (first &lt; 0x80) {\n    return 1;\n  }\n  if (first &lt;= 0xc1) {\n    return 0;\n  }\n  if (first &lt;= 0xdf) {\n    return 2;\n  }\n  if (first &lt;= 0xef) {\n    return 3;\n  }\n  if (first &lt;= 0xf4) {\n    return 4;\n  }\n  return 0;\n}\n\n\/** Returns the length of the string contents, in bytes\n *\/\nstatic inline uint32_t ph_string_len(const ph_string_t *str) {\n  return str-&gt;len;\n}\n\n\/** Resets the string length to zero\n *\n * Sets the length to zero, effectively clearly the string\n * contents and rewinding the append position to the start\n * of the string.\n *\n * This is useful in cases where you desire to reuse the string\n * buffer and avoid additional heap allocations.\n *\/\nstatic inline void ph_string_reset(ph_string_t *str) {\n  str-&gt;len = 0;\n}\n\n\/** Compare the value of two strings for equality\n *\n * Return true if the strings are equal based on a raw binary\n * comparison of the string buffers.  This function ignores locale\n * and other nuances of multi-byte encodings.\n *\/\nbool ph_string_equal(const ph_string_t *a, const ph_string_t *b);\n\n\/** Compare the value of two strings for equality, case insensitive\n *\n * Return true the strings compare equal, with each byte passed\n * to the tolower() function.  Aside form lower casing each byte,\n * this function ignores locale and other nuances of multi-byte\n * encodings.\n *\/\nbool ph_string_equal_caseless(const ph_string_t *a, const ph_string_t *b);\n\n\/** Compare the value of the string against a C-string for equality\n *\/\nbool ph_string_equal_cstr(ph_string_t *a, const char *b);\n\n\/** Compare the value of two strings\n *\n * Compares two strings, returning an integer value less than\n * zero if `a` is considered less than `b`, 0 if `a` == `b` or\n * greater than zero if `a` is considered greater than `b`.\n *\n * This function ignores locale and other nuances of multi-byte encodings.\n *\/\nint ph_string_compare(const ph_string_t *a, const ph_string_t *b);\n\n\/** Formatted print to string\n *\/\nint ph_string_vprintf(ph_string_t *a, const char *fmt, va_list ap);\n\n\/** Formatted print to string\n *\n * Uses ph_vprintf_core()\n *\/\nint ph_string_printf(ph_string_t *a, const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 2, 3)))\n#endif\n  ;\n\n\/** Make a string from a formatted string\n *\/\nph_string_t *ph_string_make_printf(ph_memtype_t mt, uint32_t size,\n    const char *fmt, ...)\n#ifdef __GNUC__\n  __attribute__((format(printf, 3, 4)))\n#endif\n  ;\n\n#if 0 \/\/ Dummy for docs\n\/** Copy a NUL-terminated C-string from a ph_string to a stack buffer\n *\n * Since ph_string_t does not maintain C-string NUL termination,\n * and many library functions require a C-string representation,\n * there will be times where you need to get one.\n *\n * This macro declares a local variable named `localvarname` using\n * the C99 variable sized array feature to create a stack buffer,\n * and copies the string data to the stack buffer and null terminates\n * the buffer.\n *\n * Usage:\n *\n * ```\n * void open_a_file(ph_string_t *name) {\n *   PH_STRING_DECLARE_AND_COPY_CSTR(filename, name);\n *   int fd = open(filename, O_RDONLY);\n * }\n * ```\n *\/\nvoid PH_STRING_DECLARE_AND_COPY_CSTR(localvarname, ph_string_t *str);\n\n\/** Obtain a NUL-terminated C-string pointer from a ph_string\n *\n * This macro declares a local `const char *` variable named\n * `localvarname` and initializes it to reference a C-string representation\n * of the provided `str` parameter.\n *\n * If `str` happens to be NUL terminated, or can be safely NUL terminated,\n * `localvarname` is set to point to the buffer in `str` and no copying is\n * performed.\n *\n * If `str` cannot be NUL terminated, uses the C99 variable sized array\n * feature to create storage on the stack, copies the string data to\n * the stack, NUL-terminates it and sets `localvarname` to reference it.\n *\n * `localvarname` is a const variable because it may reference the internal\n * string buffer.  `localvarname` should be considered to be invalidated\n * by any changes made to the `str`.\n *\n * Usage:\n *\n * ```\n * void open_a_file(ph_string_t *name) {\n *   PH_STRING_DECLARE_CSTR_AVOID_COPY(filename, name);\n *   int fd = open(filename, O_RDONLY);\n * }\n * ```\n *\n * This is invalid usage because the string is modified:\n *\n * ```COUNTEREXAMPLE\n * void do_something(ph_string_t *name) {\n *   PH_STRING_DECLARE_CSTR_AVOID_COPY(namecstr, name);\n *   ph_string_append_cstr(name, &quot;woot&quot;);\n *   \/\/ WRONG! because the append above means that namecstr was invalidated\n *   \/\/ and is no longer safe to use\n *   ph_fd_printf(STDOUT_FILENO, &quot;namecstr is %s&quot;, namecstr);\n * }\n * ```\n *\/\nvoid PH_STRING_DECLARE_CSTR_AVOID_COPY(localvarname, ph_string_t *str);\n#endif\n\n#define PH_STRING_DECLARE_AND_COPY_CSTR(name, str) \\\n  char name[ph_string_len(str)+1]; \\\n  memcpy(name, (str)-&gt;buf, ph_string_len(str)); \\\n  name[ph_string_len(str)] = &#039;\\0&#039;\n\n\/\/ Check for, or arrange to, NUL terminate a string ready for grabbing\n\/\/ a c-string representation\nbool _ph_string_nul_terminated(ph_string_t *str);\n\n#define PH_STRING_DECLARE_CSTR_AVOID_COPY_INNER(name, namebuf, str) \\\n  bool ph_defs_paste1(namebuf, _terminated) = _ph_string_nul_terminated(str); \\\n  char namebuf[ph_defs_paste1(namebuf, _terminated) ? 1 : str-&gt;len + 1]; \\\n  const char *name = namebuf; \\\n  if (ph_defs_paste1(namebuf, _terminated)) { \\\n    name = str-&gt;buf; \\\n  } else { \\\n    memcpy(namebuf, str-&gt;buf, str-&gt;len); \\\n    namebuf[str-&gt;len] = &#039;\\0&#039;; \\\n  }\n\n#define PH_STRING_DECLARE_CSTR_AVOID_COPY(name, str) \\\n  PH_STRING_DECLARE_CSTR_AVOID_COPY_INNER(name, \\\n      ph_defs_gen_symbol(name##_avoid_copy_), (str))\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "sysutil": {
        "name": "sysutil",
        "title": "sysutil",
        "content": "\n# Utility Functions\n\nA slightly random set of helper functions.\n\n### ph_pipe\n\n```c\nph_result_t ph_pipe(ph_socket_t fds[2], int flags);\n```\n\n\n*Create a pipe and optional set flags.*\n\n\nThe flags parameter can be one or more of:\n\n* `PH_PIPE_NONBLOCK` - set non-blocking IO\n* `PH_PIPE_CLOEXEC` - set the CLOEXEC flag\n  or'd together.\n\n### ph_library_init\n\n```c\nph_result_t ph_library_init(void);\n```\n\n\n*Initialize the library*\n\n\nMust be called prior to calling into any other phenom\nlibrary functions.\n\nWhen invoked for the first time, invokes the `init` routines\nthat have been registered using the PH_LIBRARY_INIT() and\nPH_LIBRARY_INIT_PRI() macros.  The init routines are invoked\nin order of ascending priority.\n\nArranges for the `fini` routines to be called in order of descending\npriority when the process terminates, using atexit().\n\nph_library_init() is safe to be called concurrently from multiple\nthreads, and safe to invoke multiple times from the same thread.\n\nYou may use ph_library_init() to bootstrap the thread-local variables\nneeded for libphenom to operate.  See ph_thread_self().\n\n### ph_power_2\n\n```c\nuint32_t ph_power_2(uint32_t n)\n```\n\n\n*round up to next power of 2*\n\n\n### ph_num_cores\n\n```c\nuint32_t ph_num_cores(void);\n```\n\n\n*Return the number of physical cores in the system*\n\n\n### ph_mkostemp\n\n```c\nint ph_mkostemp(char *nametemplate, int flags);\n```\n\n\n*Generate a unique temporary file name and open it.*\n\nnametemplate must be of the form `\/path\/to\/fileXXXXXX`.  The\n'X' characters will be replaced by randomized characters.\nflags is passed to the underlying open(2) call.\n\nReturns the opened file descriptor, or -1 on error\n\n### ph_mkostemps\n\n```c\nint ph_mkostemps(char *nametemplate, int suffixlen, int flags);\n```\n\n\n*Generate a unique temporary name with a suffix and open it.*\n\nnametemplate must not be NULL; it must be of the form\n`\/path\/to\/fileXXXXXsuffix.`  The 'X' characters will be replaced\nby randomized characters.  suffixlen identifies the length of\nthe filename suffix.\n\nflags is passed to the underlying open(2) call.\n\nReturns the opened file descriptor, or -1 on error\n\n### ph_strerror\n\n```c\nconst char *ph_strerror(int errval);\n```\n\n\n*Thread-safe errno value to string conversion*\n\n\n### ph_strerror_r\n\n```c\nconst char *ph_strerror_r(int errval, char *buf, size_t len);\n```\n\n\n*Thread-safe errno value to string conversion*\n\n\n### ph_hash_bytes_murmur\n\n```c\nvoid ph_hash_bytes_murmur(const void *key, const int len,\n    const uint32_t seed, void *out);\n```\n\n\n*128-bit murmur hash implementation; result goes into out (which*\n\ncan just be a uint64_t[2]).\n",
        "decl_titles": [
            "ph_pipe",
            "ph_library_init",
            "ph_power_2",
            "ph_num_cores",
            "ph_mkostemp",
            "ph_mkostemps",
            "ph_strerror",
            "ph_strerror_r",
            "ph_hash_bytes_murmur"
        ],
        "raw_content": "\/*\n * Copyright 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_SYSUTIL_H\n#define PHENOM_SYSUTIL_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/socket.h&quot;\n#include &quot;phenom\/memory.h&quot;\n\n\/**\n * # Utility Functions\n *\n * A slightly random set of helper functions.\n *\/\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\n#ifndef MIN\n# define MIN(a, b) ((a) &lt; (b) ? (a) : (b))\n#endif\n#ifndef MAX\n# define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n#endif\n\n#define PH_PIPE_NONBLOCK 1\n#define PH_PIPE_CLOEXEC  2\n\/** Create a pipe and optional set flags.\n *\n * The flags parameter can be one or more of:\n *\n * * `PH_PIPE_NONBLOCK` - set non-blocking IO\n * * `PH_PIPE_CLOEXEC` - set the CLOEXEC flag\n *   or&#039;d together.\n *\/\nph_result_t ph_pipe(ph_socket_t fds[2], int flags);\n\nstruct ph_pingfd {\n  ph_socket_t fds[2];\n};\n\ntypedef struct ph_pingfd ph_pingfd_t;\n\nph_result_t ph_pingfd_init(ph_pingfd_t *pfd);\nph_result_t ph_pingfd_ping(ph_pingfd_t *pfd);\nph_result_t ph_pingfd_close(ph_pingfd_t *pfd);\nph_socket_t ph_pingfd_get_fd(ph_pingfd_t *pfd);\nbool ph_pingfd_consume_one(ph_pingfd_t *pfd);\nuint32_t ph_pingfd_consume_all(ph_pingfd_t *pfd);\n\nvoid ph_freedtoa(char *s);\nchar *ph_dtoa(double _d, int mode, int ndigits,\n    int *decpt, int *sign, char **rve);\ndouble ph_strtod(const char *s00, const char **se);\n\n\/** Initialize the library\n *\n * Must be called prior to calling into any other phenom\n * library functions.\n *\n * When invoked for the first time, invokes the `init` routines\n * that have been registered using the PH_LIBRARY_INIT() and\n * PH_LIBRARY_INIT_PRI() macros.  The init routines are invoked\n * in order of ascending priority.\n *\n * Arranges for the `fini` routines to be called in order of descending\n * priority when the process terminates, using atexit().\n *\n * ph_library_init() is safe to be called concurrently from multiple\n * threads, and safe to invoke multiple times from the same thread.\n *\n * You may use ph_library_init() to bootstrap the thread-local variables\n * needed for libphenom to operate.  See ph_thread_self().\n *\/\nph_result_t ph_library_init(void);\n\nstruct timeval ph_time_now(void);\n\n\/** round up to next power of 2 *\/\nstatic inline uint32_t ph_power_2(uint32_t n)\n{\n  n |= (n &gt;&gt; 16);\n  n |= (n &gt;&gt; 8);\n  n |= (n &gt;&gt; 4);\n  n |= (n &gt;&gt; 2);\n  n |= (n &gt;&gt; 1);\n  return n + 1;\n}\n\n\/** Return the number of physical cores in the system *\/\nuint32_t ph_num_cores(void);\n\n\/** Generate a unique temporary file name and open it.\n * nametemplate must be of the form `\/path\/to\/fileXXXXXX`.  The\n * &#039;X&#039; characters will be replaced by randomized characters.\n * flags is passed to the underlying open(2) call.\n *\n * Returns the opened file descriptor, or -1 on error\n *\/\nint ph_mkostemp(char *nametemplate, int flags);\n\n\/** Generate a unique temporary name with a suffix and open it.\n * nametemplate must not be NULL; it must be of the form\n * `\/path\/to\/fileXXXXXsuffix.`  The &#039;X&#039; characters will be replaced\n * by randomized characters.  suffixlen identifies the length of\n * the filename suffix.\n *\n * flags is passed to the underlying open(2) call.\n *\n * Returns the opened file descriptor, or -1 on error\n *\/\nint ph_mkostemps(char *nametemplate, int suffixlen, int flags);\n\n\/** Thread-safe errno value to string conversion *\/\nconst char *ph_strerror(int errval);\n\/** Thread-safe errno value to string conversion *\/\nconst char *ph_strerror_r(int errval, char *buf, size_t len);\n\n\/** 128-bit murmur hash implementation; result goes into out (which\n * can just be a uint64_t[2]). *\/\nvoid ph_hash_bytes_murmur(const void *key, const int len,\n    const uint32_t seed, void *out);\n\nvoid ph_debug_console_start(const char *unix_sock_path);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "thread": {
        "name": "thread",
        "title": "thread",
        "content": "\n### ph_thread_spawn\n\n```c\nph_thread_t *ph_thread_spawn(ph_thread_func func, void *arg);\n```\n\n\n*Spawn a thread*\n\n\n### ph_thread_join\n\n```c\nint ph_thread_join(ph_thread_t *thr, void **res);\n```\n\n\n*Wait for a thread to complete*\n\n\n### ph_thread_self\n\n```c\nph_thread_t *ph_thread_self(void)\n```\n\n\n*Return my own thread handle.*\n\n\nIf you create a thread for yourself, not using ph_thread_spawn(),\nyou must call ph_library_init() at least once prior to calling\nany phenom function in that thread.\n\nThis restriction avoids a conditional branch on every ph_thread_self() call,\nwhich can amount to over a million thread pool callback dispatches per\nsecond difference in throughput.\n\n### ph_thread_set_name\n\n```c\nvoid ph_thread_set_name(const char *name);\n```\n\n\n*Set the name of the currently executing thread.*\n\nUsed for debugging.  libPhenom will set this up\nwhen initializing thread pools, you probably don't\nneed to call it\n\n### ph_thread_set_affinity\n\n```c\nbool ph_thread_set_affinity(ph_thread_t *thr, int affinity);\n```\n\n\n*Set the affinity of a thread*\n\n\n### ph_thread_epoch_begin\n\n```c\nvoid ph_thread_epoch_begin(void);\n```\n\n\n*Begin a new epoch*\n\n\nMark the start of an epoch-protected code section.\nThe epoch is terminated by a call to ph_thread_epoch_end().\nIt is possible to nest an epoch within an existing epoch,\nbut the epoch will not end until the ph_thread_epoch_end() is\ncalled enough times to counter each ph_thread_epoch_begin()\ncall.\n\nYou do not typically need to call this function unless you\nare implementing a long-lived thread that does not participate\nin the NBIO or thread pool subsystems.\n\n### ph_thread_epoch_end\n\n```c\nvoid ph_thread_epoch_end(void);\n```\n\n\n*Mark the end of an epoch*\n\n\nMark the end of an epoch-protected code section.\n\nYou do not typically need to call this function unless you\nare implementing a long-lived thread that does not participate\nin the NBIO or thread pool subsystems.\n\n### ph_thread_epoch_defer\n\n```c\nvoid ph_thread_epoch_defer(ck_epoch_entry_t *entry, ck_epoch_cb_t *func);\n```\n\n\n*Defer a function call until a grace period has been detected in epoch*\n\n\nAll threads that may have held references to the object need to participate\nin the epoch for this to work as intended; once they do, the callback\nfunction will be invoked at a safe point where all observers have moved\nbeyond observing the object.\n\nThe epoch entry should to be embedded in the object in question.\nSee http:\/\/concurrencykit.org\/doc\/ck_epoch_call.html for more information\non the underlying implementation of this function.\n\n### ph_thread_epoch_poll\n\n```c\nbool ph_thread_epoch_poll(void);\n```\n\n\n*Attempt to dispatch any deferred epoch calls, if safe*\n\n\nReturns `true` if at least one function was dispatched.\nReturns `false` if it has determined that not all threads have\nobserved the latest generation of epoch-protected objects.\n\nNeither value indicates an error.\n\nYou do not typically need to call this function unless you\nare implementing a long-lived thread that does not participate\nin the NBIO or thread pool subsystems.\n\n### ph_thread_epoch_barrier\n\n```c\nvoid ph_thread_epoch_barrier(void);\n```\n\n\n*Synchronize and reclaim memory*\n\n\nYou must not call this from within an epoch-protected code section.\nThis means that you must not call this from within a job callback\nfunction or other epoch protected region.\n\nYou do not typically need to call this function unless you\nare implementing a long-lived thread that does not participate\nin the NBIO or thread pool subsystems.\n\n### ph_thread_emitter_affinity\n\n```c\nuint32_t ph_thread_emitter_affinity(void);\n```\n\n\n*Return the emitter affinity value for the currently executing thread*\n\n\nIf the thread is an emitter (one of the nbio threads), return an affinity\nvalue that can be set in job->affinity to cause a job to execute on the\nsame thread later.\n\nIf the thread is not an emitter, returns 0\n",
        "decl_titles": [
            "ph_thread_spawn",
            "ph_thread_join",
            "ph_thread_self",
            "ph_thread_set_name",
            "ph_thread_set_affinity",
            "ph_thread_epoch_begin",
            "ph_thread_epoch_end",
            "ph_thread_epoch_defer",
            "ph_thread_epoch_poll",
            "ph_thread_epoch_barrier",
            "ph_thread_emitter_affinity"
        ],
        "raw_content": "\/*\n * Copyright 2012-2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n#ifndef PHENOM_THREAD_H\n#define PHENOM_THREAD_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/queue.h&quot;\n#include &quot;phenom\/memory.h&quot;\n#include &lt;ck_stack.h&gt;\n#include &lt;ck_queue.h&gt;\n#include &lt;ck_epoch.h&gt;\n#include &lt;ck_hs.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nstruct ph_thread;\nstruct ph_job;\nstruct ph_thread_pool;\nstruct ph_nbio_emitter;\n\ntypedef struct ph_thread ph_thread_t;\n\nstruct ph_thread {\n  bool refresh_time;\n  \/\/ internal monotonic thread id\n  uint32_t tid;\n\n  PH_STAILQ_HEAD(pdisp, ph_job) pending_nbio, pending_pool;\n  struct ph_nbio_emitter *is_emitter;\n\n  int is_worker;\n  struct timeval now;\n\n  ck_epoch_record_t epoch_record;\n  ck_hs_t counter_hs;\n  \/\/ linkage so that a stat reader can find all counters\n  ck_stack_entry_t thread_linkage;\n\n  \/\/ OS level representation\n  pthread_t thr;\n\n  \/\/ If part of a pool, linkage in that pool\n  CK_LIST_ENTRY(ph_thread) pool_ent;\n\n  pid_t lwpid;\n\n#ifdef HAVE_STRERROR_R\n  char strerror_buf[128];\n#endif\n\n  \/\/ Name for debugging purposes\n  char name[16];\n};\n\nstruct ph_thread_pool;\ntypedef struct ph_thread_pool ph_thread_pool_t;\n\ntypedef void *(*ph_thread_func)(void *arg);\n\n\/** Spawn a thread *\/\nph_thread_t *ph_thread_spawn(ph_thread_func func, void *arg);\n\n\/** Wait for a thread to complete *\/\nint ph_thread_join(ph_thread_t *thr, void **res);\n\nph_thread_t *ph_thread_self_slow(void);\n\nextern pthread_key_t __ph_thread_key;\n#ifdef HAVE___THREAD\nextern __thread ph_thread_t *__ph_thread_self;\n# define ph_thread_self_fast()   (__ph_thread_self)\n#else\n# define ph_thread_self_fast()   \\\n  ((ph_thread_t*)pthread_getspecific(__ph_thread_key))\n#endif\n\n\/** Return my own thread handle.\n *\n * If you create a thread for yourself, not using ph_thread_spawn(),\n * you must call ph_library_init() at least once prior to calling\n * any phenom function in that thread.\n *\n * This restriction avoids a conditional branch on every ph_thread_self() call,\n * which can amount to over a million thread pool callback dispatches per\n * second difference in throughput.\n *\/\nstatic inline ph_thread_t *ph_thread_self(void)\n{\n  ph_thread_t *me = ph_thread_self_fast();\n\n#if 0 \/* enabling this costs 1mm dispatches per second *\/\n  if (ph_unlikely(me == NULL)) {\n    return ph_thread_self_slow();\n  }\n#endif\n  return me;\n}\n\n\/** Set the name of the currently executing thread.\n * Used for debugging.  libPhenom will set this up\n * when initializing thread pools, you probably don&#039;t\n * need to call it *\/\nvoid ph_thread_set_name(const char *name);\n\n\/** Set the affinity of a thread *\/\nbool ph_thread_set_affinity(ph_thread_t *thr, int affinity);\n\n\/** Begin a new epoch\n *\n * Mark the start of an epoch-protected code section.\n * The epoch is terminated by a call to ph_thread_epoch_end().\n * It is possible to nest an epoch within an existing epoch,\n * but the epoch will not end until the ph_thread_epoch_end() is\n * called enough times to counter each ph_thread_epoch_begin()\n * call.\n *\n * You do not typically need to call this function unless you\n * are implementing a long-lived thread that does not participate\n * in the NBIO or thread pool subsystems.\n *\/\nvoid ph_thread_epoch_begin(void);\n\n\/** Mark the end of an epoch\n *\n * Mark the end of an epoch-protected code section.\n *\n * You do not typically need to call this function unless you\n * are implementing a long-lived thread that does not participate\n * in the NBIO or thread pool subsystems.\n *\/\nvoid ph_thread_epoch_end(void);\n\n\/** Defer a function call until a grace period has been detected in epoch\n *\n * All threads that may have held references to the object need to participate\n * in the epoch for this to work as intended; once they do, the callback\n * function will be invoked at a safe point where all observers have moved\n * beyond observing the object.\n *\n * The epoch entry should to be embedded in the object in question.\n * See http:\/\/concurrencykit.org\/doc\/ck_epoch_call.html for more information\n * on the underlying implementation of this function.\n *\/\nvoid ph_thread_epoch_defer(ck_epoch_entry_t *entry, ck_epoch_cb_t *func);\n\n\/** Attempt to dispatch any deferred epoch calls, if safe\n *\n * Returns `true` if at least one function was dispatched.\n * Returns `false` if it has determined that not all threads have\n * observed the latest generation of epoch-protected objects.\n *\n * Neither value indicates an error.\n *\n * You do not typically need to call this function unless you\n * are implementing a long-lived thread that does not participate\n * in the NBIO or thread pool subsystems.\n *\/\nbool ph_thread_epoch_poll(void);\n\n\/** Synchronize and reclaim memory\n *\n * You must not call this from within an epoch-protected code section.\n * This means that you must not call this from within a job callback\n * function or other epoch protected region.\n *\n * You do not typically need to call this function unless you\n * are implementing a long-lived thread that does not participate\n * in the NBIO or thread pool subsystems.\n *\/\nvoid ph_thread_epoch_barrier(void);\n\n\/** Return the emitter affinity value for the currently executing thread\n *\n * If the thread is an emitter (one of the nbio threads), return an affinity\n * value that can be set in job-&gt;affinity to cause a job to execute on the\n * same thread later.\n *\n * If the thread is not an emitter, returns 0\n *\/\nuint32_t ph_thread_emitter_affinity(void);\n\nvoid ph_counter_tear_down_thread(ph_thread_t *thr);\nvoid ph_counter_init_thread(ph_thread_t *thr);\nextern ck_stack_t ph_thread_all_threads;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "timerwheel": {
        "name": "timerwheel",
        "title": "timerwheel",
        "content": "\n# Timer Wheel\n\nThis borrows from the concepts explored in the paper:\n\"Hashed and Hierarchical Timing Wheels: Effcient\nData Structures for Implementing a Timer Facility by\nGeorge Varghese and Anthony Lauck\"\n\nWe model timers as the number of ticks until the next\ndue event.  We allow 32-bits of space to track this\ndue interval, and break that into 4 regions of 8 bits.\nEach region indexes into a bucket of 256 lists.\n\nBucket 0 represents those events that are due the soonest.\nEach tick causes us to look at the next list in a bucket.\nThe 0th list in a bucket is special; it means that it is time to\nflush the timers from the next higher bucket and schedule them\ninto a different bucket.\n\nThis technique results in a very cheap mechanism for\nmaintaining time and timers, provided that we can maintain\na consistent rate of ticks.\n\n### ph_timerwheel_init\n\n```c\nph_result_t ph_timerwheel_init(\n    ph_timerwheel_t *wheel,\n    struct timeval now,\n    uint32_t tick_resolution);\n```\n\n\n*Initialize a timerwheel*\n\ntick_resolution specifies how many milliseconds comprise a tick.\n\n### ph_timerwheel_disable\n\n```c\nph_result_t ph_timerwheel_disable(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer)\n```\n\n\n*Disable a timer that is already in the timerwheel.*\n\nIt remains in the timerwheel until removed.\nYou may re-enable it using ph_timerwheel_enable().\nIf the wheel ticks and dispatches a disabled timer,\nit simply skips over it.\n\n### ph_timerwheel_enable\n\n```c\nph_result_t ph_timerwheel_enable(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer);\n```\n\n\n*Enable a timer.*\n\nCan be used to insert a new timer or re-enable a disabled timer.\n\n\n### ph_timerwheel_remove\n\n```c\nph_result_t ph_timerwheel_remove(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer);\n```\n\n\n*Remove an element from the timerwheel*\n\n\n### ph_timerwheel_tick\n\n```c\nuint32_t ph_timerwheel_tick(\n    ph_timerwheel_t *wheel,\n    struct timeval now,\n    ph_timerwheel_should_dispatch_func_t should_dispatch,\n    ph_timerwheel_dispatch_func_t dispatch,\n    void *arg);\n```\n\n\n*Tick and dispatch any due timer(s).*\n\n\nYou must arrange for the wheel to tick over at least\nonce every tick_resolution milliseconds to avoid\nfalling behind.\n\nYou supply the current time when you call this function.\nThe wheel will tick through and dispatch any due (or overdue!)\ntimers by invoking your dispatch function.\n\nReturns the number of timers that were dispatched.\n",
        "decl_titles": [
            "ph_timerwheel_init",
            "ph_timerwheel_disable",
            "ph_timerwheel_enable",
            "ph_timerwheel_remove",
            "ph_timerwheel_tick"
        ],
        "raw_content": "\/*\n * Copyright 2012 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\n\/**\n * # Timer Wheel\n *\n * This borrows from the concepts explored in the paper:\n * &quot;Hashed and Hierarchical Timing Wheels: Effcient\n * Data Structures for Implementing a Timer Facility by\n * George Varghese and Anthony Lauck&quot;\n *\n * We model timers as the number of ticks until the next\n * due event.  We allow 32-bits of space to track this\n * due interval, and break that into 4 regions of 8 bits.\n * Each region indexes into a bucket of 256 lists.\n *\n * Bucket 0 represents those events that are due the soonest.\n * Each tick causes us to look at the next list in a bucket.\n * The 0th list in a bucket is special; it means that it is time to\n * flush the timers from the next higher bucket and schedule them\n * into a different bucket.\n *\n * This technique results in a very cheap mechanism for\n * maintaining time and timers, provided that we can maintain\n * a consistent rate of ticks.\n *\/\n\n#ifndef PHENOM_TIMERWHEEL_H\n#define PHENOM_TIMERWHEEL_H\n\n#include &lt;phenom\/defs.h&gt;\n#include &lt;phenom\/thread.h&gt;\n#include &lt;phenom\/queue.h&gt;\n#include &lt;ck_rwlock.h&gt;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\nPH_LIST_HEAD(\n    ph_timerwheel_list,\n    ph_timerwheel_timer);\n\nstruct ph_timerwheel_timer {\n  PH_LIST_ENTRY(ph_timerwheel_timer) t;\n  struct ph_timerwheel_list *list;\n  struct timeval due;\n  int enable;\n#define PH_TIMER_DISABLED    0\n#define PH_TIMER_ENABLED     1\n#define PH_TIMER_LOCKED      2\n};\n\n#define PHENOM_WHEEL_BITS 8\n#define PHENOM_WHEEL_SIZE (1 &lt;&lt; PHENOM_WHEEL_BITS)\n#define PHENOM_WHEEL_MASK (PHENOM_WHEEL_SIZE - 1)\n\nstruct ph_timerwheel {\n  struct timeval next_run;\n  uint32_t tick_resolution;\n  ck_rwlock_t lock;\n  struct {\n    struct ph_timerwheel_list lists[PHENOM_WHEEL_SIZE];\n  } buckets[4];\n};\n\ntypedef struct ph_timerwheel ph_timerwheel_t;\n\n\/** Initialize a timerwheel\n * tick_resolution specifies how many milliseconds comprise a tick.\n *\/\nph_result_t ph_timerwheel_init(\n    ph_timerwheel_t *wheel,\n    struct timeval now,\n    uint32_t tick_resolution);\n\n\/** Disable a timer that is already in the timerwheel.\n * It remains in the timerwheel until removed.\n * You may re-enable it using ph_timerwheel_enable().\n * If the wheel ticks and dispatches a disabled timer,\n * it simply skips over it.\n *\/\nstatic inline ph_result_t ph_timerwheel_disable(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer)\n{\n  ph_unused_parameter(wheel);\n\n  if (ck_pr_load_int(&amp;timer-&gt;enable) == PH_TIMER_DISABLED) {\n    return PH_OK;\n  }\n\n  if (ck_pr_cas_int(&amp;timer-&gt;enable, PH_TIMER_ENABLED, PH_TIMER_DISABLED)) {\n    return PH_OK;\n  }\n\n  return PH_BUSY;\n}\n\n\n\/** Enable a timer.\n * Can be used to insert a new timer or re-enable a disabled timer.\n * *\/\nph_result_t ph_timerwheel_enable(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer);\n\n\/** Remove an element from the timerwheel *\/\nph_result_t ph_timerwheel_remove(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer);\n\n\/* Called by the wheel to advise that a timer will be dispatched\n * imminently.  This gives you the opportunity to take steps to make\n * this safe.  Return true to allow the timer to be dispatched or\n * false to ignore it.  Returning false deactivates the timer.\n * This is called under the wheel lock *\/\ntypedef bool (*ph_timerwheel_should_dispatch_func_t)(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer,\n    struct timeval now,\n    void *arg);\n\n\/* Called by the wheel to actually dispatch a timer *\/\ntypedef void (*ph_timerwheel_dispatch_func_t)(\n    ph_timerwheel_t *wheel,\n    struct ph_timerwheel_timer *timer,\n    struct timeval now,\n    void *arg);\n\n\/** Tick and dispatch any due timer(s).\n *\n * You must arrange for the wheel to tick over at least\n * once every tick_resolution milliseconds to avoid\n * falling behind.\n *\n * You supply the current time when you call this function.\n * The wheel will tick through and dispatch any due (or overdue!)\n * timers by invoking your dispatch function.\n *\n * Returns the number of timers that were dispatched.\n *\/\nuint32_t ph_timerwheel_tick(\n    ph_timerwheel_t *wheel,\n    struct timeval now,\n    ph_timerwheel_should_dispatch_func_t should_dispatch,\n    ph_timerwheel_dispatch_func_t dispatch,\n    void *arg);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    },
    "variant": {
        "name": "variant",
        "title": "variant",
        "content": "\n# Variant Data Type\n\nVariants can represent runtime variable values and are primarily\nuseful when it comes to serialization to\/from the JSON or BSER encoding\nformats.\n\nNote: JSON requires that all strings be UTF-8 encoded, but these\nfunctions won't validate the strings you pass into them because there\nare situations where binary string support is desirable or essential.\nYou may use ph_string_is_valid_utf8() to check for correctness.\n\n## Building Values\n\nThis section describes functions that help to create, or pack, complex\nvalues, especially nested objects and arrays. Value building is based on a\nformat string that is used to tell the functions about the expected\narguments.  The builder API is derived from equivalent functionality in\nthe excellent [Jansson](http:\/\/www.digip.org\/jansson\/) library.\n\nFor example, the format string `i` specifies a single integer value, while\nthe format string `[ssb]` or the equivalent `[s, s, b]` specifies an array\nvalue with two strings and a boolean as its items:\n\n```\n\/\/ Create the integer 42\nph_variant_t *v = ph_var_pack(\"i\", 42);\n\n\/\/ Create the array [\"foo\", \"bar\", true]\nv = ph_var_pack(\"[ssb]\", \"foo\", \"bar\", true);\n```\n\nHere's the full list of format characters. The type in parentheses denotes\nthe resulting variant type, and the type in brackets (if any) denotes the\nC type that is expected as the corresponding argument.\n\n`z` (string) [const char \\*]\nConvert a NULL (`z`ero) terminated C-string to a variant string.\nThe string is copied and a fresh ph_string_t is constructed.\n\n`s` (string) [ph_string_t \\*]\nConvert a ph_string_t reference to a variant string.  Does not add a\nreference to the provided string; the reference is stolen by the container.\n\n`S` (string) [ph_string_t \\*]\nConvert a ph_string_t reference to a variant string.  Adds a reference\nto the provided string.\n\n`n` (null)\nOutput a variant null value. No argument is consumed.\n\n`b` (boolean) [int]\nConvert a C int to variant boolean value. Zero is converted to false and\nnon-zero to true.\n\n`i` (integer) [int]\nConvert a C int to variant integer.\n\n`I` (integer) [int64_t]\nConvert a C int64_t to variant integer.\n\n`f` (real) [double]\nConvert a C double to variant real.\n\n`o` (any value) [ph_variant_t \\*]\nOutput any given variant value as-is. If the value is added to an array or\nobject, the reference to the value passed to o is stolen by the container.\n\n`O` (any value) [ph_variant_t \\*]\nLike o, but the argument's reference count is incremented. This is useful\nif you pack into an array or object and want to keep the reference for the\nvariant value consumed by `O` to yourself.\n\n`[fmt]` (array)\nBuild an array with contents from the inner format string. fmt may contain\nobjects and arrays, i.e. recursive value building is supported.\n\n`{fmt}` (object)\nBuild an object with contents from the inner format string fmt. The first,\nthird, etc. format character represent a key, and must be `s` (as object keys\nare always strings). The second, fourth, etc. format character represent a\nvalue. Any value may be an object or array, i.e. recursive value building\nis supported.\n\nWhitespace, `:` and `,` are ignored; you may use them to improve the\nreadability of your format strings.\n\nMore examples:\n\n```\n\/\/ Build an empty variant object\nph_var_pack(NULL, \"{}\");\n\n\/\/ Build the variant object {\"foo\": 42, \"bar\": 7}\nph_var_pack(NULL, \"{sisi}\", \"foo\", 42, \"bar\", 7);\n\n\/\/ Like above, ':', ',' and whitespace are ignored\nph_var_pack(NULL, \"{s:i, s:i}\", \"foo\", 42, \"bar\", 7);\n\n\/\/ Build the variant array [[1, 2], {\"cool\": true}]\nph_var_pack(NULL, \"[[i,i],{s:b}]\", 1, 2, \"cool\", true);\n```\n\n## Parsing and Validating Values\n\nThis section describes functions that help to validate complex values and\nextract, or unpack, data from them. Like building values, this is also\nbased on format strings.\n\nWhile a variant value is unpacked, the type specified in the format string\nis checked to match that of the variant value.  This is the validation part\nof the process. In addition to this, the unpacking functions can also check\nthat all items of arrays and objects are unpacked. This check be enabled\nwith the format character `!` or by using the flag `PH_VAR_STRICT`.\nSee below for details.\n\nHere's the full list of format characters. The type in parentheses denotes\nthe variant type, and the type in brackets (if any) denotes the C type\nwhose address should be passed.\n\n`s` (string) [ph_string_t \\*]\nStore the string pointer into the ph_string_t parameter.  The reference\ncount is not incremented.\n\n`S` (string) [ph_string_t \\*]\nStore the string pointer into the ph_string_t parameter.  The reference\nis incremented.\n\n`n` (null)\nExpect a variant null value. Nothing is extracted.\n\n`b` (boolean) [bool]\nConvert a variant boolean value to a C bool.\n\n`i` (integer) [int]\nConvert a variant integer to C int.\n\n`I` (integer) [int64_t]\nConvert a variant integer to C int64_t.\n\n`f` (real) [double]\nConvert a variant real to C double.\n\n`F` (integer or real) [double]\nConvert a variant number (integer or real) to C double.\n\n`o` (any value) [ph_variant_t \\*]\nStore a variant value with no conversion to a ph_variant_t pointer.\n\n`O` (any value) [ph_variant_t \\*]\nLike `O`, but the variant value's reference count is incremented.\n\n`[fmt]` (array)\nConvert each item in the variant array according to the inner format string.\nfmt may contain objects and arrays, i.e. recursive value extraction is\nsupported.\n\n`{fmt}` (object)\nConvert each item in the variant object according to the inner format\nstring fmt. The first, third, etc. format character represent a key, and\nmust be `s`. The corresponding argument to unpack functions is read as the\nobject key. The second fourth, etc. format character represent a value and\nis written to the address given as the corresponding argument. Note that\nevery other argument is read from and every other is written to.\n\nfmt may contain objects and arrays as values, i.e. recursive value\nextraction is supporetd.\n\nAny `s` representing a key may be suffixed with a `?` to make the key\noptional. If the key is not found, nothing is extracted. See below for\nan example.\n\n`!`\nThis special format character is used to enable the check that all object\nand array items are accessed, on a per-value basis. It must appear inside\nan array or object as the last format character before the closing bracket\nor brace. To enable the check globally, use the `PH_VAR_STRICT` unpacking\nflag.\n\n`*`\nThis special format character is the opposite of `!`. If the `PH_VAR_STRICT`\nflag is used, `*` can be used to disable the strict check on a per-value\nbasis. It must appear inside an array or object as the last format\ncharacter before the closing bracket or brace.\n\nWhitespace, `:` and `,` are ignored; you may use them to improve the\nreadability of your format strings.\n\nThe following unpacking flags are available:\n\n* `PH_VAR_STRICT` - Enable the extra validation step checking that all\n  object and array items are unpacked. This is equivalent to appending the\n  format character `!` to the end of every array and object in the format\n  string.\n* `PH_VAR_VALIDATE_ONLY` - Don't extract any data, just validate the value\n  against the given format string. Note that object keys must still be\n  specified after the format string.\n\nExamples:\n```\n\/\/ root is the variant integer 42\nint myint;\nph_var_unpack(root, &err, 0, \"i\", &myint);\nassert(myint == 42);\n\n\/\/ root is the variant object {\"foo\": \"bar\", \"quux\": true}\nph_string_t *str;\nint boolean;\nph_var_unpack(root, &err, 0, \"{s:s, s:b}\", \"foo\", &str, \"quux\", &boolean);\nassert(strcmp(str, \"bar\") == 0 && boolean == 1);\n\n\/\/ root is the variant array [[1, 2], {\"baz\": null}\nph_var_unpack(root, &err, PH_VAR_VALIDATE_ONLY, \"[[i,i], {s:n}]\", \"baz\");\n\/\/ returns PH_OK for validation success, nothing is extracted\n\n\/\/ root is the variant array [1, 2, 3, 4, 5]\nint myint1, myint2;\nph_var_unpack(root, &err, 0, \"[ii!]\", &myint1, &myint2);\n\/\/ returns -1 for failed validation\n\n\/\/ root is an empty variant object\nint myint = 0, myint2 = 0;\nph_var_unpack(root, &err, 0, \"{s?i, s?[ii]}\",\n            \"foo\", &myint1,\n            \"bar\", &myint2, &myint3);\n\/\/ myint1, myint2 or myint3 is no touched as \"foo\" and \"bar\" don't exist\n```\n\n# JSONPath style queries\n\nSimple [JSONPath](http:\/\/goessner.net\/articles\/JsonPath\/) style queries may be\nused to interrogate variants.  libPhenom supports only a limited subset of\nJSONPath.\n\nThe query must be started at the root (using the `$` character) and will\nreturn only a single value; wildcard selection is not supported.\n\n* `$` selects the root object\n* `.` focuses on a child of the current cursor\n* `name` selects an object with the specified name\n* `[1]` selects the 2nd array element from the current cursor (arrays are zero\n   based).\n\nFor example, given the object:\n\n```json\n{\n  \"one\": {\n    \"two\": [\"a\", \"b\", \"c\", {\n      \"lemon\": \"cake\"\n    }]\n  }\n}\n```\n\nThe query `$.one.two[2]` produces the value `\"c\"`, while the\nquery `$.one.two[3].lemon` produces the value `\"cake\"`.\n\nUse ph_var_jsonpath_get() to issue JSONPath style queries.\n\n### struct ph_variant\n\n```c\ntypedef struct ph_variant ph_variant_t;\n```\n\n\n*Represents a runtime variable data type*\n\n\n### ph_var_type\n\n```c\nph_variant_type_t ph_var_type(const ph_variant_t *var)\n```\n\n\n*Returns the type of a variant*\n\n\n### ph_var_bool\n\n```c\nph_variant_t *ph_var_bool(bool val);\n```\n\n\n*Construct a boolean variant value*\n\n\n### ph_var_bool_val\n\n```c\nbool ph_var_bool_val(ph_variant_t *var)\n```\n\n\n*Returns the boolean value of a boolean variant*\n\n\nReturns false if the variant is not actually a boolean.\n\n### ph_var_is_boolean\n\n```c\nbool ph_var_is_boolean(ph_variant_t *var)\n```\n\n\n*Returns true if the variant is a boolean*\n\n\n### ph_var_null\n\n```c\nph_variant_t *ph_var_null(void);\n```\n\n\n*Construct a null variant value*\n\n\n### ph_var_is_null\n\n```c\nbool ph_var_is_null(ph_variant_t *var)\n```\n\n\n*Returns true if the variant is a NULL value*\n\n\n### ph_var_delref\n\n```c\nvoid ph_var_delref(ph_variant_t *var);\n```\n\n\n*Release a variant value*\n\n\n### ph_var_addref\n\n```c\nvoid ph_var_addref(ph_variant_t *var)\n```\n\n\n*Add a reference to a variant value*\n\n\n### ph_var_int\n\n```c\nph_variant_t *ph_var_int(int64_t ival);\n```\n\n\n*Construct an integer variant value*\n\n\n### ph_var_int_val\n\n```c\nint64_t ph_var_int_val(const ph_variant_t *var)\n```\n\n\n*Returns the integer value of a variant*\n\n\nReturns 0 if the value is not an integer\n\n### ph_var_is_int\n\n```c\nbool ph_var_is_int(ph_variant_t *var)\n```\n\n\n*Returns true if the variant holds an integer value*\n\n\n### ph_var_double\n\n```c\nph_variant_t *ph_var_double(double dval);\n```\n\n\n*Construct a real variant value*\n\n\n### ph_var_double_val\n\n```c\ndouble ph_var_double_val(const ph_variant_t *var)\n```\n\n\n*Returns the double value of a variant*\n\n\nReturns 0.0 if the value is not a double\n\n### ph_var_is_double\n\n```c\nbool ph_var_is_double(ph_variant_t *var)\n```\n\n\n*Returns true if the variant holds a double value*\n\n\n### ph_var_string_claim\n\n```c\nph_variant_t *ph_var_string_claim(ph_string_t *str);\n```\n\n\n*Construct and claim a string variant value*\n\n\nThis steals a reference from str.\n\n### ph_var_string_make\n\n```c\nph_variant_t *ph_var_string_make(ph_string_t *str);\n```\n\n\n*Construct a string variant value*\n\n\nAdds a reference to str and wraps it in a variant.\n\n### ph_var_string_make_cstr\n\n```c\nph_variant_t *ph_var_string_make_cstr(const char *cstr);\n```\n\n\n*Construct a variant from a C-string*\n\n\n### ph_var_string_val\n\n```c\nph_string_t *ph_var_string_val(const ph_variant_t *var)\n```\n\n\n*Returns the string value of a variant*\n\n\nReturns NULL if the variant does not hold a string.\n\nDoes **not** add a reference to the string value.\n\n### ph_var_is_string\n\n```c\nbool ph_var_is_string(ph_variant_t *var)\n```\n\n\n*Returns true if a variant contains a string value*\n\n\n### ph_var_array\n\n```c\nph_variant_t *ph_var_array(uint32_t nelems);\n```\n\n\n*Construct a variant array*\n\n\nIt is pre-sized to hold the specified number of elements, but\nis initially empty.\n\n### ph_var_array_size\n\n```c\nuint32_t ph_var_array_size(ph_variant_t *var)\n```\n\n\n*Returns the number of elements in the variant array.*\n\n\nReturns 0 if the variant is not an array.\n\n### ph_var_is_array\n\n```c\nbool ph_var_is_array(ph_variant_t *var)\n```\n\n\n*Returns true if the variant is an array*\n\n\n### ph_var_array_append\n\n```c\nph_result_t ph_var_array_append(ph_variant_t *arr, ph_variant_t *val);\n```\n\n\n*Append a variant to an array*\n\n\nThe array may need to be grown to accommodate the new value,\nin which case the append operation can fail and this function\nwill return `PH_NOMEM`.\n\nIf successful, adds a reference to the added value and returns `PH_OK`.\n\n### ph_var_array_append_claim\n\n```c\nph_result_t ph_var_array_append_claim(ph_variant_t *arr, ph_variant_t *val);\n```\n\n\n*Append a variant to an array and claim its reference*\n\n\nThe array may need to be grown to accommodate the new value,\nin which case the append operation can fail and this function\nwill return `PH_NOMEM`.\n\nIf successful, returns `PH_OK`.\n\n### ph_var_array_get\n\n```c\nph_variant_t *ph_var_array_get(ph_variant_t *arr, uint32_t pos)\n```\n\n\n*Get array element at a given position*\n\n\nReturns the array element, borrowing its reference (addref is not\ncalled).\n\n### ph_var_array_set_claim\n\n```c\nph_result_t ph_var_array_set_claim(ph_variant_t *arr, uint32_t pos,\n    ph_variant_t *val);\n```\n\n\n*Set array element at a given position to val, and claim its reference.*\n\n\nReplaces the value at the given position.  You may not use this\nfunction to create a hole in the array. Valid positions are 0 through\nthe length of the array.\n\n### ph_var_array_set\n\n```c\nph_result_t ph_var_array_set(ph_variant_t *arr, uint32_t pos,\n    ph_variant_t *val);\n```\n\n\n*Set array element at a given position to val.*\n\n\nReplaces the value at the given position.  You may not use this\nfunction to create a hole in the array. Valid positions are 0 through\nthe length of the array.\n\nIf successful, adds a reference to the value.\n\n### ph_var_object\n\n```c\nph_variant_t *ph_var_object(uint32_t nelems);\n```\n\n\n*Construct a variant object*\n\n\nIt is pre-sized to hold the specified number of elements, but is\ninitially empty.\n\n### ph_var_is_object\n\n```c\nbool ph_var_is_object(ph_variant_t *var)\n```\n\n\n*Returns true if the variant is an object*\n\n\n### ph_var_object_size\n\n```c\nuint32_t ph_var_object_size(ph_variant_t *var);\n```\n\n\n*Returns the number of key\/value pairs in an object*\n\n\n### ph_var_object_set_claim_kv\n\n```c\nph_result_t ph_var_object_set_claim_kv(ph_variant_t *obj,\n    ph_string_t *key, ph_variant_t *val);\n```\n\n\n*Set or replace a key\/value pair, claiming the key and value*\n\n\n### ph_var_object_set\n\n```c\nph_result_t ph_var_object_set(ph_variant_t *obj,\n    ph_string_t *key, ph_variant_t *val);\n```\n\n\n*Set or replace a key\/value pair, adding a ref to key and value.*\n\n\n### ph_var_object_set_claim_cstr\n\n```c\nph_result_t ph_var_object_set_claim_cstr(ph_variant_t *obj,\n    const char *cstr, ph_variant_t *val);\n```\n\n\n*Set or replace a key\/value pair, claiming the value*\n\n\nThis variation allows setting the key using a C-string\n\n### ph_var_object_del\n\n```c\nph_result_t ph_var_object_del(ph_variant_t *obj, ph_string_t *key);\n```\n\n\n*Delete a key\/value pair*\n\n\n### ph_var_object_get\n\n```c\nph_variant_t *ph_var_object_get(ph_variant_t *obj, ph_string_t *key);\n```\n\n\n*Get the value for a given key*\n\n\nReturns NULL if the key isn't present in the object, otherwise\nreturns a borrowed reference to the value.\n\n### ph_var_object_get_cstr\n\n```c\nph_variant_t *ph_var_object_get_cstr(ph_variant_t *obj, const char *key);\n```\n\n\n*Get the value for a given C-string key*\n\n\nReturns NULL if the key isn't present in the object, otherwise\nreturns a borrowed reference to the value.\n\n### ph_var_object_iter_first\n\n```c\nbool ph_var_object_iter_first(ph_variant_t *obj, ph_ht_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n```\n\n\n*Begin iterating an object value*\n\n\nDelegates to ph_ht_iter_first()\n\n### ph_var_object_iter_next\n\n```c\nbool ph_var_object_iter_next(ph_variant_t *obj, ph_ht_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n```\n\n\n*Continue iterating an object value*\n\n\n### ph_var_object_ordered_iter_first\n\n```c\nbool ph_var_object_ordered_iter_first(ph_variant_t *obj,\n    ph_ht_ordered_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n```\n\n\n*Begin iterating an object value in key order*\n\n\nDelegates to ph_ht_ordered_iter_first().\nYou must call ph_var_object_ordered_iter_end() to release the iterator\nwhen you have finished iterating.\n\n### ph_var_object_ordered_iter_next\n\n```c\nbool ph_var_object_ordered_iter_next(ph_variant_t *obj,\n    ph_ht_ordered_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n```\n\n\n*Continue iterating an object value*\n\n\nYou must call ph_var_object_ordered_iter_end() to release the iterator\nwhen you have finished iterating.\n\n### ph_var_object_ordered_iter_end\n\n```c\nvoid ph_var_object_ordered_iter_end(ph_variant_t *obj,\n    ph_ht_ordered_iter_t *iter);\n```\n\n\n*Release ordered iterator resources*\n\n\n### ph_var_equal\n\n```c\nbool ph_var_equal(ph_variant_t *a, ph_variant_t *b);\n```\n\n\n*Compare two variants for equality*\n\n\n* Two integer or real values are equal if their contained numeric values\n  are equal.  An integer value is never equal to a real value.\n* Two strings are equal if their bit strings are equal, byte by byte.\n* Two arrays are equal if they have the same number of elements and each\n  element in the first array is equal to the corresponding element in the\n  second array.\n* Two objects are equal if they have exactly the same keys and the value\n  for each key in the first object is equal to the value of the corresponding\n  key in the second object.\n* Two true, false or null values are equal if their types are equal\n\nph_var_equal() returns true if the values are equal, false otherwise.\n\n### ph_var_pack\n\n```c\nph_variant_t *ph_var_pack(ph_var_err_t *error, const char *fmt, ...);\n```\n\n\n*Build a new variant value based on a format string*\n\n\nFor each format character (except for `{}[]n`), one argument\nis consumed and used to build the corresponding value.\n\nSee [the section above on Building Values](#variant--Building-Values).\n\nReturns `NULL` on error.\n\n### ph_var_vpack\n\n```c\nph_variant_t *ph_var_vpack(ph_var_err_t *error, const char *fmt, va_list ap);\n```\n\n\n*Build a new variant value based on a format string*\n\n\nFor each format character (except for `{}[]n`), one argument\nis consumed and used to build the corresponding value.\n\nSee [the section above on Building Values](#variant--Building-Values).\n\nReturns `NULL` on error.\n\n### ph_var_unpack\n\n```c\nph_result_t ph_var_unpack(ph_variant_t *root, ph_var_err_t *error,\n    uint32_t flags, const char *fmt, ...);\n```\n\n\n*Parse a variant into native C values*\n\n\nSee [the section above on Parsing and Validating values\n](#variant--Parsing-and-Validating-Values).\n\nReturns `PH_OK` on success.\n\n### ph_var_vunpack\n\n```c\nph_result_t ph_var_vunpack(ph_variant_t *root, ph_var_err_t *error,\n    uint32_t flags, const char *fmt, va_list ap);\n```\n\n\n*Parse a variant into native C values*\n\n\nSee [the section above on Parsing and Validating values\n](#variant--Parsing-and-Validating-Values).\n\nReturns `PH_OK` on success.\n\n### ph_var_jsonpath_get\n\n```c\nph_variant_t *ph_var_jsonpath_get(ph_variant_t *var, const char *path);\n```\n\n\n*Evaluate a JSONPath style expression.*\n\n\nlibPhenom supports a limited subset of JSONPath; see [the start of this\ndocument](#variant--JSONPath-style-queries) for more details on the supported syntax.\n\nReturns a borrowed reference on the matching element if found, else\nreturns NULL pointer.\n",
        "decl_titles": [
            "struct ph_variant",
            "ph_var_type",
            "ph_var_bool",
            "ph_var_bool_val",
            "ph_var_is_boolean",
            "ph_var_null",
            "ph_var_is_null",
            "ph_var_delref",
            "ph_var_addref",
            "ph_var_int",
            "ph_var_int_val",
            "ph_var_is_int",
            "ph_var_double",
            "ph_var_double_val",
            "ph_var_is_double",
            "ph_var_string_claim",
            "ph_var_string_make",
            "ph_var_string_make_cstr",
            "ph_var_string_val",
            "ph_var_is_string",
            "ph_var_array",
            "ph_var_array_size",
            "ph_var_is_array",
            "ph_var_array_append",
            "ph_var_array_append_claim",
            "ph_var_array_get",
            "ph_var_array_set_claim",
            "ph_var_array_set",
            "ph_var_object",
            "ph_var_is_object",
            "ph_var_object_size",
            "ph_var_object_set_claim_kv",
            "ph_var_object_set",
            "ph_var_object_set_claim_cstr",
            "ph_var_object_del",
            "ph_var_object_get",
            "ph_var_object_get_cstr",
            "ph_var_object_iter_first",
            "ph_var_object_iter_next",
            "ph_var_object_ordered_iter_first",
            "ph_var_object_ordered_iter_next",
            "ph_var_object_ordered_iter_end",
            "ph_var_equal",
            "ph_var_pack",
            "ph_var_vpack",
            "ph_var_unpack",
            "ph_var_vunpack",
            "ph_var_jsonpath_get"
        ],
        "raw_content": "\/*\n * Copyright 2013 Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\/\n\/* Portions of the code and the bulk of the pack\/unpack documentation are:\n * Copyright (c) 2009-2012 Petri Lehtinen &lt;petri@digip.org&gt;\n *\n * Jansson is free software; you can redistribute it and\/or modify\n * it under the terms of the MIT license. See LICENSE for details.\n *\/\n\n\/**\n * # Variant Data Type\n *\n * Variants can represent runtime variable values and are primarily\n * useful when it comes to serialization to\/from the JSON or BSER encoding\n * formats.\n *\n * Note: JSON requires that all strings be UTF-8 encoded, but these\n * functions won&#039;t validate the strings you pass into them because there\n * are situations where binary string support is desirable or essential.\n * You may use ph_string_is_valid_utf8() to check for correctness.\n *\n * ## Building Values\n *\n * This section describes functions that help to create, or pack, complex\n * values, especially nested objects and arrays. Value building is based on a\n * format string that is used to tell the functions about the expected\n * arguments.  The builder API is derived from equivalent functionality in\n * the excellent [Jansson](http:\/\/www.digip.org\/jansson\/) library.\n *\n * For example, the format string `i` specifies a single integer value, while\n * the format string `[ssb]` or the equivalent `[s, s, b]` specifies an array\n * value with two strings and a boolean as its items:\n *\n * ```\n * \/\/ Create the integer 42\n * ph_variant_t *v = ph_var_pack(&quot;i&quot;, 42);\n *\n * \/\/ Create the array [&quot;foo&quot;, &quot;bar&quot;, true]\n * v = ph_var_pack(&quot;[ssb]&quot;, &quot;foo&quot;, &quot;bar&quot;, true);\n * ```\n *\n * Here&#039;s the full list of format characters. The type in parentheses denotes\n * the resulting variant type, and the type in brackets (if any) denotes the\n * C type that is expected as the corresponding argument.\n *\n * `z` (string) [const char \\*]\n * Convert a NULL (`z`ero) terminated C-string to a variant string.\n * The string is copied and a fresh ph_string_t is constructed.\n *\n * `s` (string) [ph_string_t \\*]\n * Convert a ph_string_t reference to a variant string.  Does not add a\n * reference to the provided string; the reference is stolen by the container.\n *\n * `S` (string) [ph_string_t \\*]\n * Convert a ph_string_t reference to a variant string.  Adds a reference\n * to the provided string.\n *\n * `n` (null)\n * Output a variant null value. No argument is consumed.\n *\n * `b` (boolean) [int]\n * Convert a C int to variant boolean value. Zero is converted to false and\n * non-zero to true.\n *\n * `i` (integer) [int]\n * Convert a C int to variant integer.\n *\n * `I` (integer) [int64_t]\n * Convert a C int64_t to variant integer.\n *\n * `f` (real) [double]\n * Convert a C double to variant real.\n *\n * `o` (any value) [ph_variant_t \\*]\n * Output any given variant value as-is. If the value is added to an array or\n * object, the reference to the value passed to o is stolen by the container.\n *\n * `O` (any value) [ph_variant_t \\*]\n * Like o, but the argument&#039;s reference count is incremented. This is useful\n * if you pack into an array or object and want to keep the reference for the\n * variant value consumed by `O` to yourself.\n *\n * `[fmt]` (array)\n * Build an array with contents from the inner format string. fmt may contain\n * objects and arrays, i.e. recursive value building is supported.\n *\n * `{fmt}` (object)\n * Build an object with contents from the inner format string fmt. The first,\n * third, etc. format character represent a key, and must be `s` (as object keys\n * are always strings). The second, fourth, etc. format character represent a\n * value. Any value may be an object or array, i.e. recursive value building\n * is supported.\n *\n * Whitespace, `:` and `,` are ignored; you may use them to improve the\n * readability of your format strings.\n *\n * More examples:\n *\n * ```\n * \/\/ Build an empty variant object\n * ph_var_pack(NULL, &quot;{}&quot;);\n *\n * \/\/ Build the variant object {&quot;foo&quot;: 42, &quot;bar&quot;: 7}\n * ph_var_pack(NULL, &quot;{sisi}&quot;, &quot;foo&quot;, 42, &quot;bar&quot;, 7);\n *\n * \/\/ Like above, &#039;:&#039;, &#039;,&#039; and whitespace are ignored\n * ph_var_pack(NULL, &quot;{s:i, s:i}&quot;, &quot;foo&quot;, 42, &quot;bar&quot;, 7);\n *\n * \/\/ Build the variant array [[1, 2], {&quot;cool&quot;: true}]\n * ph_var_pack(NULL, &quot;[[i,i],{s:b}]&quot;, 1, 2, &quot;cool&quot;, true);\n * ```\n *\n * ## Parsing and Validating Values\n *\n * This section describes functions that help to validate complex values and\n * extract, or unpack, data from them. Like building values, this is also\n * based on format strings.\n *\n * While a variant value is unpacked, the type specified in the format string\n * is checked to match that of the variant value.  This is the validation part\n * of the process. In addition to this, the unpacking functions can also check\n * that all items of arrays and objects are unpacked. This check be enabled\n * with the format character `!` or by using the flag `PH_VAR_STRICT`.\n * See below for details.\n *\n * Here&#039;s the full list of format characters. The type in parentheses denotes\n * the variant type, and the type in brackets (if any) denotes the C type\n * whose address should be passed.\n *\n * `s` (string) [ph_string_t \\*]\n * Store the string pointer into the ph_string_t parameter.  The reference\n * count is not incremented.\n *\n * `S` (string) [ph_string_t \\*]\n * Store the string pointer into the ph_string_t parameter.  The reference\n * is incremented.\n *\n * `n` (null)\n * Expect a variant null value. Nothing is extracted.\n *\n * `b` (boolean) [bool]\n * Convert a variant boolean value to a C bool.\n *\n * `i` (integer) [int]\n * Convert a variant integer to C int.\n *\n * `I` (integer) [int64_t]\n * Convert a variant integer to C int64_t.\n *\n * `f` (real) [double]\n * Convert a variant real to C double.\n *\n * `F` (integer or real) [double]\n * Convert a variant number (integer or real) to C double.\n *\n * `o` (any value) [ph_variant_t \\*]\n * Store a variant value with no conversion to a ph_variant_t pointer.\n *\n * `O` (any value) [ph_variant_t \\*]\n * Like `O`, but the variant value&#039;s reference count is incremented.\n *\n * `[fmt]` (array)\n * Convert each item in the variant array according to the inner format string.\n * fmt may contain objects and arrays, i.e. recursive value extraction is\n * supported.\n *\n * `{fmt}` (object)\n * Convert each item in the variant object according to the inner format\n * string fmt. The first, third, etc. format character represent a key, and\n * must be `s`. The corresponding argument to unpack functions is read as the\n * object key. The second fourth, etc. format character represent a value and\n * is written to the address given as the corresponding argument. Note that\n * every other argument is read from and every other is written to.\n *\n * fmt may contain objects and arrays as values, i.e. recursive value\n * extraction is supporetd.\n *\n * Any `s` representing a key may be suffixed with a `?` to make the key\n * optional. If the key is not found, nothing is extracted. See below for\n * an example.\n *\n * `!`\n * This special format character is used to enable the check that all object\n * and array items are accessed, on a per-value basis. It must appear inside\n * an array or object as the last format character before the closing bracket\n * or brace. To enable the check globally, use the `PH_VAR_STRICT` unpacking\n * flag.\n *\n * `*`\n * This special format character is the opposite of `!`. If the `PH_VAR_STRICT`\n * flag is used, `*` can be used to disable the strict check on a per-value\n * basis. It must appear inside an array or object as the last format\n * character before the closing bracket or brace.\n *\n * Whitespace, `:` and `,` are ignored; you may use them to improve the\n * readability of your format strings.\n *\n * The following unpacking flags are available:\n *\n * * `PH_VAR_STRICT` - Enable the extra validation step checking that all\n *   object and array items are unpacked. This is equivalent to appending the\n *   format character `!` to the end of every array and object in the format\n *   string.\n * * `PH_VAR_VALIDATE_ONLY` - Don&#039;t extract any data, just validate the value\n *   against the given format string. Note that object keys must still be\n *   specified after the format string.\n *\n * Examples:\n```\n\/\/ root is the variant integer 42\nint myint;\nph_var_unpack(root, &amp;err, 0, &quot;i&quot;, &amp;myint);\nassert(myint == 42);\n\n\/\/ root is the variant object {&quot;foo&quot;: &quot;bar&quot;, &quot;quux&quot;: true}\nph_string_t *str;\nint boolean;\nph_var_unpack(root, &amp;err, 0, &quot;{s:s, s:b}&quot;, &quot;foo&quot;, &amp;str, &quot;quux&quot;, &amp;boolean);\nassert(strcmp(str, &quot;bar&quot;) == 0 &amp;&amp; boolean == 1);\n\n\/\/ root is the variant array [[1, 2], {&quot;baz&quot;: null}\nph_var_unpack(root, &amp;err, PH_VAR_VALIDATE_ONLY, &quot;[[i,i], {s:n}]&quot;, &quot;baz&quot;);\n\/\/ returns PH_OK for validation success, nothing is extracted\n\n\/\/ root is the variant array [1, 2, 3, 4, 5]\nint myint1, myint2;\nph_var_unpack(root, &amp;err, 0, &quot;[ii!]&quot;, &amp;myint1, &amp;myint2);\n\/\/ returns -1 for failed validation\n\n\/\/ root is an empty variant object\nint myint = 0, myint2 = 0;\nph_var_unpack(root, &amp;err, 0, &quot;{s?i, s?[ii]}&quot;,\n            &quot;foo&quot;, &amp;myint1,\n            &quot;bar&quot;, &amp;myint2, &amp;myint3);\n\/\/ myint1, myint2 or myint3 is no touched as &quot;foo&quot; and &quot;bar&quot; don&#039;t exist\n```\n *\n * # JSONPath style queries\n *\n * Simple [JSONPath](http:\/\/goessner.net\/articles\/JsonPath\/) style queries may be\n * used to interrogate variants.  libPhenom supports only a limited subset of\n * JSONPath.\n *\n * The query must be started at the root (using the `$` character) and will\n * return only a single value; wildcard selection is not supported.\n *\n * * `$` selects the root object\n * * `.` focuses on a child of the current cursor\n * * `name` selects an object with the specified name\n * * `[1]` selects the 2nd array element from the current cursor (arrays are zero\n *    based).\n *\n * For example, given the object:\n *\n```json\n{\n  &quot;one&quot;: {\n    &quot;two&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, {\n      &quot;lemon&quot;: &quot;cake&quot;\n    }]\n  }\n}\n```\n *\n * The query `$.one.two[2]` produces the value `&quot;c&quot;`, while the\n * query `$.one.two[3].lemon` produces the value `&quot;cake&quot;`.\n *\n * Use ph_var_jsonpath_get() to issue JSONPath style queries.\n *\/\n\n#ifndef PHENOM_VARIANT_H\n#define PHENOM_VARIANT_H\n\n#include &quot;phenom\/defs.h&quot;\n#include &quot;phenom\/refcnt.h&quot;\n#include &quot;phenom\/memory.h&quot;\n#include &quot;phenom\/queue.h&quot;\n#include &quot;phenom\/hashtable.h&quot;\n#include &quot;phenom\/string.h&quot;\n\n#ifdef __cplusplus\nextern &quot;C&quot; {\n#endif\n\ntypedef enum {\n  PH_VAR_OBJECT,\n  PH_VAR_ARRAY,\n  PH_VAR_STRING,\n  PH_VAR_INTEGER,\n  PH_VAR_REAL,\n  PH_VAR_TRUE,\n  PH_VAR_FALSE,\n  PH_VAR_NULL\n} ph_variant_type_t;\n\nstruct ph_variant {\n  ph_refcnt_t ref;\n  ph_variant_type_t type;\n  union {\n    int64_t ival;\n    double  dval;\n    ph_string_t *sval;\n    struct {\n      uint32_t len, alloc;\n      struct ph_variant **arr;\n    } aval;\n    ph_ht_t oval;\n  } u;\n};\n\n\/** Represents a runtime variable data type *\/\ntypedef struct ph_variant ph_variant_t;\n\n#define PH_VAR_ERROR_TEXT_LENGTH    160\nstruct ph_var_err {\n  uint32_t line, column, position;\n  \/\/ Transient failures are likely due to memory limitations or any class\n  \/\/ of issue that means that a later attempt to parse this same data might\n  \/\/ result in a successful outcome.\n  bool transient;\n  char text[PH_VAR_ERROR_TEXT_LENGTH];\n};\ntypedef struct ph_var_err ph_var_err_t;\n\n\n\/** Returns the type of a variant *\/\nstatic inline ph_variant_type_t ph_var_type(const ph_variant_t *var) {\n  return var-&gt;type;\n}\n\n\/** Construct a boolean variant value *\/\nph_variant_t *ph_var_bool(bool val);\n\n\/** Returns the boolean value of a boolean variant\n *\n * Returns false if the variant is not actually a boolean.\n *\/\nstatic inline bool ph_var_bool_val(ph_variant_t *var) {\n  if (var-&gt;type == PH_VAR_TRUE) {\n    return true;\n  }\n  return false;\n}\n\n\/** Returns true if the variant is a boolean *\/\nstatic inline bool ph_var_is_boolean(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_TRUE || var-&gt;type == PH_VAR_FALSE;\n}\n\n\/** Construct a null variant value *\/\nph_variant_t *ph_var_null(void);\n\n\/** Returns true if the variant is a NULL value *\/\nstatic inline bool ph_var_is_null(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_NULL;\n}\n\n\/** Release a variant value *\/\nvoid ph_var_delref(ph_variant_t *var);\n\n\/** Add a reference to a variant value *\/\nstatic inline void ph_var_addref(ph_variant_t *var) {\n  ph_refcnt_add(&amp;var-&gt;ref);\n}\n\n\/** Construct an integer variant value *\/\nph_variant_t *ph_var_int(int64_t ival);\n\n\/** Returns the integer value of a variant\n *\n * Returns 0 if the value is not an integer\n *\/\nstatic inline int64_t ph_var_int_val(const ph_variant_t *var) {\n  switch (var-&gt;type) {\n    case PH_VAR_INTEGER:\n      return var-&gt;u.ival;\n    default:\n      return 0;\n  }\n}\n\n\/** Returns true if the variant holds an integer value *\/\nstatic inline bool ph_var_is_int(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_INTEGER;\n}\n\n\/** Construct a real variant value *\/\nph_variant_t *ph_var_double(double dval);\n\n\/** Returns the double value of a variant\n *\n * Returns 0.0 if the value is not a double\n *\/\nstatic inline double ph_var_double_val(const ph_variant_t *var) {\n  switch (var-&gt;type) {\n    case PH_VAR_REAL:\n      return var-&gt;u.dval;\n    default:\n      return 0.0;\n  }\n}\n\n\/** Returns true if the variant holds a double value *\/\nstatic inline bool ph_var_is_double(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_REAL;\n}\n\n\/** Construct and claim a string variant value\n *\n * This steals a reference from str.\n *\/\nph_variant_t *ph_var_string_claim(ph_string_t *str);\n\n\/** Construct a string variant value\n *\n * Adds a reference to str and wraps it in a variant.\n *\/\nph_variant_t *ph_var_string_make(ph_string_t *str);\n\n\/** Construct a variant from a C-string\n *\/\nph_variant_t *ph_var_string_make_cstr(const char *cstr);\n\n\/** Returns the string value of a variant\n *\n * Returns NULL if the variant does not hold a string.\n *\n * Does **not** add a reference to the string value.\n *\/\nstatic inline ph_string_t *ph_var_string_val(const ph_variant_t *var) {\n  switch (var-&gt;type) {\n    case PH_VAR_STRING:\n      return var-&gt;u.sval;\n    default:\n      return 0;\n  }\n}\n\n\/** Returns true if a variant contains a string value *\/\nstatic inline bool ph_var_is_string(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_STRING;\n}\n\n\/** Construct a variant array\n *\n * It is pre-sized to hold the specified number of elements, but\n * is initially empty.\n *\/\nph_variant_t *ph_var_array(uint32_t nelems);\n\n\/** Returns the number of elements in the variant array.\n *\n * Returns 0 if the variant is not an array.\n *\/\nstatic inline uint32_t ph_var_array_size(ph_variant_t *var) {\n  switch (var-&gt;type) {\n    case PH_VAR_ARRAY:\n      return var-&gt;u.aval.len;\n    default:\n      return 0;\n  }\n}\n\n\/** Returns true if the variant is an array *\/\nstatic inline bool ph_var_is_array(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_ARRAY;\n}\n\n\/** Append a variant to an array\n *\n * The array may need to be grown to accommodate the new value,\n * in which case the append operation can fail and this function\n * will return `PH_NOMEM`.\n *\n * If successful, adds a reference to the added value and returns `PH_OK`.\n *\/\nph_result_t ph_var_array_append(ph_variant_t *arr, ph_variant_t *val);\n\n\/** Append a variant to an array and claim its reference\n *\n * The array may need to be grown to accommodate the new value,\n * in which case the append operation can fail and this function\n * will return `PH_NOMEM`.\n *\n * If successful, returns `PH_OK`.\n *\/\nph_result_t ph_var_array_append_claim(ph_variant_t *arr, ph_variant_t *val);\n\n\/** Get array element at a given position\n *\n * Returns the array element, borrowing its reference (addref is not\n * called).\n *\/\nstatic inline ph_variant_t *ph_var_array_get(ph_variant_t *arr, uint32_t pos)\n{\n  switch (arr-&gt;type) {\n    case PH_VAR_ARRAY:\n      if (pos &gt;= arr-&gt;u.aval.len) {\n        return NULL;\n      }\n      return arr-&gt;u.aval.arr[pos];\n    default:\n      return NULL;\n  }\n}\n\n\/** Set array element at a given position to val, and claim its reference.\n *\n * Replaces the value at the given position.  You may not use this\n * function to create a hole in the array. Valid positions are 0 through\n * the length of the array.\n *\/\nph_result_t ph_var_array_set_claim(ph_variant_t *arr, uint32_t pos,\n    ph_variant_t *val);\n\n\/** Set array element at a given position to val.\n *\n * Replaces the value at the given position.  You may not use this\n * function to create a hole in the array. Valid positions are 0 through\n * the length of the array.\n *\n * If successful, adds a reference to the value.\n *\/\nph_result_t ph_var_array_set(ph_variant_t *arr, uint32_t pos,\n    ph_variant_t *val);\n\n\/** Construct a variant object\n *\n * It is pre-sized to hold the specified number of elements, but is\n * initially empty.\n *\/\nph_variant_t *ph_var_object(uint32_t nelems);\n\n\/** Returns true if the variant is an object *\/\nstatic inline bool ph_var_is_object(ph_variant_t *var) {\n  return var-&gt;type == PH_VAR_OBJECT;\n}\n\n\/** Returns the number of key\/value pairs in an object\n *\/\nuint32_t ph_var_object_size(ph_variant_t *var);\n\n\/** Set or replace a key\/value pair, claiming the key and value\n *\/\nph_result_t ph_var_object_set_claim_kv(ph_variant_t *obj,\n    ph_string_t *key, ph_variant_t *val);\n\n\/** Set or replace a key\/value pair, adding a ref to key and value.\n *\/\nph_result_t ph_var_object_set(ph_variant_t *obj,\n    ph_string_t *key, ph_variant_t *val);\n\n\/** Set or replace a key\/value pair, claiming the value\n *\n * This variation allows setting the key using a C-string\n *\/\nph_result_t ph_var_object_set_claim_cstr(ph_variant_t *obj,\n    const char *cstr, ph_variant_t *val);\n\n\/** Delete a key\/value pair\n *\/\nph_result_t ph_var_object_del(ph_variant_t *obj, ph_string_t *key);\n\n\/** Get the value for a given key\n *\n * Returns NULL if the key isn&#039;t present in the object, otherwise\n * returns a borrowed reference to the value.\n *\/\nph_variant_t *ph_var_object_get(ph_variant_t *obj, ph_string_t *key);\n\n\/** Get the value for a given C-string key\n *\n * Returns NULL if the key isn&#039;t present in the object, otherwise\n * returns a borrowed reference to the value.\n *\/\nph_variant_t *ph_var_object_get_cstr(ph_variant_t *obj, const char *key);\n\n\/** Begin iterating an object value\n *\n * Delegates to ph_ht_iter_first()\n *\/\nbool ph_var_object_iter_first(ph_variant_t *obj, ph_ht_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n\n\/** Continue iterating an object value\n *\/\nbool ph_var_object_iter_next(ph_variant_t *obj, ph_ht_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n\n\/** Begin iterating an object value in key order\n *\n * Delegates to ph_ht_ordered_iter_first().\n * You must call ph_var_object_ordered_iter_end() to release the iterator\n * when you have finished iterating.\n *\/\nbool ph_var_object_ordered_iter_first(ph_variant_t *obj,\n    ph_ht_ordered_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n\n\/** Continue iterating an object value\n *\n * You must call ph_var_object_ordered_iter_end() to release the iterator\n * when you have finished iterating.\n *\/\nbool ph_var_object_ordered_iter_next(ph_variant_t *obj,\n    ph_ht_ordered_iter_t *iter,\n    ph_string_t **key, ph_variant_t **val);\n\n\/** Release ordered iterator resources\n *\/\nvoid ph_var_object_ordered_iter_end(ph_variant_t *obj,\n    ph_ht_ordered_iter_t *iter);\n\n\/** Compare two variants for equality\n *\n * * Two integer or real values are equal if their contained numeric values\n *   are equal.  An integer value is never equal to a real value.\n * * Two strings are equal if their bit strings are equal, byte by byte.\n * * Two arrays are equal if they have the same number of elements and each\n *   element in the first array is equal to the corresponding element in the\n *   second array.\n * * Two objects are equal if they have exactly the same keys and the value\n *   for each key in the first object is equal to the value of the corresponding\n *   key in the second object.\n * * Two true, false or null values are equal if their types are equal\n *\n * ph_var_equal() returns true if the values are equal, false otherwise.\n *\/\nbool ph_var_equal(ph_variant_t *a, ph_variant_t *b);\n\n#define PH_VAR_VALIDATE_ONLY 1\n#define PH_VAR_STRICT 2\n\n\/** Build a new variant value based on a format string\n *\n * For each format character (except for `{}[]n`), one argument\n * is consumed and used to build the corresponding value.\n *\n * See [the section above on Building Values](#variant--Building-Values).\n *\n * Returns `NULL` on error.\n *\/\nph_variant_t *ph_var_pack(ph_var_err_t *error, const char *fmt, ...);\n\n\/** Build a new variant value based on a format string\n *\n * For each format character (except for `{}[]n`), one argument\n * is consumed and used to build the corresponding value.\n *\n * See [the section above on Building Values](#variant--Building-Values).\n *\n * Returns `NULL` on error.\n *\/\nph_variant_t *ph_var_vpack(ph_var_err_t *error, const char *fmt, va_list ap);\n\n\/** Parse a variant into native C values\n *\n * See [the section above on Parsing and Validating values\n * ](#variant--Parsing-and-Validating-Values).\n *\n * Returns `PH_OK` on success.\n *\/\nph_result_t ph_var_unpack(ph_variant_t *root, ph_var_err_t *error,\n    uint32_t flags, const char *fmt, ...);\n\n\/** Parse a variant into native C values\n *\n * See [the section above on Parsing and Validating values\n * ](#variant--Parsing-and-Validating-Values).\n *\n * Returns `PH_OK` on success.\n *\/\nph_result_t ph_var_vunpack(ph_variant_t *root, ph_var_err_t *error,\n    uint32_t flags, const char *fmt, va_list ap);\n\n\/** Evaluate a JSONPath style expression.\n *\n * libPhenom supports a limited subset of JSONPath; see [the start of this\n * document](#variant--JSONPath-style-queries) for more details on the supported syntax.\n *\n * Returns a borrowed reference on the matching element if found, else\n * returns NULL pointer.\n *\/\nph_variant_t *ph_var_jsonpath_get(ph_variant_t *var, const char *path);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n\/* vim:ts=2:sw=2:et:\n *\/\n\n"
    }
};
